"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prism-react-renderer";
exports.ids = ["vendor-chunks/prism-react-renderer"];
exports.modules = {

/***/ "(ssr)/./node_modules/prism-react-renderer/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/prism-react-renderer/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Prism: () => (/* reexport safe */ _prism_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   defaultProps: () => (/* binding */ defaultProps)\n/* harmony export */ });\n/* harmony import */ var _prism_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../prism/index.js */ \"(ssr)/./node_modules/prism-react-renderer/prism/index.js\");\n/* harmony import */ var _themes_duotoneDark__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../themes/duotoneDark */ \"(ssr)/./node_modules/prism-react-renderer/themes/duotoneDark/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\nvar defaultProps = {\n    // $FlowFixMe\n    Prism: _prism_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n    theme: _themes_duotoneDark__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n};\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nvar newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\nvar normalizeEmptyLines = function(line) {\n    if (line.length === 0) {\n        line.push({\n            types: [\n                \"plain\"\n            ],\n            content: \"\\n\",\n            empty: true\n        });\n    } else if (line.length === 1 && line[0].content === \"\") {\n        line[0].content = \"\\n\";\n        line[0].empty = true;\n    }\n};\nvar appendTypes = function(types, add) {\n    var typesSize = types.length;\n    if (typesSize > 0 && types[typesSize - 1] === add) {\n        return types;\n    }\n    return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\nvar normalizeTokens = function(tokens) {\n    var typeArrStack = [\n        []\n    ];\n    var tokenArrStack = [\n        tokens\n    ];\n    var tokenArrIndexStack = [\n        0\n    ];\n    var tokenArrSizeStack = [\n        tokens.length\n    ];\n    var i = 0;\n    var stackIndex = 0;\n    var currentLine = [];\n    var acc = [\n        currentLine\n    ];\n    while(stackIndex > -1){\n        while((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]){\n            var content = void 0;\n            var types = typeArrStack[stackIndex];\n            var tokenArr = tokenArrStack[stackIndex];\n            var token = tokenArr[i]; // Determine content and append type to types if necessary\n            if (typeof token === \"string\") {\n                types = stackIndex > 0 ? types : [\n                    \"plain\"\n                ];\n                content = token;\n            } else {\n                types = appendTypes(types, token.type);\n                if (token.alias) {\n                    types = appendTypes(types, token.alias);\n                }\n                content = token.content;\n            } // If token.content is an array, increase the stack depth and repeat this while-loop\n            if (typeof content !== \"string\") {\n                stackIndex++;\n                typeArrStack.push(types);\n                tokenArrStack.push(content);\n                tokenArrIndexStack.push(0);\n                tokenArrSizeStack.push(content.length);\n                continue;\n            } // Split by newlines\n            var splitByNewlines = content.split(newlineRe);\n            var newlineCount = splitByNewlines.length;\n            currentLine.push({\n                types: types,\n                content: splitByNewlines[0]\n            }); // Create a new line for each string on a new line\n            for(var i$1 = 1; i$1 < newlineCount; i$1++){\n                normalizeEmptyLines(currentLine);\n                acc.push(currentLine = []);\n                currentLine.push({\n                    types: types,\n                    content: splitByNewlines[i$1]\n                });\n            }\n        } // Decreate the stack depth\n        stackIndex--;\n        typeArrStack.pop();\n        tokenArrStack.pop();\n        tokenArrIndexStack.pop();\n        tokenArrSizeStack.pop();\n    }\n    normalizeEmptyLines(currentLine);\n    return acc;\n};\nvar themeToDict = function(theme, language) {\n    var plain = theme.plain; // $FlowFixMe\n    var base = Object.create(null);\n    var themeDict = theme.styles.reduce(function(acc, themeEntry) {\n        var languages = themeEntry.languages;\n        var style = themeEntry.style;\n        if (languages && !languages.includes(language)) {\n            return acc;\n        }\n        themeEntry.types.forEach(function(type) {\n            // $FlowFixMe\n            var accStyle = _extends({}, acc[type], style);\n            acc[type] = accStyle;\n        });\n        return acc;\n    }, base); // $FlowFixMe\n    themeDict.root = plain; // $FlowFixMe\n    themeDict.plain = _extends({}, plain, {\n        backgroundColor: null\n    });\n    return themeDict;\n};\nfunction objectWithoutProperties(obj, exclude) {\n    var target = {};\n    for(var k in obj)if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n    return target;\n}\nvar Highlight = /*@__PURE__*/ function(Component) {\n    function Highlight() {\n        var this$1 = this;\n        var args = [], len = arguments.length;\n        while(len--)args[len] = arguments[len];\n        Component.apply(this, args);\n        _defineProperty(this, \"getThemeDict\", function(props) {\n            if (this$1.themeDict !== undefined && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {\n                return this$1.themeDict;\n            }\n            this$1.prevTheme = props.theme;\n            this$1.prevLanguage = props.language;\n            var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;\n            return this$1.themeDict = themeDict;\n        });\n        _defineProperty(this, \"getLineProps\", function(ref) {\n            var key = ref.key;\n            var className = ref.className;\n            var style = ref.style;\n            var rest$1 = objectWithoutProperties(ref, [\n                \"key\",\n                \"className\",\n                \"style\",\n                \"line\"\n            ]);\n            var rest = rest$1;\n            var output = _extends({}, rest, {\n                className: \"token-line\",\n                style: undefined,\n                key: undefined\n            });\n            var themeDict = this$1.getThemeDict(this$1.props);\n            if (themeDict !== undefined) {\n                output.style = themeDict.plain;\n            }\n            if (style !== undefined) {\n                output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n            }\n            if (key !== undefined) {\n                output.key = key;\n            }\n            if (className) {\n                output.className += \" \" + className;\n            }\n            return output;\n        });\n        _defineProperty(this, \"getStyleForToken\", function(ref) {\n            var types = ref.types;\n            var empty = ref.empty;\n            var typesSize = types.length;\n            var themeDict = this$1.getThemeDict(this$1.props);\n            if (themeDict === undefined) {\n                return undefined;\n            } else if (typesSize === 1 && types[0] === \"plain\") {\n                return empty ? {\n                    display: \"inline-block\"\n                } : undefined;\n            } else if (typesSize === 1 && !empty) {\n                return themeDict[types[0]];\n            }\n            var baseStyle = empty ? {\n                display: \"inline-block\"\n            } : {}; // $FlowFixMe\n            var typeStyles = types.map(function(type) {\n                return themeDict[type];\n            });\n            return Object.assign.apply(Object, [\n                baseStyle\n            ].concat(typeStyles));\n        });\n        _defineProperty(this, \"getTokenProps\", function(ref) {\n            var key = ref.key;\n            var className = ref.className;\n            var style = ref.style;\n            var token = ref.token;\n            var rest$1 = objectWithoutProperties(ref, [\n                \"key\",\n                \"className\",\n                \"style\",\n                \"token\"\n            ]);\n            var rest = rest$1;\n            var output = _extends({}, rest, {\n                className: \"token \" + token.types.join(\" \"),\n                children: token.content,\n                style: this$1.getStyleForToken(token),\n                key: undefined\n            });\n            if (style !== undefined) {\n                output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n            }\n            if (key !== undefined) {\n                output.key = key;\n            }\n            if (className) {\n                output.className += \" \" + className;\n            }\n            return output;\n        });\n        _defineProperty(this, \"tokenize\", function(Prism, code, grammar, language) {\n            var env = {\n                code: code,\n                grammar: grammar,\n                language: language,\n                tokens: []\n            };\n            Prism.hooks.run(\"before-tokenize\", env);\n            var tokens = env.tokens = Prism.tokenize(env.code, env.grammar, env.language);\n            Prism.hooks.run(\"after-tokenize\", env);\n            return tokens;\n        });\n    }\n    if (Component) Highlight.__proto__ = Component;\n    Highlight.prototype = Object.create(Component && Component.prototype);\n    Highlight.prototype.constructor = Highlight;\n    Highlight.prototype.render = function render() {\n        var ref = this.props;\n        var Prism = ref.Prism;\n        var language = ref.language;\n        var code = ref.code;\n        var children = ref.children;\n        var themeDict = this.getThemeDict(this.props);\n        var grammar = Prism.languages[language];\n        var mixedTokens = grammar !== undefined ? this.tokenize(Prism, code, grammar, language) : [\n            code\n        ];\n        var tokens = normalizeTokens(mixedTokens);\n        return children({\n            tokens: tokens,\n            className: \"prism-code language-\" + language,\n            style: themeDict !== undefined ? themeDict.root : {},\n            getLineProps: this.getLineProps,\n            getTokenProps: this.getTokenProps\n        });\n    };\n    return Highlight;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Highlight);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJpc20tcmVhY3QtcmVuZGVyZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXNDO0FBQ2U7QUFDWDtBQUNSO0FBRWxDLElBQUlLLGVBQWU7SUFDakIsYUFBYTtJQUNiSCxPQUFPRix1REFBS0E7SUFDWkcsT0FBT0EsMkRBQUtBO0FBQ2Q7QUFFQSxTQUFTRyxnQkFBZ0JDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxLQUFLO0lBQ3RDLElBQUlELE9BQU9ELEtBQUs7UUFDZEcsT0FBT0MsY0FBYyxDQUFDSixLQUFLQyxLQUFLO1lBQzlCQyxPQUFPQTtZQUNQRyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtRQUNaO0lBQ0YsT0FBTztRQUNMUCxHQUFHLENBQUNDLElBQUksR0FBR0M7SUFDYjtJQUVBLE9BQU9GO0FBQ1Q7QUFFQSxTQUFTUTtJQUNQQSxXQUFXTCxPQUFPTSxNQUFNLElBQUksU0FBVUMsTUFBTTtRQUMxQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUV6QixJQUFLLElBQUlWLE9BQU9hLE9BQVE7Z0JBQ3RCLElBQUlYLE9BQU9ZLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNILFFBQVFiLE1BQU07b0JBQ3JEUyxNQUFNLENBQUNULElBQUksR0FBR2EsTUFBTSxDQUFDYixJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFFQSxPQUFPUztJQUNUO0lBRUEsT0FBT0YsU0FBU1UsS0FBSyxDQUFDLElBQUksRUFBRU47QUFDOUI7QUFFQSxJQUFJTyxZQUFZLGNBQWMsaUZBQWlGO0FBRS9HLElBQUlDLHNCQUFzQixTQUFVQyxJQUFJO0lBQ3RDLElBQUlBLEtBQUtSLE1BQU0sS0FBSyxHQUFHO1FBQ3JCUSxLQUFLQyxJQUFJLENBQUM7WUFDUkMsT0FBTztnQkFBQzthQUFRO1lBQ2hCQyxTQUFTO1lBQ1RDLE9BQU87UUFDVDtJQUNGLE9BQU8sSUFBSUosS0FBS1IsTUFBTSxLQUFLLEtBQUtRLElBQUksQ0FBQyxFQUFFLENBQUNHLE9BQU8sS0FBSyxJQUFJO1FBQ3RESCxJQUFJLENBQUMsRUFBRSxDQUFDRyxPQUFPLEdBQUc7UUFDbEJILElBQUksQ0FBQyxFQUFFLENBQUNJLEtBQUssR0FBRztJQUNsQjtBQUNGO0FBRUEsSUFBSUMsY0FBYyxTQUFVSCxLQUFLLEVBQUVJLEdBQUc7SUFDcEMsSUFBSUMsWUFBWUwsTUFBTVYsTUFBTTtJQUU1QixJQUFJZSxZQUFZLEtBQUtMLEtBQUssQ0FBQ0ssWUFBWSxFQUFFLEtBQUtELEtBQUs7UUFDakQsT0FBT0o7SUFDVDtJQUVBLE9BQU9BLE1BQU1NLE1BQU0sQ0FBQ0Y7QUFDdEIsR0FBRywwRUFBMEU7QUFDN0UsMEVBQTBFO0FBQzFFLDZFQUE2RTtBQUM3RSw4QkFBOEI7QUFDOUIsb0ZBQW9GO0FBQ3BGLHVDQUF1QztBQUd2QyxJQUFJRyxrQkFBa0IsU0FBVUMsTUFBTTtJQUNwQyxJQUFJQyxlQUFlO1FBQUMsRUFBRTtLQUFDO0lBQ3ZCLElBQUlDLGdCQUFnQjtRQUFDRjtLQUFPO0lBQzVCLElBQUlHLHFCQUFxQjtRQUFDO0tBQUU7SUFDNUIsSUFBSUMsb0JBQW9CO1FBQUNKLE9BQU9sQixNQUFNO0tBQUM7SUFDdkMsSUFBSUYsSUFBSTtJQUNSLElBQUl5QixhQUFhO0lBQ2pCLElBQUlDLGNBQWMsRUFBRTtJQUNwQixJQUFJQyxNQUFNO1FBQUNEO0tBQVk7SUFFdkIsTUFBT0QsYUFBYSxDQUFDLEVBQUc7UUFDdEIsTUFBTyxDQUFDekIsSUFBSXVCLGtCQUFrQixDQUFDRSxXQUFXLEVBQUMsSUFBS0QsaUJBQWlCLENBQUNDLFdBQVcsQ0FBRTtZQUM3RSxJQUFJWixVQUFVLEtBQUs7WUFDbkIsSUFBSUQsUUFBUVMsWUFBWSxDQUFDSSxXQUFXO1lBQ3BDLElBQUlHLFdBQVdOLGFBQWEsQ0FBQ0csV0FBVztZQUN4QyxJQUFJSSxRQUFRRCxRQUFRLENBQUM1QixFQUFFLEVBQUUsMERBQTBEO1lBRW5GLElBQUksT0FBTzZCLFVBQVUsVUFBVTtnQkFDN0JqQixRQUFRYSxhQUFhLElBQUliLFFBQVE7b0JBQUM7aUJBQVE7Z0JBQzFDQyxVQUFVZ0I7WUFDWixPQUFPO2dCQUNMakIsUUFBUUcsWUFBWUgsT0FBT2lCLE1BQU1DLElBQUk7Z0JBRXJDLElBQUlELE1BQU1FLEtBQUssRUFBRTtvQkFDZm5CLFFBQVFHLFlBQVlILE9BQU9pQixNQUFNRSxLQUFLO2dCQUN4QztnQkFFQWxCLFVBQVVnQixNQUFNaEIsT0FBTztZQUN6QixFQUFFLG9GQUFvRjtZQUd0RixJQUFJLE9BQU9BLFlBQVksVUFBVTtnQkFDL0JZO2dCQUNBSixhQUFhVixJQUFJLENBQUNDO2dCQUNsQlUsY0FBY1gsSUFBSSxDQUFDRTtnQkFDbkJVLG1CQUFtQlosSUFBSSxDQUFDO2dCQUN4QmEsa0JBQWtCYixJQUFJLENBQUNFLFFBQVFYLE1BQU07Z0JBQ3JDO1lBQ0YsRUFBRSxvQkFBb0I7WUFHdEIsSUFBSThCLGtCQUFrQm5CLFFBQVFvQixLQUFLLENBQUN6QjtZQUNwQyxJQUFJMEIsZUFBZUYsZ0JBQWdCOUIsTUFBTTtZQUN6Q3dCLFlBQVlmLElBQUksQ0FBQztnQkFDZkMsT0FBT0E7Z0JBQ1BDLFNBQVNtQixlQUFlLENBQUMsRUFBRTtZQUM3QixJQUFJLGtEQUFrRDtZQUV0RCxJQUFLLElBQUlHLE1BQU0sR0FBR0EsTUFBTUQsY0FBY0MsTUFBTztnQkFDM0MxQixvQkFBb0JpQjtnQkFDcEJDLElBQUloQixJQUFJLENBQUNlLGNBQWMsRUFBRTtnQkFDekJBLFlBQVlmLElBQUksQ0FBQztvQkFDZkMsT0FBT0E7b0JBQ1BDLFNBQVNtQixlQUFlLENBQUNHLElBQUk7Z0JBQy9CO1lBQ0Y7UUFDRixFQUFFLDJCQUEyQjtRQUc3QlY7UUFDQUosYUFBYWUsR0FBRztRQUNoQmQsY0FBY2MsR0FBRztRQUNqQmIsbUJBQW1CYSxHQUFHO1FBQ3RCWixrQkFBa0JZLEdBQUc7SUFDdkI7SUFFQTNCLG9CQUFvQmlCO0lBQ3BCLE9BQU9DO0FBQ1Q7QUFFQSxJQUFJVSxjQUFjLFNBQVVwRCxLQUFLLEVBQUVxRCxRQUFRO0lBQ3pDLElBQUlDLFFBQVF0RCxNQUFNc0QsS0FBSyxFQUFFLGFBQWE7SUFFdEMsSUFBSUMsT0FBT2hELE9BQU9pRCxNQUFNLENBQUM7SUFDekIsSUFBSUMsWUFBWXpELE1BQU0wRCxNQUFNLENBQUNDLE1BQU0sQ0FBQyxTQUFVakIsR0FBRyxFQUFFa0IsVUFBVTtRQUMzRCxJQUFJQyxZQUFZRCxXQUFXQyxTQUFTO1FBQ3BDLElBQUlDLFFBQVFGLFdBQVdFLEtBQUs7UUFFNUIsSUFBSUQsYUFBYSxDQUFDQSxVQUFVRSxRQUFRLENBQUNWLFdBQVc7WUFDOUMsT0FBT1g7UUFDVDtRQUVBa0IsV0FBV2pDLEtBQUssQ0FBQ3FDLE9BQU8sQ0FBQyxTQUFVbkIsSUFBSTtZQUNyQyxhQUFhO1lBQ2IsSUFBSW9CLFdBQVdyRCxTQUFTLENBQUMsR0FBRzhCLEdBQUcsQ0FBQ0csS0FBSyxFQUFFaUI7WUFFdkNwQixHQUFHLENBQUNHLEtBQUssR0FBR29CO1FBQ2Q7UUFDQSxPQUFPdkI7SUFDVCxHQUFHYSxPQUFPLGFBQWE7SUFFdkJFLFVBQVVTLElBQUksR0FBR1osT0FBTyxhQUFhO0lBRXJDRyxVQUFVSCxLQUFLLEdBQUcxQyxTQUFTLENBQUMsR0FBRzBDLE9BQU87UUFDcENhLGlCQUFpQjtJQUNuQjtJQUNBLE9BQU9WO0FBQ1Q7QUFFQSxTQUFTVyx3QkFBd0JoRSxHQUFHLEVBQUVpRSxPQUFPO0lBQzNDLElBQUl2RCxTQUFTLENBQUM7SUFFZCxJQUFLLElBQUl3RCxLQUFLbEUsSUFBSyxJQUFJRyxPQUFPWSxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDakIsS0FBS2tFLE1BQU1ELFFBQVFFLE9BQU8sQ0FBQ0QsT0FBTyxDQUFDLEdBQUd4RCxNQUFNLENBQUN3RCxFQUFFLEdBQUdsRSxHQUFHLENBQUNrRSxFQUFFO0lBRXBILE9BQU94RDtBQUNUO0FBRUEsSUFBSTBELFlBQVksV0FBVyxHQUFFLFNBQVV2RSxTQUFTO0lBQzlDLFNBQVN1RTtRQUNQLElBQUlDLFNBQVMsSUFBSTtRQUNqQixJQUFJQyxPQUFPLEVBQUUsRUFDVEMsTUFBTTNELFVBQVVDLE1BQU07UUFFMUIsTUFBTzBELE1BQU9ELElBQUksQ0FBQ0MsSUFBSSxHQUFHM0QsU0FBUyxDQUFDMkQsSUFBSTtRQUV4QzFFLFVBQVVxQixLQUFLLENBQUMsSUFBSSxFQUFFb0Q7UUFFdEJ2RSxnQkFBZ0IsSUFBSSxFQUFFLGdCQUFnQixTQUFVeUUsS0FBSztZQUNuRCxJQUFJSCxPQUFPaEIsU0FBUyxLQUFLb0IsYUFBYUQsTUFBTTVFLEtBQUssS0FBS3lFLE9BQU9LLFNBQVMsSUFBSUYsTUFBTXZCLFFBQVEsS0FBS29CLE9BQU9NLFlBQVksRUFBRTtnQkFDaEgsT0FBT04sT0FBT2hCLFNBQVM7WUFDekI7WUFFQWdCLE9BQU9LLFNBQVMsR0FBR0YsTUFBTTVFLEtBQUs7WUFDOUJ5RSxPQUFPTSxZQUFZLEdBQUdILE1BQU12QixRQUFRO1lBQ3BDLElBQUlJLFlBQVltQixNQUFNNUUsS0FBSyxHQUFHb0QsWUFBWXdCLE1BQU01RSxLQUFLLEVBQUU0RSxNQUFNdkIsUUFBUSxJQUFJd0I7WUFDekUsT0FBT0osT0FBT2hCLFNBQVMsR0FBR0E7UUFDNUI7UUFFQXRELGdCQUFnQixJQUFJLEVBQUUsZ0JBQWdCLFNBQVU2RSxHQUFHO1lBQ2pELElBQUkzRSxNQUFNMkUsSUFBSTNFLEdBQUc7WUFDakIsSUFBSTRFLFlBQVlELElBQUlDLFNBQVM7WUFDN0IsSUFBSW5CLFFBQVFrQixJQUFJbEIsS0FBSztZQUNyQixJQUFJb0IsU0FBU2Qsd0JBQXdCWSxLQUFLO2dCQUFDO2dCQUFPO2dCQUFhO2dCQUFTO2FBQU87WUFDL0UsSUFBSUcsT0FBT0Q7WUFFWCxJQUFJRSxTQUFTeEUsU0FBUyxDQUFDLEdBQUd1RSxNQUFNO2dCQUM5QkYsV0FBVztnQkFDWG5CLE9BQU9lO2dCQUNQeEUsS0FBS3dFO1lBQ1A7WUFFQSxJQUFJcEIsWUFBWWdCLE9BQU9ZLFlBQVksQ0FBQ1osT0FBT0csS0FBSztZQUVoRCxJQUFJbkIsY0FBY29CLFdBQVc7Z0JBQzNCTyxPQUFPdEIsS0FBSyxHQUFHTCxVQUFVSCxLQUFLO1lBQ2hDO1lBRUEsSUFBSVEsVUFBVWUsV0FBVztnQkFDdkJPLE9BQU90QixLQUFLLEdBQUdzQixPQUFPdEIsS0FBSyxLQUFLZSxZQUFZakUsU0FBUyxDQUFDLEdBQUd3RSxPQUFPdEIsS0FBSyxFQUFFQSxTQUFTQTtZQUNsRjtZQUVBLElBQUl6RCxRQUFRd0UsV0FBVztnQkFDckJPLE9BQU8vRSxHQUFHLEdBQUdBO1lBQ2Y7WUFFQSxJQUFJNEUsV0FBVztnQkFDYkcsT0FBT0gsU0FBUyxJQUFJLE1BQU1BO1lBQzVCO1lBRUEsT0FBT0c7UUFDVDtRQUVBakYsZ0JBQWdCLElBQUksRUFBRSxvQkFBb0IsU0FBVTZFLEdBQUc7WUFDckQsSUFBSXJELFFBQVFxRCxJQUFJckQsS0FBSztZQUNyQixJQUFJRSxRQUFRbUQsSUFBSW5ELEtBQUs7WUFDckIsSUFBSUcsWUFBWUwsTUFBTVYsTUFBTTtZQUM1QixJQUFJd0MsWUFBWWdCLE9BQU9ZLFlBQVksQ0FBQ1osT0FBT0csS0FBSztZQUVoRCxJQUFJbkIsY0FBY29CLFdBQVc7Z0JBQzNCLE9BQU9BO1lBQ1QsT0FBTyxJQUFJN0MsY0FBYyxLQUFLTCxLQUFLLENBQUMsRUFBRSxLQUFLLFNBQVM7Z0JBQ2xELE9BQU9FLFFBQVE7b0JBQ2J5RCxTQUFTO2dCQUNYLElBQUlUO1lBQ04sT0FBTyxJQUFJN0MsY0FBYyxLQUFLLENBQUNILE9BQU87Z0JBQ3BDLE9BQU80QixTQUFTLENBQUM5QixLQUFLLENBQUMsRUFBRSxDQUFDO1lBQzVCO1lBRUEsSUFBSTRELFlBQVkxRCxRQUFRO2dCQUN0QnlELFNBQVM7WUFDWCxJQUFJLENBQUMsR0FBRyxhQUFhO1lBRXJCLElBQUlFLGFBQWE3RCxNQUFNOEQsR0FBRyxDQUFDLFNBQVU1QyxJQUFJO2dCQUN2QyxPQUFPWSxTQUFTLENBQUNaLEtBQUs7WUFDeEI7WUFDQSxPQUFPdEMsT0FBT00sTUFBTSxDQUFDUyxLQUFLLENBQUNmLFFBQVE7Z0JBQUNnRjthQUFVLENBQUN0RCxNQUFNLENBQUN1RDtRQUN4RDtRQUVBckYsZ0JBQWdCLElBQUksRUFBRSxpQkFBaUIsU0FBVTZFLEdBQUc7WUFDbEQsSUFBSTNFLE1BQU0yRSxJQUFJM0UsR0FBRztZQUNqQixJQUFJNEUsWUFBWUQsSUFBSUMsU0FBUztZQUM3QixJQUFJbkIsUUFBUWtCLElBQUlsQixLQUFLO1lBQ3JCLElBQUlsQixRQUFRb0MsSUFBSXBDLEtBQUs7WUFDckIsSUFBSXNDLFNBQVNkLHdCQUF3QlksS0FBSztnQkFBQztnQkFBTztnQkFBYTtnQkFBUzthQUFRO1lBQ2hGLElBQUlHLE9BQU9EO1lBRVgsSUFBSUUsU0FBU3hFLFNBQVMsQ0FBQyxHQUFHdUUsTUFBTTtnQkFDOUJGLFdBQVcsV0FBV3JDLE1BQU1qQixLQUFLLENBQUMrRCxJQUFJLENBQUM7Z0JBQ3ZDQyxVQUFVL0MsTUFBTWhCLE9BQU87Z0JBQ3ZCa0MsT0FBT1csT0FBT21CLGdCQUFnQixDQUFDaEQ7Z0JBQy9CdkMsS0FBS3dFO1lBQ1A7WUFFQSxJQUFJZixVQUFVZSxXQUFXO2dCQUN2Qk8sT0FBT3RCLEtBQUssR0FBR3NCLE9BQU90QixLQUFLLEtBQUtlLFlBQVlqRSxTQUFTLENBQUMsR0FBR3dFLE9BQU90QixLQUFLLEVBQUVBLFNBQVNBO1lBQ2xGO1lBRUEsSUFBSXpELFFBQVF3RSxXQUFXO2dCQUNyQk8sT0FBTy9FLEdBQUcsR0FBR0E7WUFDZjtZQUVBLElBQUk0RSxXQUFXO2dCQUNiRyxPQUFPSCxTQUFTLElBQUksTUFBTUE7WUFDNUI7WUFFQSxPQUFPRztRQUNUO1FBRUFqRixnQkFBZ0IsSUFBSSxFQUFFLFlBQVksU0FBVUosS0FBSyxFQUFFOEYsSUFBSSxFQUFFQyxPQUFPLEVBQUV6QyxRQUFRO1lBQ3hFLElBQUkwQyxNQUFNO2dCQUNSRixNQUFNQTtnQkFDTkMsU0FBU0E7Z0JBQ1R6QyxVQUFVQTtnQkFDVmxCLFFBQVEsRUFBRTtZQUNaO1lBQ0FwQyxNQUFNaUcsS0FBSyxDQUFDQyxHQUFHLENBQUMsbUJBQW1CRjtZQUNuQyxJQUFJNUQsU0FBUzRELElBQUk1RCxNQUFNLEdBQUdwQyxNQUFNbUcsUUFBUSxDQUFDSCxJQUFJRixJQUFJLEVBQUVFLElBQUlELE9BQU8sRUFBRUMsSUFBSTFDLFFBQVE7WUFDNUV0RCxNQUFNaUcsS0FBSyxDQUFDQyxHQUFHLENBQUMsa0JBQWtCRjtZQUNsQyxPQUFPNUQ7UUFDVDtJQUNGO0lBRUEsSUFBSWxDLFdBQVd1RSxVQUFVMkIsU0FBUyxHQUFHbEc7SUFDckN1RSxVQUFVckQsU0FBUyxHQUFHWixPQUFPaUQsTUFBTSxDQUFDdkQsYUFBYUEsVUFBVWtCLFNBQVM7SUFDcEVxRCxVQUFVckQsU0FBUyxDQUFDaUYsV0FBVyxHQUFHNUI7SUFFbENBLFVBQVVyRCxTQUFTLENBQUNrRixNQUFNLEdBQUcsU0FBU0E7UUFDcEMsSUFBSXJCLE1BQU0sSUFBSSxDQUFDSixLQUFLO1FBQ3BCLElBQUk3RSxRQUFRaUYsSUFBSWpGLEtBQUs7UUFDckIsSUFBSXNELFdBQVcyQixJQUFJM0IsUUFBUTtRQUMzQixJQUFJd0MsT0FBT2IsSUFBSWEsSUFBSTtRQUNuQixJQUFJRixXQUFXWCxJQUFJVyxRQUFRO1FBQzNCLElBQUlsQyxZQUFZLElBQUksQ0FBQzRCLFlBQVksQ0FBQyxJQUFJLENBQUNULEtBQUs7UUFDNUMsSUFBSWtCLFVBQVUvRixNQUFNOEQsU0FBUyxDQUFDUixTQUFTO1FBQ3ZDLElBQUlpRCxjQUFjUixZQUFZakIsWUFBWSxJQUFJLENBQUNxQixRQUFRLENBQUNuRyxPQUFPOEYsTUFBTUMsU0FBU3pDLFlBQVk7WUFBQ3dDO1NBQUs7UUFDaEcsSUFBSTFELFNBQVNELGdCQUFnQm9FO1FBQzdCLE9BQU9YLFNBQVM7WUFDZHhELFFBQVFBO1lBQ1I4QyxXQUFXLHlCQUF5QjVCO1lBQ3BDUyxPQUFPTCxjQUFjb0IsWUFBWXBCLFVBQVVTLElBQUksR0FBRyxDQUFDO1lBQ25EcUMsY0FBYyxJQUFJLENBQUNBLFlBQVk7WUFDL0JDLGVBQWUsSUFBSSxDQUFDQSxhQUFhO1FBQ25DO0lBQ0Y7SUFFQSxPQUFPaEM7QUFDVCxFQUFFdkUsNENBQVNBO0FBRVgsaUVBQWV1RSxTQUFTQSxFQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC1jbGllbnQvLi9ub2RlX21vZHVsZXMvcHJpc20tcmVhY3QtcmVuZGVyZXIvZGlzdC9pbmRleC5qcz8zYWQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwcmlzbSBmcm9tICcuLi9wcmlzbS9pbmRleC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFByaXNtIH0gZnJvbSAnLi4vcHJpc20vaW5kZXguanMnO1xuaW1wb3J0IHRoZW1lIGZyb20gJy4uL3RoZW1lcy9kdW90b25lRGFyayc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIC8vICRGbG93Rml4TWVcbiAgUHJpc206IHByaXNtLFxuICB0aGVtZTogdGhlbWVcbn07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgbmV3bGluZVJlID0gL1xcclxcbnxcXHJ8XFxuLzsgLy8gRW1wdHkgbGluZXMgbmVlZCB0byBjb250YWluIGEgc2luZ2xlIGVtcHR5IHRva2VuLCBkZW5vdGVkIHdpdGggeyBlbXB0eTogdHJ1ZSB9XG5cbnZhciBub3JtYWxpemVFbXB0eUxpbmVzID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgbGluZS5wdXNoKHtcbiAgICAgIHR5cGVzOiBbXCJwbGFpblwiXSxcbiAgICAgIGNvbnRlbnQ6IFwiXFxuXCIsXG4gICAgICBlbXB0eTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGxpbmUubGVuZ3RoID09PSAxICYmIGxpbmVbMF0uY29udGVudCA9PT0gXCJcIikge1xuICAgIGxpbmVbMF0uY29udGVudCA9IFwiXFxuXCI7XG4gICAgbGluZVswXS5lbXB0eSA9IHRydWU7XG4gIH1cbn07XG5cbnZhciBhcHBlbmRUeXBlcyA9IGZ1bmN0aW9uICh0eXBlcywgYWRkKSB7XG4gIHZhciB0eXBlc1NpemUgPSB0eXBlcy5sZW5ndGg7XG5cbiAgaWYgKHR5cGVzU2l6ZSA+IDAgJiYgdHlwZXNbdHlwZXNTaXplIC0gMV0gPT09IGFkZCkge1xuICAgIHJldHVybiB0eXBlcztcbiAgfVxuXG4gIHJldHVybiB0eXBlcy5jb25jYXQoYWRkKTtcbn07IC8vIFRha2VzIGFuIGFycmF5IG9mIFByaXNtJ3MgdG9rZW5zIGFuZCBncm91cHMgdGhlbSBieSBsaW5lLCB0dXJuaW5nIHBsYWluXG4vLyBzdHJpbmdzIGludG8gdG9rZW5zIGFzIHdlbGwuIFRva2VucyBjYW4gYmVjb21lIHJlY3Vyc2l2ZSBpbiBzb21lIGNhc2VzLFxuLy8gd2hpY2ggbWVhbnMgdGhhdCB0aGVpciB0eXBlcyBhcmUgY29uY2F0ZW5hdGVkLiBQbGFpbi1zdHJpbmcgdG9rZW5zIGhvd2V2ZXJcbi8vIGFyZSBhbHdheXMgb2YgdHlwZSBcInBsYWluXCIuXG4vLyBUaGlzIGlzIG5vdCByZWN1cnNpdmUgdG8gYXZvaWQgZXhjZWVkaW5nIHRoZSBjYWxsLXN0YWNrIGxpbWl0LCBzaW5jZSBpdCdzIHVuY2xlYXJcbi8vIGhvdyBuZXN0ZWQgUHJpc20ncyB0b2tlbnMgY2FuIGJlY29tZVxuXG5cbnZhciBub3JtYWxpemVUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gIHZhciB0eXBlQXJyU3RhY2sgPSBbW11dO1xuICB2YXIgdG9rZW5BcnJTdGFjayA9IFt0b2tlbnNdO1xuICB2YXIgdG9rZW5BcnJJbmRleFN0YWNrID0gWzBdO1xuICB2YXIgdG9rZW5BcnJTaXplU3RhY2sgPSBbdG9rZW5zLmxlbmd0aF07XG4gIHZhciBpID0gMDtcbiAgdmFyIHN0YWNrSW5kZXggPSAwO1xuICB2YXIgY3VycmVudExpbmUgPSBbXTtcbiAgdmFyIGFjYyA9IFtjdXJyZW50TGluZV07XG5cbiAgd2hpbGUgKHN0YWNrSW5kZXggPiAtMSkge1xuICAgIHdoaWxlICgoaSA9IHRva2VuQXJySW5kZXhTdGFja1tzdGFja0luZGV4XSsrKSA8IHRva2VuQXJyU2l6ZVN0YWNrW3N0YWNrSW5kZXhdKSB7XG4gICAgICB2YXIgY29udGVudCA9IHZvaWQgMDtcbiAgICAgIHZhciB0eXBlcyA9IHR5cGVBcnJTdGFja1tzdGFja0luZGV4XTtcbiAgICAgIHZhciB0b2tlbkFyciA9IHRva2VuQXJyU3RhY2tbc3RhY2tJbmRleF07XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbkFycltpXTsgLy8gRGV0ZXJtaW5lIGNvbnRlbnQgYW5kIGFwcGVuZCB0eXBlIHRvIHR5cGVzIGlmIG5lY2Vzc2FyeVxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHR5cGVzID0gc3RhY2tJbmRleCA+IDAgPyB0eXBlcyA6IFtcInBsYWluXCJdO1xuICAgICAgICBjb250ZW50ID0gdG9rZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlcyA9IGFwcGVuZFR5cGVzKHR5cGVzLCB0b2tlbi50eXBlKTtcblxuICAgICAgICBpZiAodG9rZW4uYWxpYXMpIHtcbiAgICAgICAgICB0eXBlcyA9IGFwcGVuZFR5cGVzKHR5cGVzLCB0b2tlbi5hbGlhcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZW50ID0gdG9rZW4uY29udGVudDtcbiAgICAgIH0gLy8gSWYgdG9rZW4uY29udGVudCBpcyBhbiBhcnJheSwgaW5jcmVhc2UgdGhlIHN0YWNrIGRlcHRoIGFuZCByZXBlYXQgdGhpcyB3aGlsZS1sb29wXG5cblxuICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN0YWNrSW5kZXgrKztcbiAgICAgICAgdHlwZUFyclN0YWNrLnB1c2godHlwZXMpO1xuICAgICAgICB0b2tlbkFyclN0YWNrLnB1c2goY29udGVudCk7XG4gICAgICAgIHRva2VuQXJySW5kZXhTdGFjay5wdXNoKDApO1xuICAgICAgICB0b2tlbkFyclNpemVTdGFjay5wdXNoKGNvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIFNwbGl0IGJ5IG5ld2xpbmVzXG5cblxuICAgICAgdmFyIHNwbGl0QnlOZXdsaW5lcyA9IGNvbnRlbnQuc3BsaXQobmV3bGluZVJlKTtcbiAgICAgIHZhciBuZXdsaW5lQ291bnQgPSBzcGxpdEJ5TmV3bGluZXMubGVuZ3RoO1xuICAgICAgY3VycmVudExpbmUucHVzaCh7XG4gICAgICAgIHR5cGVzOiB0eXBlcyxcbiAgICAgICAgY29udGVudDogc3BsaXRCeU5ld2xpbmVzWzBdXG4gICAgICB9KTsgLy8gQ3JlYXRlIGEgbmV3IGxpbmUgZm9yIGVhY2ggc3RyaW5nIG9uIGEgbmV3IGxpbmVcblxuICAgICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgbmV3bGluZUNvdW50OyBpJDErKykge1xuICAgICAgICBub3JtYWxpemVFbXB0eUxpbmVzKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgYWNjLnB1c2goY3VycmVudExpbmUgPSBbXSk7XG4gICAgICAgIGN1cnJlbnRMaW5lLnB1c2goe1xuICAgICAgICAgIHR5cGVzOiB0eXBlcyxcbiAgICAgICAgICBjb250ZW50OiBzcGxpdEJ5TmV3bGluZXNbaSQxXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vIERlY3JlYXRlIHRoZSBzdGFjayBkZXB0aFxuXG5cbiAgICBzdGFja0luZGV4LS07XG4gICAgdHlwZUFyclN0YWNrLnBvcCgpO1xuICAgIHRva2VuQXJyU3RhY2sucG9wKCk7XG4gICAgdG9rZW5BcnJJbmRleFN0YWNrLnBvcCgpO1xuICAgIHRva2VuQXJyU2l6ZVN0YWNrLnBvcCgpO1xuICB9XG5cbiAgbm9ybWFsaXplRW1wdHlMaW5lcyhjdXJyZW50TGluZSk7XG4gIHJldHVybiBhY2M7XG59O1xuXG52YXIgdGhlbWVUb0RpY3QgPSBmdW5jdGlvbiAodGhlbWUsIGxhbmd1YWdlKSB7XG4gIHZhciBwbGFpbiA9IHRoZW1lLnBsYWluOyAvLyAkRmxvd0ZpeE1lXG5cbiAgdmFyIGJhc2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgdGhlbWVEaWN0ID0gdGhlbWUuc3R5bGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0aGVtZUVudHJ5KSB7XG4gICAgdmFyIGxhbmd1YWdlcyA9IHRoZW1lRW50cnkubGFuZ3VhZ2VzO1xuICAgIHZhciBzdHlsZSA9IHRoZW1lRW50cnkuc3R5bGU7XG5cbiAgICBpZiAobGFuZ3VhZ2VzICYmICFsYW5ndWFnZXMuaW5jbHVkZXMobGFuZ3VhZ2UpKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIHRoZW1lRW50cnkudHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgdmFyIGFjY1N0eWxlID0gX2V4dGVuZHMoe30sIGFjY1t0eXBlXSwgc3R5bGUpO1xuXG4gICAgICBhY2NbdHlwZV0gPSBhY2NTdHlsZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBiYXNlKTsgLy8gJEZsb3dGaXhNZVxuXG4gIHRoZW1lRGljdC5yb290ID0gcGxhaW47IC8vICRGbG93Rml4TWVcblxuICB0aGVtZURpY3QucGxhaW4gPSBfZXh0ZW5kcyh7fSwgcGxhaW4sIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG51bGxcbiAgfSk7XG4gIHJldHVybiB0aGVtZURpY3Q7XG59O1xuXG5mdW5jdGlvbiBvYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykgJiYgZXhjbHVkZS5pbmRleE9mKGspID09PSAtMSkgdGFyZ2V0W2tdID0gb2JqW2tdO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBIaWdobGlnaHQgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICBmdW5jdGlvbiBIaWdobGlnaHQoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG5cbiAgICBDb21wb25lbnQuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRUaGVtZURpY3RcIiwgZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICBpZiAodGhpcyQxLnRoZW1lRGljdCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLnRoZW1lID09PSB0aGlzJDEucHJldlRoZW1lICYmIHByb3BzLmxhbmd1YWdlID09PSB0aGlzJDEucHJldkxhbmd1YWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzJDEudGhlbWVEaWN0O1xuICAgICAgfVxuXG4gICAgICB0aGlzJDEucHJldlRoZW1lID0gcHJvcHMudGhlbWU7XG4gICAgICB0aGlzJDEucHJldkxhbmd1YWdlID0gcHJvcHMubGFuZ3VhZ2U7XG4gICAgICB2YXIgdGhlbWVEaWN0ID0gcHJvcHMudGhlbWUgPyB0aGVtZVRvRGljdChwcm9wcy50aGVtZSwgcHJvcHMubGFuZ3VhZ2UpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMkMS50aGVtZURpY3QgPSB0aGVtZURpY3Q7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRMaW5lUHJvcHNcIiwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gcmVmLmNsYXNzTmFtZTtcbiAgICAgIHZhciBzdHlsZSA9IHJlZi5zdHlsZTtcbiAgICAgIHZhciByZXN0JDEgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhyZWYsIFtcImtleVwiLCBcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwibGluZVwiXSk7XG4gICAgICB2YXIgcmVzdCA9IHJlc3QkMTtcblxuICAgICAgdmFyIG91dHB1dCA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJ0b2tlbi1saW5lXCIsXG4gICAgICAgIHN0eWxlOiB1bmRlZmluZWQsXG4gICAgICAgIGtleTogdW5kZWZpbmVkXG4gICAgICB9KTtcblxuICAgICAgdmFyIHRoZW1lRGljdCA9IHRoaXMkMS5nZXRUaGVtZURpY3QodGhpcyQxLnByb3BzKTtcblxuICAgICAgaWYgKHRoZW1lRGljdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5zdHlsZSA9IHRoZW1lRGljdC5wbGFpbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0LnN0eWxlID0gb3V0cHV0LnN0eWxlICE9PSB1bmRlZmluZWQgPyBfZXh0ZW5kcyh7fSwgb3V0cHV0LnN0eWxlLCBzdHlsZSkgOiBzdHlsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5rZXkgPSBrZXk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgb3V0cHV0LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFN0eWxlRm9yVG9rZW5cIiwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIHR5cGVzID0gcmVmLnR5cGVzO1xuICAgICAgdmFyIGVtcHR5ID0gcmVmLmVtcHR5O1xuICAgICAgdmFyIHR5cGVzU2l6ZSA9IHR5cGVzLmxlbmd0aDtcbiAgICAgIHZhciB0aGVtZURpY3QgPSB0aGlzJDEuZ2V0VGhlbWVEaWN0KHRoaXMkMS5wcm9wcyk7XG5cbiAgICAgIGlmICh0aGVtZURpY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmICh0eXBlc1NpemUgPT09IDEgJiYgdHlwZXNbMF0gPT09IFwicGxhaW5cIikge1xuICAgICAgICByZXR1cm4gZW1wdHkgPyB7XG4gICAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIlxuICAgICAgICB9IDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmICh0eXBlc1NpemUgPT09IDEgJiYgIWVtcHR5KSB7XG4gICAgICAgIHJldHVybiB0aGVtZURpY3RbdHlwZXNbMF1dO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFzZVN0eWxlID0gZW1wdHkgPyB7XG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCJcbiAgICAgIH0gOiB7fTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICB2YXIgdHlwZVN0eWxlcyA9IHR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhlbWVEaWN0W3R5cGVdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIFtiYXNlU3R5bGVdLmNvbmNhdCh0eXBlU3R5bGVzKSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRUb2tlblByb3BzXCIsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHJlZi5jbGFzc05hbWU7XG4gICAgICB2YXIgc3R5bGUgPSByZWYuc3R5bGU7XG4gICAgICB2YXIgdG9rZW4gPSByZWYudG9rZW47XG4gICAgICB2YXIgcmVzdCQxID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmVmLCBbXCJrZXlcIiwgXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcInRva2VuXCJdKTtcbiAgICAgIHZhciByZXN0ID0gcmVzdCQxO1xuXG4gICAgICB2YXIgb3V0cHV0ID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInRva2VuIFwiICsgdG9rZW4udHlwZXMuam9pbihcIiBcIiksXG4gICAgICAgIGNoaWxkcmVuOiB0b2tlbi5jb250ZW50LFxuICAgICAgICBzdHlsZTogdGhpcyQxLmdldFN0eWxlRm9yVG9rZW4odG9rZW4pLFxuICAgICAgICBrZXk6IHVuZGVmaW5lZFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5zdHlsZSA9IG91dHB1dC5zdHlsZSAhPT0gdW5kZWZpbmVkID8gX2V4dGVuZHMoe30sIG91dHB1dC5zdHlsZSwgc3R5bGUpIDogc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQua2V5ID0ga2V5O1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIG91dHB1dC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b2tlbml6ZVwiLCBmdW5jdGlvbiAoUHJpc20sIGNvZGUsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG4gICAgICB2YXIgZW52ID0ge1xuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICBncmFtbWFyOiBncmFtbWFyLFxuICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICAgIHRva2VuczogW11cbiAgICAgIH07XG4gICAgICBQcmlzbS5ob29rcy5ydW4oXCJiZWZvcmUtdG9rZW5pemVcIiwgZW52KTtcbiAgICAgIHZhciB0b2tlbnMgPSBlbnYudG9rZW5zID0gUHJpc20udG9rZW5pemUoZW52LmNvZGUsIGVudi5ncmFtbWFyLCBlbnYubGFuZ3VhZ2UpO1xuICAgICAgUHJpc20uaG9va3MucnVuKFwiYWZ0ZXItdG9rZW5pemVcIiwgZW52KTtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoQ29tcG9uZW50KSBIaWdobGlnaHQuX19wcm90b19fID0gQ29tcG9uZW50O1xuICBIaWdobGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQgJiYgQ29tcG9uZW50LnByb3RvdHlwZSk7XG4gIEhpZ2hsaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIaWdobGlnaHQ7XG5cbiAgSGlnaGxpZ2h0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIFByaXNtID0gcmVmLlByaXNtO1xuICAgIHZhciBsYW5ndWFnZSA9IHJlZi5sYW5ndWFnZTtcbiAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgdGhlbWVEaWN0ID0gdGhpcy5nZXRUaGVtZURpY3QodGhpcy5wcm9wcyk7XG4gICAgdmFyIGdyYW1tYXIgPSBQcmlzbS5sYW5ndWFnZXNbbGFuZ3VhZ2VdO1xuICAgIHZhciBtaXhlZFRva2VucyA9IGdyYW1tYXIgIT09IHVuZGVmaW5lZCA/IHRoaXMudG9rZW5pemUoUHJpc20sIGNvZGUsIGdyYW1tYXIsIGxhbmd1YWdlKSA6IFtjb2RlXTtcbiAgICB2YXIgdG9rZW5zID0gbm9ybWFsaXplVG9rZW5zKG1peGVkVG9rZW5zKTtcbiAgICByZXR1cm4gY2hpbGRyZW4oe1xuICAgICAgdG9rZW5zOiB0b2tlbnMsXG4gICAgICBjbGFzc05hbWU6IFwicHJpc20tY29kZSBsYW5ndWFnZS1cIiArIGxhbmd1YWdlLFxuICAgICAgc3R5bGU6IHRoZW1lRGljdCAhPT0gdW5kZWZpbmVkID8gdGhlbWVEaWN0LnJvb3QgOiB7fSxcbiAgICAgIGdldExpbmVQcm9wczogdGhpcy5nZXRMaW5lUHJvcHMsXG4gICAgICBnZXRUb2tlblByb3BzOiB0aGlzLmdldFRva2VuUHJvcHNcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gSGlnaGxpZ2h0O1xufShDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBIaWdobGlnaHQ7XG5leHBvcnQgeyBkZWZhdWx0UHJvcHMgfTtcbiJdLCJuYW1lcyI6WyJwcmlzbSIsImRlZmF1bHQiLCJQcmlzbSIsInRoZW1lIiwiQ29tcG9uZW50IiwiZGVmYXVsdFByb3BzIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwibmV3bGluZVJlIiwibm9ybWFsaXplRW1wdHlMaW5lcyIsImxpbmUiLCJwdXNoIiwidHlwZXMiLCJjb250ZW50IiwiZW1wdHkiLCJhcHBlbmRUeXBlcyIsImFkZCIsInR5cGVzU2l6ZSIsImNvbmNhdCIsIm5vcm1hbGl6ZVRva2VucyIsInRva2VucyIsInR5cGVBcnJTdGFjayIsInRva2VuQXJyU3RhY2siLCJ0b2tlbkFyckluZGV4U3RhY2siLCJ0b2tlbkFyclNpemVTdGFjayIsInN0YWNrSW5kZXgiLCJjdXJyZW50TGluZSIsImFjYyIsInRva2VuQXJyIiwidG9rZW4iLCJ0eXBlIiwiYWxpYXMiLCJzcGxpdEJ5TmV3bGluZXMiLCJzcGxpdCIsIm5ld2xpbmVDb3VudCIsImkkMSIsInBvcCIsInRoZW1lVG9EaWN0IiwibGFuZ3VhZ2UiLCJwbGFpbiIsImJhc2UiLCJjcmVhdGUiLCJ0aGVtZURpY3QiLCJzdHlsZXMiLCJyZWR1Y2UiLCJ0aGVtZUVudHJ5IiwibGFuZ3VhZ2VzIiwic3R5bGUiLCJpbmNsdWRlcyIsImZvckVhY2giLCJhY2NTdHlsZSIsInJvb3QiLCJiYWNrZ3JvdW5kQ29sb3IiLCJvYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGUiLCJrIiwiaW5kZXhPZiIsIkhpZ2hsaWdodCIsInRoaXMkMSIsImFyZ3MiLCJsZW4iLCJwcm9wcyIsInVuZGVmaW5lZCIsInByZXZUaGVtZSIsInByZXZMYW5ndWFnZSIsInJlZiIsImNsYXNzTmFtZSIsInJlc3QkMSIsInJlc3QiLCJvdXRwdXQiLCJnZXRUaGVtZURpY3QiLCJkaXNwbGF5IiwiYmFzZVN0eWxlIiwidHlwZVN0eWxlcyIsIm1hcCIsImpvaW4iLCJjaGlsZHJlbiIsImdldFN0eWxlRm9yVG9rZW4iLCJjb2RlIiwiZ3JhbW1hciIsImVudiIsImhvb2tzIiwicnVuIiwidG9rZW5pemUiLCJfX3Byb3RvX18iLCJjb25zdHJ1Y3RvciIsInJlbmRlciIsIm1peGVkVG9rZW5zIiwiZ2V0TGluZVByb3BzIiwiZ2V0VG9rZW5Qcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prism-react-renderer/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/prism-react-renderer/prism/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prism-react-renderer/prism/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */ /**\n * prism-react-renderer:\n * This file has been modified to remove:\n * - globals and window dependency\n * - worker support\n * - highlightAll and other element dependent methods\n * - _.hooks helpers\n * - UMD/node-specific hacks\n * It has also been run through prettier\n */ var Prism = function() {\n    // Private helper vars\n    var lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n    var uniqueId = 0;\n    // The grammar object for plaintext\n    var plainTextGrammar = {};\n    var _ = {\n        /**\n\t\t * A namespace for utility methods.\n\t\t *\n\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n\t\t * change or disappear at any time.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t */ util: {\n            encode: function encode(tokens) {\n                if (tokens instanceof Token) {\n                    return new Token(tokens.type, encode(tokens.content), tokens.alias);\n                } else if (Array.isArray(tokens)) {\n                    return tokens.map(encode);\n                } else {\n                    return tokens.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/\\u00a0/g, \" \");\n                }\n            },\n            /**\n\t\t\t * Returns the name of the type of the given value.\n\t\t\t *\n\t\t\t * @param {any} o\n\t\t\t * @returns {string}\n\t\t\t * @example\n\t\t\t * type(null)      === 'Null'\n\t\t\t * type(undefined) === 'Undefined'\n\t\t\t * type(123)       === 'Number'\n\t\t\t * type('foo')     === 'String'\n\t\t\t * type(true)      === 'Boolean'\n\t\t\t * type([1, 2])    === 'Array'\n\t\t\t * type({})        === 'Object'\n\t\t\t * type(String)    === 'Function'\n\t\t\t * type(/abc+/)    === 'RegExp'\n\t\t\t */ type: function(o) {\n                return Object.prototype.toString.call(o).slice(8, -1);\n            },\n            /**\n\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.\n\t\t\t *\n\t\t\t * @param {Object} obj\n\t\t\t * @returns {number}\n\t\t\t */ objId: function(obj) {\n                if (!obj[\"__id\"]) {\n                    Object.defineProperty(obj, \"__id\", {\n                        value: ++uniqueId\n                    });\n                }\n                return obj[\"__id\"];\n            },\n            /**\n\t\t\t * Creates a deep clone of the given object.\n\t\t\t *\n\t\t\t * The main intended use of this function is to clone language definitions.\n\t\t\t *\n\t\t\t * @param {T} o\n\t\t\t * @param {Record<number, any>} [visited]\n\t\t\t * @returns {T}\n\t\t\t * @template T\n\t\t\t */ clone: function deepClone(o, visited) {\n                visited = visited || {};\n                var clone;\n                var id;\n                switch(_.util.type(o)){\n                    case \"Object\":\n                        id = _.util.objId(o);\n                        if (visited[id]) {\n                            return visited[id];\n                        }\n                        clone = /** @type {Record<string, any>} */ {};\n                        visited[id] = clone;\n                        for(var key in o){\n                            if (o.hasOwnProperty(key)) {\n                                clone[key] = deepClone(o[key], visited);\n                            }\n                        }\n                        return /** @type {any} */ clone;\n                    case \"Array\":\n                        id = _.util.objId(o);\n                        if (visited[id]) {\n                            return visited[id];\n                        }\n                        clone = [];\n                        visited[id] = clone;\n                        /** @type {Array} */ /** @type {any} */ o.forEach(function(v, i) {\n                            clone[i] = deepClone(v, visited);\n                        });\n                        return /** @type {any} */ clone;\n                    default:\n                        return o;\n                }\n            },\n            /**\n\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n\t\t\t *\n\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @returns {string}\n\t\t\t */ getLanguage: function(element) {\n                while(element){\n                    var m = lang.exec(element.className);\n                    if (m) {\n                        return m[1].toLowerCase();\n                    }\n                    element = element.parentElement;\n                }\n                return \"none\";\n            },\n            /**\n\t\t\t * Sets the Prism `language-xxxx` class of the given element.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} language\n\t\t\t * @returns {void}\n\t\t\t */ setLanguage: function(element, language) {\n                // remove all `language-xxxx` classes\n                // (this might leave behind a leading space)\n                element.className = element.className.replace(RegExp(lang, \"gi\"), \"\");\n                // add the new `language-xxxx` class\n                // (using `classList` will automatically clean up spaces for us)\n                element.classList.add(\"language-\" + language);\n            },\n            /**\n\t\t\t * Returns whether a given class is active for `element`.\n\t\t\t *\n\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n\t\t\t * given class is just the given class with a `no-` prefix.\n\t\t\t *\n\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.\n\t\t\t *\n\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n\t\t\t * version of it, the class is considered active.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} className\n\t\t\t * @param {boolean} [defaultActivation=false]\n\t\t\t * @returns {boolean}\n\t\t\t */ isActive: function(element, className, defaultActivation) {\n                var no = \"no-\" + className;\n                while(element){\n                    var classList = element.classList;\n                    if (classList.contains(className)) {\n                        return true;\n                    }\n                    if (classList.contains(no)) {\n                        return false;\n                    }\n                    element = element.parentElement;\n                }\n                return !!defaultActivation;\n            }\n        },\n        /**\n\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */ languages: {\n            /**\n\t\t\t * The grammar for plain, unformatted text.\n\t\t\t */ plain: plainTextGrammar,\n            plaintext: plainTextGrammar,\n            text: plainTextGrammar,\n            txt: plainTextGrammar,\n            /**\n\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.\n\t\t\t *\n\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n\t\t\t * will be overwritten at its original position.\n\t\t\t *\n\t\t\t * ## Best practices\n\t\t\t *\n\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n\t\t\t *\n\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n\t\t\t *\n\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n\t\t\t * @param {Grammar} redef The new tokens to append.\n\t\t\t * @returns {Grammar} The new language created.\n\t\t\t * @public\n\t\t\t * @example\n\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n\t\t\t *     // at its original position\n\t\t\t *     'comment': { ... },\n\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended\n\t\t\t *     'color': /\\b(?:red|green|blue)\\b/\n\t\t\t * });\n\t\t\t */ extend: function(id, redef) {\n                var lang = _.util.clone(_.languages[id]);\n                for(var key in redef){\n                    lang[key] = redef[key];\n                }\n                return lang;\n            },\n            /**\n\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.\n\t\t\t *\n\t\t\t * ## Usage\n\t\t\t *\n\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n\t\t\t * this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.markup.style = {\n\t\t\t *     // token\n\t\t\t * };\n\t\t\t * ```\n\t\t\t *\n\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n\t\t\t * before existing tokens. For the CSS example above, you would use it like this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {\n\t\t\t *     'style': {\n\t\t\t *         // token\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Special cases\n\t\t\t *\n\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n\t\t\t * will be ignored.\n\t\t\t *\n\t\t\t * This behavior can be used to insert tokens after `before`:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'comment', {\n\t\t\t *     'comment': Prism.languages.markup.comment,\n\t\t\t *     // tokens after 'comment'\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Limitations\n\t\t\t *\n\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n\t\t\t * deleting properties which is necessary to insert at arbitrary positions.\n\t\t\t *\n\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This\n\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.\n\t\t\t *\n\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n\t\t\t * you hold the target object in a variable, then the value of the variable will not change.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var oldMarkup = Prism.languages.markup;\n\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n\t\t\t *\n\t\t\t * assert(oldMarkup !== Prism.languages.markup);\n\t\t\t * assert(newMarkup === Prism.languages.markup);\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n\t\t\t * object to be modified.\n\t\t\t * @param {string} before The key to insert before.\n\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n\t\t\t * object to be modified.\n\t\t\t *\n\t\t\t * Defaults to `Prism.languages`.\n\t\t\t * @returns {Grammar} The new grammar object.\n\t\t\t * @public\n\t\t\t */ insertBefore: function(inside, before, insert, root) {\n                root = root || /** @type {any} */ _.languages;\n                var grammar = root[inside];\n                /** @type {Grammar} */ var ret = {};\n                for(var token in grammar){\n                    if (grammar.hasOwnProperty(token)) {\n                        if (token == before) {\n                            for(var newToken in insert){\n                                if (insert.hasOwnProperty(newToken)) {\n                                    ret[newToken] = insert[newToken];\n                                }\n                            }\n                        }\n                        // Do not insert token which also occur in insert. See #1525\n                        if (!insert.hasOwnProperty(token)) {\n                            ret[token] = grammar[token];\n                        }\n                    }\n                }\n                var old = root[inside];\n                root[inside] = ret;\n                // Update references in other language definitions\n                _.languages.DFS(_.languages, function(key, value) {\n                    if (value === old && key != inside) {\n                        this[key] = ret;\n                    }\n                });\n                return ret;\n            },\n            // Traverse a language definition with Depth First Search\n            DFS: function DFS(o, callback, type, visited) {\n                visited = visited || {};\n                var objId = _.util.objId;\n                for(var i in o){\n                    if (o.hasOwnProperty(i)) {\n                        callback.call(o, i, o[i], type || i);\n                        var property = o[i];\n                        var propertyType = _.util.type(property);\n                        if (propertyType === \"Object\" && !visited[objId(property)]) {\n                            visited[objId(property)] = true;\n                            DFS(property, callback, null, visited);\n                        } else if (propertyType === \"Array\" && !visited[objId(property)]) {\n                            visited[objId(property)] = true;\n                            DFS(property, callback, i, visited);\n                        }\n                    }\n                }\n            }\n        },\n        plugins: {},\n        /**\n\t\t * Low-level function, only use if you know what youre doing. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns a string with the HTML produced.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-tokenize`\n\t\t * 2. `after-tokenize`\n\t\t * 3. `wrap`: On each {@link Token}.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @param {string} language The name of the language definition passed to `grammar`.\n\t\t * @returns {string} The highlighted HTML.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n\t\t */ highlight: function(text, grammar, language) {\n            var env = {\n                code: text,\n                grammar: grammar,\n                language: language\n            };\n            _.hooks.run(\"before-tokenize\", env);\n            env.tokens = _.tokenize(env.code, env.grammar);\n            _.hooks.run(\"after-tokenize\", env);\n            return Token.stringify(_.util.encode(env.tokens), env.language);\n        },\n        /**\n\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns an array with the tokenized code.\n\t\t *\n\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t\t *\n\t\t * This method could be useful in other contexts as well, as a very crude parser.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * let code = `var foo = 0;`;\n\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n\t\t * tokens.forEach(token => {\n\t\t *     if (token instanceof Prism.Token && token.type === 'number') {\n\t\t *         console.log(`Found numeric literal: ${token.content}`);\n\t\t *     }\n\t\t * });\n\t\t */ tokenize: function(text, grammar) {\n            var rest = grammar.rest;\n            if (rest) {\n                for(var token in rest){\n                    grammar[token] = rest[token];\n                }\n                delete grammar.rest;\n            }\n            var tokenList = new LinkedList();\n            addAfter(tokenList, tokenList.head, text);\n            matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n            return toArray(tokenList);\n        },\n        /**\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */ hooks: {\n            all: {},\n            /**\n\t\t\t * Adds the given callback to the list of callbacks for the given hook.\n\t\t\t *\n\t\t\t * The callback will be invoked when the hook it is registered for is run.\n\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t\t\t *\n\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.\n\t\t\t * @public\n\t\t\t */ add: function(name, callback) {\n                var hooks = _.hooks.all;\n                hooks[name] = hooks[name] || [];\n                hooks[name].push(callback);\n            },\n            /**\n\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t\t\t *\n\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t\t\t * @public\n\t\t\t */ run: function(name, env) {\n                var callbacks = _.hooks.all[name];\n                if (!callbacks || !callbacks.length) {\n                    return;\n                }\n                for(var i = 0, callback; callback = callbacks[i++];){\n                    callback(env);\n                }\n            }\n        },\n        Token: Token\n    };\n    // Typescript note:\n    // The following can be used to import the Token type in JSDoc:\n    //\n    //   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n    /**\n\t * Creates a new token.\n\t *\n\t * @param {string} type See {@link Token#type type}\n\t * @param {string | TokenStream} content See {@link Token#content content}\n\t * @param {string|string[]} [alias] The alias(es) of the token.\n\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n\t * @class\n\t * @global\n\t * @public\n\t */ function Token(type, content, alias, matchedStr) {\n        /**\n\t\t * The type of the token.\n\t\t *\n\t\t * This is usually the key of a pattern in a {@link Grammar}.\n\t\t *\n\t\t * @type {string}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */ this.type = type;\n        /**\n\t\t * The strings or tokens contained by this token.\n\t\t *\n\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t\t *\n\t\t * @type {string | TokenStream}\n\t\t * @public\n\t\t */ this.content = content;\n        /**\n\t\t * The alias(es) of the token.\n\t\t *\n\t\t * @type {string|string[]}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */ this.alias = alias;\n        // Copy of the full string this token was created from\n        this.length = (matchedStr || \"\").length | 0;\n    }\n    /**\n\t * A token stream is an array of strings and {@link Token Token} objects.\n\t *\n\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n\t * them.\n\t *\n\t * 1. No adjacent strings.\n\t * 2. No empty strings.\n\t *\n\t *    The only exception here is the token stream that only contains the empty string and nothing else.\n\t *\n\t * @typedef {Array<string | Token>} TokenStream\n\t * @global\n\t * @public\n\t */ /**\n\t * Converts the given token or token stream to an HTML representation.\n\t *\n\t * The following hooks will be run:\n\t * 1. `wrap`: On each {@link Token}.\n\t *\n\t * @param {string | Token | TokenStream} o The token or token stream to be converted.\n\t * @param {string} language The name of current language.\n\t * @returns {string} The HTML representation of the token or token stream.\n\t * @memberof Token\n\t * @static\n\t */ Token.stringify = function stringify(o, language) {\n        if (typeof o == \"string\") {\n            return o;\n        }\n        if (Array.isArray(o)) {\n            var s = \"\";\n            o.forEach(function(e) {\n                s += stringify(e, language);\n            });\n            return s;\n        }\n        var env = {\n            type: o.type,\n            content: stringify(o.content, language),\n            tag: \"span\",\n            classes: [\n                \"token\",\n                o.type\n            ],\n            attributes: {},\n            language: language\n        };\n        var aliases = o.alias;\n        if (aliases) {\n            if (Array.isArray(aliases)) {\n                Array.prototype.push.apply(env.classes, aliases);\n            } else {\n                env.classes.push(aliases);\n            }\n        }\n        _.hooks.run(\"wrap\", env);\n        var attributes = \"\";\n        for(var name in env.attributes){\n            attributes += \" \" + name + '=\"' + (env.attributes[name] || \"\").replace(/\"/g, \"&quot;\") + '\"';\n        }\n        return \"<\" + env.tag + ' class=\"' + env.classes.join(\" \") + '\"' + attributes + \">\" + env.content + \"</\" + env.tag + \">\";\n    };\n    /**\n\t * @param {RegExp} pattern\n\t * @param {number} pos\n\t * @param {string} text\n\t * @param {boolean} lookbehind\n\t * @returns {RegExpExecArray | null}\n\t */ function matchPattern(pattern, pos, text, lookbehind) {\n        pattern.lastIndex = pos;\n        var match = pattern.exec(text);\n        if (match && lookbehind && match[1]) {\n            // change the match to remove the text matched by the Prism lookbehind group\n            var lookbehindLength = match[1].length;\n            match.index += lookbehindLength;\n            match[0] = match[0].slice(lookbehindLength);\n        }\n        return match;\n    }\n    /**\n\t * @param {string} text\n\t * @param {LinkedList<string | Token>} tokenList\n\t * @param {any} grammar\n\t * @param {LinkedListNode<string | Token>} startNode\n\t * @param {number} startPos\n\t * @param {RematchOptions} [rematch]\n\t * @returns {void}\n\t * @private\n\t *\n\t * @typedef RematchOptions\n\t * @property {string} cause\n\t * @property {number} reach\n\t */ function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n        for(var token in grammar){\n            if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n                continue;\n            }\n            var patterns = grammar[token];\n            patterns = Array.isArray(patterns) ? patterns : [\n                patterns\n            ];\n            for(var j = 0; j < patterns.length; ++j){\n                if (rematch && rematch.cause == token + \",\" + j) {\n                    return;\n                }\n                var patternObj = patterns[j];\n                var inside = patternObj.inside;\n                var lookbehind = !!patternObj.lookbehind;\n                var greedy = !!patternObj.greedy;\n                var alias = patternObj.alias;\n                if (greedy && !patternObj.pattern.global) {\n                    // Without the global flag, lastIndex won't work\n                    var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n                    patternObj.pattern = RegExp(patternObj.pattern.source, flags + \"g\");\n                }\n                /** @type {RegExp} */ var pattern = patternObj.pattern || patternObj;\n                for(var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next){\n                    if (rematch && pos >= rematch.reach) {\n                        break;\n                    }\n                    var str = currentNode.value;\n                    if (tokenList.length > text.length) {\n                        // Something went terribly wrong, ABORT, ABORT!\n                        return;\n                    }\n                    if (str instanceof Token) {\n                        continue;\n                    }\n                    var removeCount = 1; // this is the to parameter of removeBetween\n                    var match;\n                    if (greedy) {\n                        match = matchPattern(pattern, pos, text, lookbehind);\n                        if (!match || match.index >= text.length) {\n                            break;\n                        }\n                        var from = match.index;\n                        var to = match.index + match[0].length;\n                        var p = pos;\n                        // find the node that contains the match\n                        p += currentNode.value.length;\n                        while(from >= p){\n                            currentNode = currentNode.next;\n                            p += currentNode.value.length;\n                        }\n                        // adjust pos (and p)\n                        p -= currentNode.value.length;\n                        pos = p;\n                        // the current node is a Token, then the match starts inside another Token, which is invalid\n                        if (currentNode.value instanceof Token) {\n                            continue;\n                        }\n                        // find the last node which is affected by this match\n                        for(var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === \"string\"); k = k.next){\n                            removeCount++;\n                            p += k.value.length;\n                        }\n                        removeCount--;\n                        // replace with the new match\n                        str = text.slice(pos, p);\n                        match.index -= pos;\n                    } else {\n                        match = matchPattern(pattern, 0, str, lookbehind);\n                        if (!match) {\n                            continue;\n                        }\n                    }\n                    // eslint-disable-next-line no-redeclare\n                    var from = match.index;\n                    var matchStr = match[0];\n                    var before = str.slice(0, from);\n                    var after = str.slice(from + matchStr.length);\n                    var reach = pos + str.length;\n                    if (rematch && reach > rematch.reach) {\n                        rematch.reach = reach;\n                    }\n                    var removeFrom = currentNode.prev;\n                    if (before) {\n                        removeFrom = addAfter(tokenList, removeFrom, before);\n                        pos += before.length;\n                    }\n                    removeRange(tokenList, removeFrom, removeCount);\n                    var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n                    currentNode = addAfter(tokenList, removeFrom, wrapped);\n                    if (after) {\n                        addAfter(tokenList, currentNode, after);\n                    }\n                    if (removeCount > 1) {\n                        // at least one Token object was removed, so we have to do some rematching\n                        // this can only happen if the current pattern is greedy\n                        /** @type {RematchOptions} */ var nestedRematch = {\n                            cause: token + \",\" + j,\n                            reach: reach\n                        };\n                        matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n                        // the reach might have been extended because of the rematching\n                        if (rematch && nestedRematch.reach > rematch.reach) {\n                            rematch.reach = nestedRematch.reach;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n\t * @typedef LinkedListNode\n\t * @property {T} value\n\t * @property {LinkedListNode<T> | null} prev The previous node.\n\t * @property {LinkedListNode<T> | null} next The next node.\n\t * @template T\n\t * @private\n\t */ /**\n\t * @template T\n\t * @private\n\t */ function LinkedList() {\n        /** @type {LinkedListNode<T>} */ var head = {\n            value: null,\n            prev: null,\n            next: null\n        };\n        /** @type {LinkedListNode<T>} */ var tail = {\n            value: null,\n            prev: head,\n            next: null\n        };\n        head.next = tail;\n        /** @type {LinkedListNode<T>} */ this.head = head;\n        /** @type {LinkedListNode<T>} */ this.tail = tail;\n        this.length = 0;\n    }\n    /**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListNode<T>} The added node.\n\t * @template T\n\t */ function addAfter(list, node, value) {\n        // assumes that node != list.tail && values.length >= 0\n        var next = node.next;\n        var newNode = {\n            value: value,\n            prev: node,\n            next: next\n        };\n        node.next = newNode;\n        next.prev = newNode;\n        list.length++;\n        return newNode;\n    }\n    /**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {number} count\n\t * @template T\n\t */ function removeRange(list, node, count) {\n        var next = node.next;\n        for(var i = 0; i < count && next !== list.tail; i++){\n            next = next.next;\n        }\n        node.next = next;\n        next.prev = node;\n        list.length -= i;\n    }\n    /**\n\t * @param {LinkedList<T>} list\n\t * @returns {T[]}\n\t * @template T\n\t */ function toArray(list) {\n        var array = [];\n        var node = list.head.next;\n        while(node !== list.tail){\n            array.push(node.value);\n            node = node.next;\n        }\n        return array;\n    }\n    return _;\n}();\nvar prism = Prism;\nPrism.default = Prism;\n/* This content is auto-generated to include some prismjs language components: */ /* \"prismjs/components/prism-markup\" */ prism.languages.markup = {\n    \"comment\": {\n        pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n        greedy: true\n    },\n    \"prolog\": {\n        pattern: /<\\?[\\s\\S]+?\\?>/,\n        greedy: true\n    },\n    \"doctype\": {\n        // https://www.w3.org/TR/xml/#NT-doctypedecl\n        pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n        greedy: true,\n        inside: {\n            \"internal-subset\": {\n                pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n                lookbehind: true,\n                greedy: true,\n                inside: null // see below\n            },\n            \"string\": {\n                pattern: /\"[^\"]*\"|'[^']*'/,\n                greedy: true\n            },\n            \"punctuation\": /^<!|>$|[[\\]]/,\n            \"doctype-tag\": /^DOCTYPE/i,\n            \"name\": /[^\\s<>'\"]+/\n        }\n    },\n    \"cdata\": {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        greedy: true\n    },\n    \"tag\": {\n        pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n        greedy: true,\n        inside: {\n            \"tag\": {\n                pattern: /^<\\/?[^\\s>\\/]+/,\n                inside: {\n                    \"punctuation\": /^<\\/?/,\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            },\n            \"special-attr\": [],\n            \"attr-value\": {\n                pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n                inside: {\n                    \"punctuation\": [\n                        {\n                            pattern: /^=/,\n                            alias: \"attr-equals\"\n                        },\n                        /\"|'/\n                    ]\n                }\n            },\n            \"punctuation\": /\\/?>/,\n            \"attr-name\": {\n                pattern: /[^\\s>\\/]+/,\n                inside: {\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            }\n        }\n    },\n    \"entity\": [\n        {\n            pattern: /&[\\da-z]{1,8};/i,\n            alias: \"named-entity\"\n        },\n        /&#x?[\\da-f]{1,8};/i\n    ]\n};\nprism.languages.markup[\"tag\"].inside[\"attr-value\"].inside[\"entity\"] = prism.languages.markup[\"entity\"];\nprism.languages.markup[\"doctype\"].inside[\"internal-subset\"].inside = prism.languages.markup; // Plugin to make entity title show the real entity, idea by Roman Komarov\nprism.hooks.add(\"wrap\", function(env) {\n    if (env.type === \"entity\") {\n        env.attributes[\"title\"] = env.content.replace(/&amp;/, \"&\");\n    }\n});\nObject.defineProperty(prism.languages.markup.tag, \"addInlined\", {\n    /**\n   * Adds an inlined language to markup.\n   *\n   * An example of an inlined language is CSS with `<style>` tags.\n   *\n   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addInlined('style', 'css');\n   */ value: function addInlined(tagName, lang) {\n        var includedCdataInside = {};\n        includedCdataInside[\"language-\" + lang] = {\n            pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n            lookbehind: true,\n            inside: prism.languages[lang]\n        };\n        includedCdataInside[\"cdata\"] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n        var inside = {\n            \"included-cdata\": {\n                pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n                inside: includedCdataInside\n            }\n        };\n        inside[\"language-\" + lang] = {\n            pattern: /[\\s\\S]+/,\n            inside: prism.languages[lang]\n        };\n        var def = {};\n        def[tagName] = {\n            pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function() {\n                return tagName;\n            }), \"i\"),\n            lookbehind: true,\n            greedy: true,\n            inside: inside\n        };\n        prism.languages.insertBefore(\"markup\", \"cdata\", def);\n    }\n});\nObject.defineProperty(prism.languages.markup.tag, \"addAttribute\", {\n    /**\n   * Adds an pattern to highlight languages embedded in HTML attributes.\n   *\n   * An example of an inlined language is CSS with `style` attributes.\n   *\n   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addAttribute('style', 'css');\n   */ value: function(attrName, lang) {\n        prism.languages.markup.tag.inside[\"special-attr\"].push({\n            pattern: RegExp(/(^|[\"'\\s])/.source + \"(?:\" + attrName + \")\" + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source, \"i\"),\n            lookbehind: true,\n            inside: {\n                \"attr-name\": /^[^\\s=]+/,\n                \"attr-value\": {\n                    pattern: /=[\\s\\S]+/,\n                    inside: {\n                        \"value\": {\n                            pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n                            lookbehind: true,\n                            alias: [\n                                lang,\n                                \"language-\" + lang\n                            ],\n                            inside: prism.languages[lang]\n                        },\n                        \"punctuation\": [\n                            {\n                                pattern: /^=/,\n                                alias: \"attr-equals\"\n                            },\n                            /\"|'/\n                        ]\n                    }\n                }\n            }\n        });\n    }\n});\nprism.languages.html = prism.languages.markup;\nprism.languages.mathml = prism.languages.markup;\nprism.languages.svg = prism.languages.markup;\nprism.languages.xml = prism.languages.extend(\"markup\", {});\nprism.languages.ssml = prism.languages.xml;\nprism.languages.atom = prism.languages.xml;\nprism.languages.rss = prism.languages.xml;\n/* \"prismjs/components/prism-bash\" */ (function(Prism) {\n    // $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\\n' '|'\n    // + LC_ALL, RANDOM, REPLY, SECONDS.\n    // + make sure PS1..4 are here as they are not always set,\n    // - some useless things.\n    var envVars = \"\\\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\\\b\";\n    var commandAfterHeredoc = {\n        pattern: /(^([\"']?)\\w+\\2)[ \\t]+\\S.*/,\n        lookbehind: true,\n        alias: \"punctuation\",\n        // this looks reasonably well in all themes\n        inside: null // see below\n    };\n    var insideString = {\n        \"bash\": commandAfterHeredoc,\n        \"environment\": {\n            pattern: RegExp(\"\\\\$\" + envVars),\n            alias: \"constant\"\n        },\n        \"variable\": [\n            {\n                pattern: /\\$?\\(\\([\\s\\S]+?\\)\\)/,\n                greedy: true,\n                inside: {\n                    // If there is a $ sign at the beginning highlight $(( and )) as variable\n                    \"variable\": [\n                        {\n                            pattern: /(^\\$\\(\\([\\s\\S]+)\\)\\)/,\n                            lookbehind: true\n                        },\n                        /^\\$\\(\\(/\n                    ],\n                    \"number\": /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee]-?\\d+)?/,\n                    // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic\n                    \"operator\": /--|\\+\\+|\\*\\*=?|<<=?|>>=?|&&|\\|\\||[=!+\\-*/%<>^&|]=?|[?~:]/,\n                    // If there is no $ sign at the beginning highlight (( and )) as punctuation\n                    \"punctuation\": /\\(\\(?|\\)\\)?|,|;/\n                }\n            },\n            {\n                pattern: /\\$\\((?:\\([^)]+\\)|[^()])+\\)|`[^`]+`/,\n                greedy: true,\n                inside: {\n                    \"variable\": /^\\$\\(|^`|\\)$|`$/\n                }\n            },\n            {\n                pattern: /\\$\\{[^}]+\\}/,\n                greedy: true,\n                inside: {\n                    \"operator\": /:[-=?+]?|[!\\/]|##?|%%?|\\^\\^?|,,?/,\n                    \"punctuation\": /[\\[\\]]/,\n                    \"environment\": {\n                        pattern: RegExp(\"(\\\\{)\" + envVars),\n                        lookbehind: true,\n                        alias: \"constant\"\n                    }\n                }\n            },\n            /\\$(?:\\w+|[#?*!@$])/\n        ],\n        // Escape sequences from echo and printf's manuals, and escaped quotes.\n        \"entity\": /\\\\(?:[abceEfnrtv\\\\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/\n    };\n    Prism.languages.bash = {\n        \"shebang\": {\n            pattern: /^#!\\s*\\/.*/,\n            alias: \"important\"\n        },\n        \"comment\": {\n            pattern: /(^|[^\"{\\\\$])#.*/,\n            lookbehind: true\n        },\n        \"function-name\": [\n            // b) foo() {\n            // c) function foo() {\n            // but not foo {\n            {\n                // a) and c)\n                pattern: /(\\bfunction\\s+)[\\w-]+(?=(?:\\s*\\(?:\\s*\\))?\\s*\\{)/,\n                lookbehind: true,\n                alias: \"function\"\n            },\n            {\n                // b)\n                pattern: /\\b[\\w-]+(?=\\s*\\(\\s*\\)\\s*\\{)/,\n                alias: \"function\"\n            }\n        ],\n        // Highlight variable names as variables in for and select beginnings.\n        \"for-or-select\": {\n            pattern: /(\\b(?:for|select)\\s+)\\w+(?=\\s+in\\s)/,\n            alias: \"variable\",\n            lookbehind: true\n        },\n        // Highlight variable names as variables in the left-hand part\n        // of assignments (= and +=).\n        \"assign-left\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()\\w+(?=\\+?=)/,\n            inside: {\n                \"environment\": {\n                    pattern: RegExp(\"(^|[\\\\s;|&]|[<>]\\\\()\" + envVars),\n                    lookbehind: true,\n                    alias: \"constant\"\n                }\n            },\n            alias: \"variable\",\n            lookbehind: true\n        },\n        \"string\": [\n            {\n                pattern: /((?:^|[^<])<<-?\\s*)(\\w+)\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\2/,\n                lookbehind: true,\n                greedy: true,\n                inside: insideString\n            },\n            //  No expansion (so no inside).\n            {\n                pattern: /((?:^|[^<])<<-?\\s*)([\"'])(\\w+)\\2\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\3/,\n                lookbehind: true,\n                greedy: true,\n                inside: {\n                    \"bash\": commandAfterHeredoc\n                }\n            },\n            {\n                // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\n                pattern: /(^|[^\\\\](?:\\\\\\\\)*)\"(?:\\\\[\\s\\S]|\\$\\([^)]+\\)|\\$(?!\\()|`[^`]+`|[^\"\\\\`$])*\"/,\n                lookbehind: true,\n                greedy: true,\n                inside: insideString\n            },\n            {\n                // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html\n                pattern: /(^|[^$\\\\])'[^']*'/,\n                lookbehind: true,\n                greedy: true\n            },\n            {\n                // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html\n                pattern: /\\$'(?:[^'\\\\]|\\\\[\\s\\S])*'/,\n                greedy: true,\n                inside: {\n                    \"entity\": insideString.entity\n                }\n            }\n        ],\n        \"environment\": {\n            pattern: RegExp(\"\\\\$?\" + envVars),\n            alias: \"constant\"\n        },\n        \"variable\": insideString.variable,\n        \"function\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\\s;|&])/,\n            lookbehind: true\n        },\n        \"keyword\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\\s;|&])/,\n            lookbehind: true\n        },\n        // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n        \"builtin\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:\\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\\s;|&])/,\n            lookbehind: true,\n            // Alias added to make those easier to distinguish from strings.\n            alias: \"class-name\"\n        },\n        \"boolean\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:false|true)(?=$|[)\\s;|&])/,\n            lookbehind: true\n        },\n        \"file-descriptor\": {\n            pattern: /\\B&\\d\\b/,\n            alias: \"important\"\n        },\n        \"operator\": {\n            // Lots of redirections here, but not just that.\n            pattern: /\\d?<>|>\\||\\+=|=[=~]?|!=?|<<[<-]?|[&\\d]?>>|\\d[<>]&?|[<>][&=]?|&[>&]?|\\|[&|]?/,\n            inside: {\n                \"file-descriptor\": {\n                    pattern: /^\\d/,\n                    alias: \"important\"\n                }\n            }\n        },\n        \"punctuation\": /\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];\\\\]/,\n        \"number\": {\n            pattern: /(^|\\s)(?:[1-9]\\d*|0)(?:[.,]\\d+)?\\b/,\n            lookbehind: true\n        }\n    };\n    commandAfterHeredoc.inside = Prism.languages.bash;\n    /* Patterns in command substitution. */ var toBeCopied = [\n        \"comment\",\n        \"function-name\",\n        \"for-or-select\",\n        \"assign-left\",\n        \"string\",\n        \"environment\",\n        \"function\",\n        \"keyword\",\n        \"builtin\",\n        \"boolean\",\n        \"file-descriptor\",\n        \"operator\",\n        \"punctuation\",\n        \"number\"\n    ];\n    var inside = insideString.variable[1].inside;\n    for(var i = 0; i < toBeCopied.length; i++){\n        inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];\n    }\n    Prism.languages.shell = Prism.languages.bash;\n})(prism);\n/* \"prismjs/components/prism-clike\" */ prism.languages.clike = {\n    \"comment\": [\n        {\n            pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n            lookbehind: true,\n            greedy: true\n        },\n        {\n            pattern: /(^|[^\\\\:])\\/\\/.*/,\n            lookbehind: true,\n            greedy: true\n        }\n    ],\n    \"string\": {\n        pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n    },\n    \"class-name\": {\n        pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n        lookbehind: true,\n        inside: {\n            \"punctuation\": /[.\\\\]/\n        }\n    },\n    \"keyword\": /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"function\": /\\b\\w+(?=\\()/,\n    \"number\": /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n    \"operator\": /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n    \"punctuation\": /[{}[\\];(),.:]/\n};\n/* \"prismjs/components/prism-c\" */ prism.languages.c = prism.languages.extend(\"clike\", {\n    \"comment\": {\n        pattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n        greedy: true\n    },\n    \"string\": {\n        // https://en.cppreference.com/w/c/language/string_literal\n        pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n        greedy: true\n    },\n    \"class-name\": {\n        pattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n        lookbehind: true\n    },\n    \"keyword\": /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n    \"function\": /\\b[a-z_]\\w*(?=\\s*\\()/i,\n    \"number\": /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n    \"operator\": />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n});\nprism.languages.insertBefore(\"c\", \"string\", {\n    \"char\": {\n        // https://en.cppreference.com/w/c/language/character_constant\n        pattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n        greedy: true\n    }\n});\nprism.languages.insertBefore(\"c\", \"string\", {\n    \"macro\": {\n        // allow for multiline macro definitions\n        // spaces after the # character compile fine with gcc\n        pattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n        lookbehind: true,\n        greedy: true,\n        alias: \"property\",\n        inside: {\n            \"string\": [\n                {\n                    // highlight the path of the include statement as a string\n                    pattern: /^(#\\s*include\\s*)<[^>]+>/,\n                    lookbehind: true\n                },\n                prism.languages.c[\"string\"]\n            ],\n            \"char\": prism.languages.c[\"char\"],\n            \"comment\": prism.languages.c[\"comment\"],\n            \"macro-name\": [\n                {\n                    pattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n                    lookbehind: true\n                },\n                {\n                    pattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n                    lookbehind: true,\n                    alias: \"function\"\n                }\n            ],\n            // highlight macro directives as keywords\n            \"directive\": {\n                pattern: /^(#\\s*)[a-z]+/,\n                lookbehind: true,\n                alias: \"keyword\"\n            },\n            \"directive-hash\": /^#/,\n            \"punctuation\": /##|\\\\(?=[\\r\\n])/,\n            \"expression\": {\n                pattern: /\\S[\\s\\S]*/,\n                inside: prism.languages.c\n            }\n        }\n    }\n});\nprism.languages.insertBefore(\"c\", \"function\", {\n    // highlight predefined macros as constants\n    \"constant\": /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n});\ndelete prism.languages.c[\"boolean\"];\n/* \"prismjs/components/prism-cpp\" */ (function(Prism) {\n    var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n    var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function() {\n        return keyword.source;\n    });\n    Prism.languages.cpp = Prism.languages.extend(\"c\", {\n        \"class-name\": [\n            {\n                pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function() {\n                    return keyword.source;\n                })),\n                lookbehind: true\n            },\n            //   void foo::bar() const {}\n            // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n            // it starts with an uppercase letter. This approximation should give decent results.\n            /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n            //   Foo::~Foo() {}\n            /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n            // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n            /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n        ],\n        \"keyword\": keyword,\n        \"number\": {\n            pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n            greedy: true\n        },\n        \"operator\": />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n        \"boolean\": /\\b(?:false|true)\\b/\n    });\n    Prism.languages.insertBefore(\"cpp\", \"string\", {\n        \"module\": {\n            // https://en.cppreference.com/w/cpp/language/modules\n            pattern: RegExp(/(\\b(?:import|module)\\s+)/.source + \"(?:\" + // header-name\n            /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source + \"|\" + // module name or partition or both\n            /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function() {\n                return modName;\n            }) + \")\"),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"string\": /^[<\"][\\s\\S]+/,\n                \"operator\": /:/,\n                \"punctuation\": /\\./\n            }\n        },\n        \"raw-string\": {\n            pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n            alias: \"string\",\n            greedy: true\n        }\n    });\n    Prism.languages.insertBefore(\"cpp\", \"keyword\", {\n        \"generic-function\": {\n            pattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n            inside: {\n                \"function\": /^\\w+/,\n                \"generic\": {\n                    pattern: /<[\\s\\S]+/,\n                    alias: \"class-name\",\n                    inside: Prism.languages.cpp\n                }\n            }\n        }\n    });\n    Prism.languages.insertBefore(\"cpp\", \"operator\", {\n        \"double-colon\": {\n            pattern: /::/,\n            alias: \"punctuation\"\n        }\n    });\n    Prism.languages.insertBefore(\"cpp\", \"class-name\", {\n        // the base clause is an optional list of parent classes\n        // https://en.cppreference.com/w/cpp/language/class\n        \"base-clause\": {\n            pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n            lookbehind: true,\n            greedy: true,\n            inside: Prism.languages.extend(\"cpp\", {})\n        }\n    });\n    Prism.languages.insertBefore(\"inside\", \"double-colon\", {\n        // All untokenized words that are not namespaces should be class names\n        \"class-name\": /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n    }, Prism.languages.cpp[\"base-clause\"]);\n})(prism);\n/* \"prismjs/components/prism-css\" */ (function(Prism) {\n    var string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n    Prism.languages.css = {\n        \"comment\": /\\/\\*[\\s\\S]*?\\*\\//,\n        \"atrule\": {\n            pattern: /@[\\w-](?:[^;{\\s]|\\s+(?![\\s{]))*(?:;|(?=\\s*\\{))/,\n            inside: {\n                \"rule\": /^@[\\w-]+/,\n                \"selector-function-argument\": {\n                    pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n                    lookbehind: true,\n                    alias: \"selector\"\n                },\n                \"keyword\": {\n                    pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n                    lookbehind: true\n                } // See rest below\n            }\n        },\n        \"url\": {\n            // https://drafts.csswg.org/css-values-3/#urls\n            pattern: RegExp(\"\\\\burl\\\\((?:\" + string.source + \"|\" + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + \")\\\\)\", \"i\"),\n            greedy: true,\n            inside: {\n                \"function\": /^url/i,\n                \"punctuation\": /^\\(|\\)$/,\n                \"string\": {\n                    pattern: RegExp(\"^\" + string.source + \"$\"),\n                    alias: \"url\"\n                }\n            }\n        },\n        \"selector\": {\n            pattern: RegExp(\"(^|[{}\\\\s])[^{}\\\\s](?:[^{};\\\"'\\\\s]|\\\\s+(?![\\\\s{])|\" + string.source + \")*(?=\\\\s*\\\\{)\"),\n            lookbehind: true\n        },\n        \"string\": {\n            pattern: string,\n            greedy: true\n        },\n        \"property\": {\n            pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n            lookbehind: true\n        },\n        \"important\": /!important\\b/i,\n        \"function\": {\n            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n            lookbehind: true\n        },\n        \"punctuation\": /[(){};:,]/\n    };\n    Prism.languages.css[\"atrule\"].inside.rest = Prism.languages.css;\n    var markup = Prism.languages.markup;\n    if (markup) {\n        markup.tag.addInlined(\"style\", \"css\");\n        markup.tag.addAttribute(\"style\", \"css\");\n    }\n})(prism);\n/* \"prismjs/components/prism-css-extras\" */ (function(Prism) {\n    var string = /(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/;\n    var selectorInside;\n    Prism.languages.css.selector = {\n        pattern: Prism.languages.css.selector.pattern,\n        lookbehind: true,\n        inside: selectorInside = {\n            \"pseudo-element\": /:(?:after|before|first-letter|first-line|selection)|::[-\\w]+/,\n            \"pseudo-class\": /:[-\\w]+/,\n            \"class\": /\\.[-\\w]+/,\n            \"id\": /#[-\\w]+/,\n            \"attribute\": {\n                pattern: RegExp(\"\\\\[(?:[^[\\\\]\\\"']|\" + string.source + \")*\\\\]\"),\n                greedy: true,\n                inside: {\n                    \"punctuation\": /^\\[|\\]$/,\n                    \"case-sensitivity\": {\n                        pattern: /(\\s)[si]$/i,\n                        lookbehind: true,\n                        alias: \"keyword\"\n                    },\n                    \"namespace\": {\n                        pattern: /^(\\s*)(?:(?!\\s)[-*\\w\\xA0-\\uFFFF])*\\|(?!=)/,\n                        lookbehind: true,\n                        inside: {\n                            \"punctuation\": /\\|$/\n                        }\n                    },\n                    \"attr-name\": {\n                        pattern: /^(\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+/,\n                        lookbehind: true\n                    },\n                    \"attr-value\": [\n                        string,\n                        {\n                            pattern: /(=\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+(?=\\s*$)/,\n                            lookbehind: true\n                        }\n                    ],\n                    \"operator\": /[|~*^$]?=/\n                }\n            },\n            \"n-th\": [\n                {\n                    pattern: /(\\(\\s*)[+-]?\\d*[\\dn](?:\\s*[+-]\\s*\\d+)?(?=\\s*\\))/,\n                    lookbehind: true,\n                    inside: {\n                        \"number\": /[\\dn]+/,\n                        \"operator\": /[+-]/\n                    }\n                },\n                {\n                    pattern: /(\\(\\s*)(?:even|odd)(?=\\s*\\))/i,\n                    lookbehind: true\n                }\n            ],\n            \"combinator\": />|\\+|~|\\|\\|/,\n            // the `tag` token has been existed and removed.\n            // because we can't find a perfect tokenize to match it.\n            // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.\n            \"punctuation\": /[(),]/\n        }\n    };\n    Prism.languages.css[\"atrule\"].inside[\"selector-function-argument\"].inside = selectorInside;\n    Prism.languages.insertBefore(\"css\", \"property\", {\n        \"variable\": {\n            pattern: /(^|[^-\\w\\xA0-\\uFFFF])--(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*/i,\n            lookbehind: true\n        }\n    });\n    var unit = {\n        pattern: /(\\b\\d+)(?:%|[a-z]+(?![\\w-]))/,\n        lookbehind: true\n    }; // 123 -123 .123 -.123 12.3 -12.3\n    var number = {\n        pattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n        lookbehind: true\n    };\n    Prism.languages.insertBefore(\"css\", \"function\", {\n        \"operator\": {\n            pattern: /(\\s)[+\\-*\\/](?=\\s)/,\n            lookbehind: true\n        },\n        // CAREFUL!\n        // Previewers and Inline color use hexcode and color.\n        \"hexcode\": {\n            pattern: /\\B#[\\da-f]{3,8}\\b/i,\n            alias: \"color\"\n        },\n        \"color\": [\n            {\n                pattern: /(^|[^\\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\\w-])/i,\n                lookbehind: true\n            },\n            {\n                pattern: /\\b(?:hsl|rgb)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:hsl|rgb)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n                inside: {\n                    \"unit\": unit,\n                    \"number\": number,\n                    \"function\": /[\\w-]+(?=\\()/,\n                    \"punctuation\": /[(),]/\n                }\n            }\n        ],\n        // it's important that there is no boundary assertion after the hex digits\n        \"entity\": /\\\\[\\da-f]{1,8}/i,\n        \"unit\": unit,\n        \"number\": number\n    });\n})(prism);\n/* \"prismjs/components/prism-javascript\" */ prism.languages.javascript = prism.languages.extend(\"clike\", {\n    \"class-name\": [\n        prism.languages.clike[\"class-name\"],\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n            lookbehind: true\n        }\n    ],\n    \"keyword\": [\n        {\n            pattern: /((?:^|\\})\\s*)catch\\b/,\n            lookbehind: true\n        },\n        {\n            pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n            lookbehind: true\n        }\n    ],\n    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n    \"function\": /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n    \"number\": {\n        pattern: RegExp(/(^|[^\\w$])/.source + \"(?:\" + (/NaN|Infinity/.source + \"|\" + // binary integer\n        /0[bB][01]+(?:_[01]+)*n?/.source + \"|\" + // octal integer\n        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + \"|\" + // hexadecimal integer\n        /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + \"|\" + // decimal bigint\n        /\\d+(?:_\\d+)*n/.source + \"|\" + // decimal number (integer or float) but no bigint\n        /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + \")\" + /(?![\\w$])/.source),\n        lookbehind: true\n    },\n    \"operator\": /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\nprism.languages.javascript[\"class-name\"][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\nprism.languages.insertBefore(\"javascript\", \"keyword\", {\n    \"regex\": {\n        // eslint-disable-next-line regexp/no-dupe-characters-character-class\n        pattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)\\/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n            \"regex-source\": {\n                pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n                lookbehind: true,\n                alias: \"language-regex\",\n                inside: prism.languages.regex\n            },\n            \"regex-delimiter\": /^\\/|\\/$/,\n            \"regex-flags\": /^[a-z]+$/\n        }\n    },\n    // This must be declared before keyword because we use \"function\" inside the look-forward\n    \"function-variable\": {\n        pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n        alias: \"function\"\n    },\n    \"parameter\": [\n        {\n            pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n            lookbehind: true,\n            inside: prism.languages.javascript\n        },\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n            lookbehind: true,\n            inside: prism.languages.javascript\n        },\n        {\n            pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n            lookbehind: true,\n            inside: prism.languages.javascript\n        },\n        {\n            pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n            lookbehind: true,\n            inside: prism.languages.javascript\n        }\n    ],\n    \"constant\": /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\nprism.languages.insertBefore(\"javascript\", \"string\", {\n    \"hashbang\": {\n        pattern: /^#!.*/,\n        greedy: true,\n        alias: \"comment\"\n    },\n    \"template-string\": {\n        pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n        greedy: true,\n        inside: {\n            \"template-punctuation\": {\n                pattern: /^`|`$/,\n                alias: \"string\"\n            },\n            \"interpolation\": {\n                pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n                lookbehind: true,\n                inside: {\n                    \"interpolation-punctuation\": {\n                        pattern: /^\\$\\{|\\}$/,\n                        alias: \"punctuation\"\n                    },\n                    rest: prism.languages.javascript\n                }\n            },\n            \"string\": /[\\s\\S]+/\n        }\n    },\n    \"string-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n        lookbehind: true,\n        greedy: true,\n        alias: \"property\"\n    }\n});\nprism.languages.insertBefore(\"javascript\", \"operator\", {\n    \"literal-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n        lookbehind: true,\n        alias: \"property\"\n    }\n});\nif (prism.languages.markup) {\n    prism.languages.markup.tag.addInlined(\"script\", \"javascript\"); // add attribute support for all DOM events.\n    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n    prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, \"javascript\");\n}\nprism.languages.js = prism.languages.javascript;\n/* \"prismjs/components/prism-coffeescript\" */ (function(Prism) {\n    // Ignore comments starting with { to privilege string interpolation highlighting\n    var comment = /#(?!\\{).+/;\n    var interpolation = {\n        pattern: /#\\{[^}]+\\}/,\n        alias: \"variable\"\n    };\n    Prism.languages.coffeescript = Prism.languages.extend(\"javascript\", {\n        \"comment\": comment,\n        \"string\": [\n            {\n                pattern: /'(?:\\\\[\\s\\S]|[^\\\\'])*'/,\n                greedy: true\n            },\n            {\n                // Strings are multiline\n                pattern: /\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"/,\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation\n                }\n            }\n        ],\n        \"keyword\": /\\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\\b/,\n        \"class-member\": {\n            pattern: /@(?!\\d)\\w+/,\n            alias: \"variable\"\n        }\n    });\n    Prism.languages.insertBefore(\"coffeescript\", \"comment\", {\n        \"multiline-comment\": {\n            pattern: /###[\\s\\S]+?###/,\n            alias: \"comment\"\n        },\n        // Block regexp can contain comments and interpolation\n        \"block-regex\": {\n            pattern: /\\/{3}[\\s\\S]*?\\/{3}/,\n            alias: \"regex\",\n            inside: {\n                \"comment\": comment,\n                \"interpolation\": interpolation\n            }\n        }\n    });\n    Prism.languages.insertBefore(\"coffeescript\", \"string\", {\n        \"inline-javascript\": {\n            pattern: /`(?:\\\\[\\s\\S]|[^\\\\`])*`/,\n            inside: {\n                \"delimiter\": {\n                    pattern: /^`|`$/,\n                    alias: \"punctuation\"\n                },\n                \"script\": {\n                    pattern: /[\\s\\S]+/,\n                    alias: \"language-javascript\",\n                    inside: Prism.languages.javascript\n                }\n            }\n        },\n        // Block strings\n        \"multiline-string\": [\n            {\n                pattern: /'''[\\s\\S]*?'''/,\n                greedy: true,\n                alias: \"string\"\n            },\n            {\n                pattern: /\"\"\"[\\s\\S]*?\"\"\"/,\n                greedy: true,\n                alias: \"string\",\n                inside: {\n                    interpolation: interpolation\n                }\n            }\n        ]\n    });\n    Prism.languages.insertBefore(\"coffeescript\", \"keyword\", {\n        // Object property\n        \"property\": /(?!\\d)\\w+(?=\\s*:(?!:))/\n    });\n    delete Prism.languages.coffeescript[\"template-string\"];\n    Prism.languages.coffee = Prism.languages.coffeescript;\n})(prism);\n/* \"prismjs/components/prism-yaml\" */ (function(Prism) {\n    // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property\n    // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node\n    var anchorOrAlias = /[*&][^\\s[\\]{},]+/; // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property\n    var tag = /!(?:<[\\w\\-%#;/?:@&=+$,.!~*'()[\\]]+>|(?:[a-zA-Z\\d-]*!)?[\\w\\-%#;/?:@&=+$.~*'()]+)?/; // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)\n    var properties = \"(?:\" + tag.source + \"(?:[ \t]+\" + anchorOrAlias.source + \")?|\" + anchorOrAlias.source + \"(?:[ \t]+\" + tag.source + \")?)\"; // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)\n    // This is a simplified version that doesn't support \"#\" and multiline keys\n    // All these long scarry character classes are simplified versions of YAML's characters\n    var plainKey = /(?:[^\\s\\x00-\\x08\\x0e-\\x1f!\"#%&'*,\\-:>?@[\\]`{|}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]|[?:-]<PLAIN>)(?:[ \\t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {\n        return /[^\\s\\x00-\\x08\\x0e-\\x1f,[\\]{}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]/.source;\n    });\n    var string = /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"|'(?:[^'\\\\\\r\\n]|\\\\.)*'/.source;\n    /**\n   *\n   * @param {string} value\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */ function createValuePattern(value, flags) {\n        flags = (flags || \"\").replace(/m/g, \"\") + \"m\"; // add m flag\n        var pattern = /([:\\-,[{]\\s*(?:\\s<<prop>>[ \\t]+)?)(?:<<value>>)(?=[ \\t]*(?:$|,|\\]|\\}|(?:[\\r\\n]\\s*)?#))/.source.replace(/<<prop>>/g, function() {\n            return properties;\n        }).replace(/<<value>>/g, function() {\n            return value;\n        });\n        return RegExp(pattern, flags);\n    }\n    Prism.languages.yaml = {\n        \"scalar\": {\n            pattern: RegExp(/([\\-:]\\s*(?:\\s<<prop>>[ \\t]+)?[|>])[ \\t]*(?:((?:\\r?\\n|\\r)[ \\t]+)\\S[^\\r\\n]*(?:\\2[^\\r\\n]+)*)/.source.replace(/<<prop>>/g, function() {\n                return properties;\n            })),\n            lookbehind: true,\n            alias: \"string\"\n        },\n        \"comment\": /#.*/,\n        \"key\": {\n            pattern: RegExp(/((?:^|[:\\-,[{\\r\\n?])[ \\t]*(?:<<prop>>[ \\t]+)?)<<key>>(?=\\s*:\\s)/.source.replace(/<<prop>>/g, function() {\n                return properties;\n            }).replace(/<<key>>/g, function() {\n                return \"(?:\" + plainKey + \"|\" + string + \")\";\n            })),\n            lookbehind: true,\n            greedy: true,\n            alias: \"atrule\"\n        },\n        \"directive\": {\n            pattern: /(^[ \\t]*)%.+/m,\n            lookbehind: true,\n            alias: \"important\"\n        },\n        \"datetime\": {\n            pattern: createValuePattern(/\\d{4}-\\d\\d?-\\d\\d?(?:[tT]|[ \\t]+)\\d\\d?:\\d{2}:\\d{2}(?:\\.\\d*)?(?:[ \\t]*(?:Z|[-+]\\d\\d?(?::\\d{2})?))?|\\d{4}-\\d{2}-\\d{2}|\\d\\d?:\\d{2}(?::\\d{2}(?:\\.\\d*)?)?/.source),\n            lookbehind: true,\n            alias: \"number\"\n        },\n        \"boolean\": {\n            pattern: createValuePattern(/false|true/.source, \"i\"),\n            lookbehind: true,\n            alias: \"important\"\n        },\n        \"null\": {\n            pattern: createValuePattern(/null|~/.source, \"i\"),\n            lookbehind: true,\n            alias: \"important\"\n        },\n        \"string\": {\n            pattern: createValuePattern(string),\n            lookbehind: true,\n            greedy: true\n        },\n        \"number\": {\n            pattern: createValuePattern(/[+-]?(?:0x[\\da-f]+|0o[0-7]+|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?|\\.inf|\\.nan)/.source, \"i\"),\n            lookbehind: true\n        },\n        \"tag\": tag,\n        \"important\": anchorOrAlias,\n        \"punctuation\": /---|[:[\\]{}\\-,|>?]|\\.\\.\\./\n    };\n    Prism.languages.yml = Prism.languages.yaml;\n})(prism);\n/* \"prismjs/components/prism-markdown\" */ (function(Prism) {\n    // Allow only one line break\n    var inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n    /**\n   * This function is intended for the creation of the bold or italic pattern.\n   *\n   * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n   *\n   * _Note:_ Keep in mind that this adds a capturing group.\n   *\n   * @param {string} pattern\n   * @returns {RegExp}\n   */ function createInline(pattern) {\n        pattern = pattern.replace(/<inner>/g, function() {\n            return inner;\n        });\n        return RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + \"(?:\" + pattern + \")\");\n    }\n    var tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/.source;\n    var tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(/__/g, function() {\n        return tableCell;\n    });\n    var tableLine = /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/.source;\n    Prism.languages.markdown = Prism.languages.extend(\"markup\", {});\n    Prism.languages.insertBefore(\"markdown\", \"prolog\", {\n        \"front-matter-block\": {\n            pattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"punctuation\": /^---|---$/,\n                \"front-matter\": {\n                    pattern: /\\S+(?:\\s+\\S+)*/,\n                    alias: [\n                        \"yaml\",\n                        \"language-yaml\"\n                    ],\n                    inside: Prism.languages.yaml\n                }\n            }\n        },\n        \"blockquote\": {\n            // > ...\n            pattern: /^>(?:[\\t ]*>)*/m,\n            alias: \"punctuation\"\n        },\n        \"table\": {\n            pattern: RegExp(\"^\" + tableRow + tableLine + \"(?:\" + tableRow + \")*\", \"m\"),\n            inside: {\n                \"table-data-rows\": {\n                    pattern: RegExp(\"^(\" + tableRow + tableLine + \")(?:\" + tableRow + \")*$\"),\n                    lookbehind: true,\n                    inside: {\n                        \"table-data\": {\n                            pattern: RegExp(tableCell),\n                            inside: Prism.languages.markdown\n                        },\n                        \"punctuation\": /\\|/\n                    }\n                },\n                \"table-line\": {\n                    pattern: RegExp(\"^(\" + tableRow + \")\" + tableLine + \"$\"),\n                    lookbehind: true,\n                    inside: {\n                        \"punctuation\": /\\||:?-{3,}:?/\n                    }\n                },\n                \"table-header-row\": {\n                    pattern: RegExp(\"^\" + tableRow + \"$\"),\n                    inside: {\n                        \"table-header\": {\n                            pattern: RegExp(tableCell),\n                            alias: \"important\",\n                            inside: Prism.languages.markdown\n                        },\n                        \"punctuation\": /\\|/\n                    }\n                }\n            }\n        },\n        \"code\": [\n            {\n                // Prefixed by 4 spaces or 1 tab and preceded by an empty line\n                pattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n                lookbehind: true,\n                alias: \"keyword\"\n            },\n            {\n                // ```optional language\n                // code block\n                // ```\n                pattern: /^```[\\s\\S]*?^```$/m,\n                greedy: true,\n                inside: {\n                    \"code-block\": {\n                        pattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n                        lookbehind: true\n                    },\n                    \"code-language\": {\n                        pattern: /^(```).+/,\n                        lookbehind: true\n                    },\n                    \"punctuation\": /```/\n                }\n            }\n        ],\n        \"title\": [\n            {\n                // title 1\n                // =======\n                // title 2\n                // -------\n                pattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n                alias: \"important\",\n                inside: {\n                    punctuation: /==+$|--+$/\n                }\n            },\n            {\n                // # title 1\n                // ###### title 6\n                pattern: /(^\\s*)#.+/m,\n                lookbehind: true,\n                alias: \"important\",\n                inside: {\n                    punctuation: /^#+|#+$/\n                }\n            }\n        ],\n        \"hr\": {\n            // ***\n            // ---\n            // * * *\n            // -----------\n            pattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n            lookbehind: true,\n            alias: \"punctuation\"\n        },\n        \"list\": {\n            // * item\n            // + item\n            // - item\n            // 1. item\n            pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n            lookbehind: true,\n            alias: \"punctuation\"\n        },\n        \"url-reference\": {\n            // [id]: http://example.com \"Optional title\"\n            // [id]: http://example.com 'Optional title'\n            // [id]: http://example.com (Optional title)\n            // [id]: <http://example.com> \"Optional title\"\n            pattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n            inside: {\n                \"variable\": {\n                    pattern: /^(!?\\[)[^\\]]+/,\n                    lookbehind: true\n                },\n                \"string\": /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n                \"punctuation\": /^[\\[\\]!:]|[<>]/\n            },\n            alias: \"url\"\n        },\n        \"bold\": {\n            // **strong**\n            // __strong__\n            // allow one nested instance of italic text using the same delimiter\n            pattern: createInline(/\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"content\": {\n                    pattern: /(^..)[\\s\\S]+(?=..$)/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"punctuation\": /\\*\\*|__/\n            }\n        },\n        \"italic\": {\n            // *em*\n            // _em_\n            // allow one nested instance of bold text using the same delimiter\n            pattern: createInline(/\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"content\": {\n                    pattern: /(^.)[\\s\\S]+(?=.$)/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"punctuation\": /[*_]/\n            }\n        },\n        \"strike\": {\n            // ~~strike through~~\n            // ~strike~\n            // eslint-disable-next-line regexp/strict\n            pattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"content\": {\n                    pattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"punctuation\": /~~?/\n            }\n        },\n        \"code-snippet\": {\n            // `code`\n            // ``code``\n            pattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n            lookbehind: true,\n            greedy: true,\n            alias: [\n                \"code\",\n                \"keyword\"\n            ]\n        },\n        \"url\": {\n            // [example](http://example.com \"Optional title\")\n            // [example][id]\n            // [example] [id]\n            pattern: createInline(/!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"operator\": /^!/,\n                \"content\": {\n                    pattern: /(^\\[)[^\\]]+(?=\\])/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"variable\": {\n                    pattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n                    lookbehind: true\n                },\n                \"url\": {\n                    pattern: /(^\\]\\()[^\\s)]+/,\n                    lookbehind: true\n                },\n                \"string\": {\n                    pattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n                    lookbehind: true\n                }\n            }\n        }\n    });\n    [\n        \"url\",\n        \"bold\",\n        \"italic\",\n        \"strike\"\n    ].forEach(function(token) {\n        [\n            \"url\",\n            \"bold\",\n            \"italic\",\n            \"strike\",\n            \"code-snippet\"\n        ].forEach(function(inside) {\n            if (token !== inside) {\n                Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];\n            }\n        });\n    });\n    Prism.hooks.add(\"after-tokenize\", function(env) {\n        if (env.language !== \"markdown\" && env.language !== \"md\") {\n            return;\n        }\n        function walkTokens(tokens) {\n            if (!tokens || typeof tokens === \"string\") {\n                return;\n            }\n            for(var i = 0, l = tokens.length; i < l; i++){\n                var token = tokens[i];\n                if (token.type !== \"code\") {\n                    walkTokens(token.content);\n                    continue;\n                }\n                /*\n         * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n         * is optional. But the grammar is defined so that there is only one case we have to handle:\n         *\n         * token.content = [\n         *     <span class=\"punctuation\">```</span>,\n         *     <span class=\"code-language\">xxxx</span>,\n         *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n         *     <span class=\"code-block\">...</span>,\n         *     '\\n', // exactly one new lines again\n         *     <span class=\"punctuation\">```</span>\n         * ];\n         */ var codeLang = token.content[1];\n                var codeBlock = token.content[3];\n                if (codeLang && codeBlock && codeLang.type === \"code-language\" && codeBlock.type === \"code-block\" && typeof codeLang.content === \"string\") {\n                    // this might be a language that Prism does not support\n                    // do some replacements to support C++, C#, and F#\n                    var lang = codeLang.content.replace(/\\b#/g, \"sharp\").replace(/\\b\\+\\+/g, \"pp\"); // only use the first word\n                    lang = (/[a-z][\\w-]*/i.exec(lang) || [\n                        \"\"\n                    ])[0].toLowerCase();\n                    var alias = \"language-\" + lang; // add alias\n                    if (!codeBlock.alias) {\n                        codeBlock.alias = [\n                            alias\n                        ];\n                    } else if (typeof codeBlock.alias === \"string\") {\n                        codeBlock.alias = [\n                            codeBlock.alias,\n                            alias\n                        ];\n                    } else {\n                        codeBlock.alias.push(alias);\n                    }\n                }\n            }\n        }\n        walkTokens(env.tokens);\n    });\n    Prism.hooks.add(\"wrap\", function(env) {\n        if (env.type !== \"code-block\") {\n            return;\n        }\n        var codeLang = \"\";\n        for(var i = 0, l = env.classes.length; i < l; i++){\n            var cls = env.classes[i];\n            var match = /language-(.+)/.exec(cls);\n            if (match) {\n                codeLang = match[1];\n                break;\n            }\n        }\n        var grammar = Prism.languages[codeLang];\n        if (!grammar) {\n            if (codeLang && codeLang !== \"none\" && Prism.plugins.autoloader) {\n                var id = \"md-\" + new Date().valueOf() + \"-\" + Math.floor(Math.random() * 1e16);\n                env.attributes[\"id\"] = id;\n                Prism.plugins.autoloader.loadLanguages(codeLang, function() {\n                    var ele = document.getElementById(id);\n                    if (ele) {\n                        ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);\n                    }\n                });\n            }\n        } else {\n            env.content = Prism.highlight(textContent(env.content), grammar, codeLang);\n        }\n    });\n    var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, \"gi\");\n    /**\n   * A list of known entity names.\n   *\n   * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n   *\n   * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n   */ var KNOWN_ENTITY_NAMES = {\n        \"amp\": \"&\",\n        \"lt\": \"<\",\n        \"gt\": \">\",\n        \"quot\": '\"'\n    }; // IE 11 doesn't support `String.fromCodePoint`\n    var fromCodePoint = String.fromCodePoint || String.fromCharCode;\n    /**\n   * Returns the text content of a given HTML source code string.\n   *\n   * @param {string} html\n   * @returns {string}\n   */ function textContent(html) {\n        // remove all tags\n        var text = html.replace(tagPattern, \"\"); // decode known entities\n        text = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function(m, code) {\n            code = code.toLowerCase();\n            if (code[0] === \"#\") {\n                var value;\n                if (code[1] === \"x\") {\n                    value = parseInt(code.slice(2), 16);\n                } else {\n                    value = Number(code.slice(1));\n                }\n                return fromCodePoint(value);\n            } else {\n                var known = KNOWN_ENTITY_NAMES[code];\n                if (known) {\n                    return known;\n                } // unable to decode\n                return m;\n            }\n        });\n        return text;\n    }\n    Prism.languages.md = Prism.languages.markdown;\n})(prism);\n/* \"prismjs/components/prism-graphql\" */ prism.languages.graphql = {\n    \"comment\": /#.*/,\n    \"description\": {\n        pattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n        greedy: true,\n        alias: \"string\",\n        inside: {\n            \"language-markdown\": {\n                pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n                lookbehind: true,\n                inside: prism.languages.markdown\n            }\n        }\n    },\n    \"string\": {\n        pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n        greedy: true\n    },\n    \"number\": /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"variable\": /\\$[a-z_]\\w*/i,\n    \"directive\": {\n        pattern: /@[a-z_]\\w*/i,\n        alias: \"function\"\n    },\n    \"attr-name\": {\n        pattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n        greedy: true\n    },\n    \"atom-input\": {\n        pattern: /\\b[A-Z]\\w*Input\\b/,\n        alias: \"class-name\"\n    },\n    \"scalar\": /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n    \"constant\": /\\b[A-Z][A-Z_\\d]*\\b/,\n    \"class-name\": {\n        pattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n        lookbehind: true\n    },\n    \"fragment\": {\n        pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n        lookbehind: true,\n        alias: \"function\"\n    },\n    \"definition-mutation\": {\n        pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n        lookbehind: true,\n        alias: \"function\"\n    },\n    \"definition-query\": {\n        pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n        lookbehind: true,\n        alias: \"function\"\n    },\n    \"keyword\": /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n    \"operator\": /[!=|&]|\\.{3}/,\n    \"property-query\": /\\w+(?=\\s*\\()/,\n    \"object\": /\\w+(?=\\s*\\{)/,\n    \"punctuation\": /[!(){}\\[\\]:=,]/,\n    \"property\": /\\w+/\n};\nprism.hooks.add(\"after-tokenize\", function afterTokenizeGraphql(env) {\n    if (env.language !== \"graphql\") {\n        return;\n    }\n    /**\n   * get the graphql token stream that we want to customize\n   *\n   * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n   * @type {Token[]}\n   */ var validTokens = env.tokens.filter(function(token) {\n        return typeof token !== \"string\" && token.type !== \"comment\" && token.type !== \"scalar\";\n    });\n    var currentIndex = 0;\n    /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {number} offset\n   * @returns {Token | undefined}\n   */ function getToken(offset) {\n        return validTokens[currentIndex + offset];\n    }\n    /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {readonly string[]} types\n   * @param {number} [offset=0]\n   * @returns {boolean}\n   */ function isTokenType(types, offset) {\n        offset = offset || 0;\n        for(var i = 0; i < types.length; i++){\n            var token = getToken(i + offset);\n            if (!token || token.type !== types[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n   * Returns the index of the closing bracket to an opening bracket.\n   *\n   * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n   *\n   * If no closing bracket could be found, `-1` will be returned.\n   *\n   * @param {RegExp} open\n   * @param {RegExp} close\n   * @returns {number}\n   */ function findClosingBracket(open, close) {\n        var stackHeight = 1;\n        for(var i = currentIndex; i < validTokens.length; i++){\n            var token = validTokens[i];\n            var content = token.content;\n            if (token.type === \"punctuation\" && typeof content === \"string\") {\n                if (open.test(content)) {\n                    stackHeight++;\n                } else if (close.test(content)) {\n                    stackHeight--;\n                    if (stackHeight === 0) {\n                        return i;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n   * Adds an alias to the given token.\n   *\n   * @param {Token} token\n   * @param {string} alias\n   * @returns {void}\n   */ function addAlias(token, alias) {\n        var aliases = token.alias;\n        if (!aliases) {\n            token.alias = aliases = [];\n        } else if (!Array.isArray(aliases)) {\n            token.alias = aliases = [\n                aliases\n            ];\n        }\n        aliases.push(alias);\n    }\n    for(; currentIndex < validTokens.length;){\n        var startToken = validTokens[currentIndex++]; // add special aliases for mutation tokens\n        if (startToken.type === \"keyword\" && startToken.content === \"mutation\") {\n            // any array of the names of all input variables (if any)\n            var inputVariables = [];\n            if (isTokenType([\n                \"definition-mutation\",\n                \"punctuation\"\n            ]) && getToken(1).content === \"(\") {\n                // definition\n                currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n                var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n                if (definitionEnd === -1) {\n                    continue;\n                } // find all input variables\n                for(; currentIndex < definitionEnd; currentIndex++){\n                    var t = getToken(0);\n                    if (t.type === \"variable\") {\n                        addAlias(t, \"variable-input\");\n                        inputVariables.push(t.content);\n                    }\n                }\n                currentIndex = definitionEnd + 1;\n            }\n            if (isTokenType([\n                \"punctuation\",\n                \"property-query\"\n            ]) && getToken(0).content === \"{\") {\n                currentIndex++; // skip opening bracket\n                addAlias(getToken(0), \"property-mutation\");\n                if (inputVariables.length > 0) {\n                    var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n                    if (mutationEnd === -1) {\n                        continue;\n                    } // give references to input variables a special alias\n                    for(var i = currentIndex; i < mutationEnd; i++){\n                        var varToken = validTokens[i];\n                        if (varToken.type === \"variable\" && inputVariables.indexOf(varToken.content) >= 0) {\n                            addAlias(varToken, \"variable-input\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n});\n/* \"prismjs/components/prism-sql\" */ prism.languages.sql = {\n    \"comment\": {\n        pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n        lookbehind: true\n    },\n    \"variable\": [\n        {\n            pattern: /@([\"'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n            greedy: true\n        },\n        /@[\\w.$]+/\n    ],\n    \"string\": {\n        pattern: /(^|[^@\\\\])(\"|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n        greedy: true,\n        lookbehind: true\n    },\n    \"identifier\": {\n        pattern: /(^|[^@\\\\])`(?:\\\\[\\s\\S]|[^`\\\\]|``)*`/,\n        greedy: true,\n        lookbehind: true,\n        inside: {\n            \"punctuation\": /^`|`$/\n        }\n    },\n    \"function\": /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i,\n    // Should we highlight user defined functions too?\n    \"keyword\": /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n    \"boolean\": /\\b(?:FALSE|NULL|TRUE)\\b/i,\n    \"number\": /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n    \"operator\": /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n    \"punctuation\": /[;[\\]()`,.]/\n};\n/* \"prismjs/components/prism-js-templates\" */ (function(Prism) {\n    var templateString = Prism.languages.javascript[\"template-string\"]; // see the pattern in prism-javascript.js\n    var templateLiteralPattern = templateString.pattern.source;\n    var interpolationObject = templateString.inside[\"interpolation\"];\n    var interpolationPunctuationObject = interpolationObject.inside[\"interpolation-punctuation\"];\n    var interpolationPattern = interpolationObject.pattern.source;\n    /**\n   * Creates a new pattern to match a template string with a special tag.\n   *\n   * This will return `undefined` if there is no grammar with the given language id.\n   *\n   * @param {string} language The language id of the embedded language. E.g. `markdown`.\n   * @param {string} tag The regex pattern to match the tag.\n   * @returns {object | undefined}\n   * @example\n   * createTemplate('css', /\\bcss/.source);\n   */ function createTemplate(language, tag) {\n        if (!Prism.languages[language]) {\n            return undefined;\n        }\n        return {\n            pattern: RegExp(\"((?:\" + tag + \")\\\\s*)\" + templateLiteralPattern),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"template-punctuation\": {\n                    pattern: /^`|`$/,\n                    alias: \"string\"\n                },\n                \"embedded-code\": {\n                    pattern: /[\\s\\S]+/,\n                    alias: language\n                }\n            }\n        };\n    }\n    Prism.languages.javascript[\"template-string\"] = [\n        //   css`a { color: #25F; }`\n        // styled-components:\n        //   styled.h1`color: red;`\n        createTemplate(\"css\", /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),\n        // div.innerHTML = `<p></p>`\n        createTemplate(\"html\", /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),\n        createTemplate(\"svg\", /\\bsvg/.source),\n        createTemplate(\"markdown\", /\\b(?:markdown|md)/.source),\n        createTemplate(\"graphql\", /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),\n        createTemplate(\"sql\", /\\bsql/.source),\n        templateString\n    ].filter(Boolean);\n    /**\n   * Returns a specific placeholder literal for the given language.\n   *\n   * @param {number} counter\n   * @param {string} language\n   * @returns {string}\n   */ function getPlaceholder(counter, language) {\n        return \"___\" + language.toUpperCase() + \"_\" + counter + \"___\";\n    }\n    /**\n   * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n   *\n   * @param {string} code\n   * @param {any} grammar\n   * @param {string} language\n   * @returns {(string|Token)[]}\n   */ function tokenizeWithHooks(code, grammar, language) {\n        var env = {\n            code: code,\n            grammar: grammar,\n            language: language\n        };\n        Prism.hooks.run(\"before-tokenize\", env);\n        env.tokens = Prism.tokenize(env.code, env.grammar);\n        Prism.hooks.run(\"after-tokenize\", env);\n        return env.tokens;\n    }\n    /**\n   * Returns the token of the given JavaScript interpolation expression.\n   *\n   * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n   * @returns {Token}\n   */ function tokenizeInterpolationExpression(expression) {\n        var tempGrammar = {};\n        tempGrammar[\"interpolation-punctuation\"] = interpolationPunctuationObject;\n        /** @type {Array} */ var tokens = Prism.tokenize(expression, tempGrammar);\n        if (tokens.length === 3) {\n            /**\n       * The token array will look like this\n       * [\n       *     [\"interpolation-punctuation\", \"${\"]\n       *     \"...\" // JavaScript expression of the interpolation\n       *     [\"interpolation-punctuation\", \"}\"]\n       * ]\n       */ var args = [\n                1,\n                1\n            ];\n            args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, \"javascript\"));\n            tokens.splice.apply(tokens, args);\n        }\n        return new Prism.Token(\"interpolation\", tokens, interpolationObject.alias, expression);\n    }\n    /**\n   * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n   *\n   * This function has 3 phases:\n   *\n   * 1. Replace all JavaScript interpolation expression with a placeholder.\n   *    The placeholder will have the syntax of a identify of the target language.\n   * 2. Tokenize the code with placeholders.\n   * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n   *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n   *    tokenized as two tokens by the grammar of the embedded language.\n   *\n   * @param {string} code\n   * @param {object} grammar\n   * @param {string} language\n   * @returns {Token}\n   */ function tokenizeEmbedded(code, grammar, language) {\n        // 1. First filter out all interpolations\n        // because they might be escaped, we need a lookbehind, so we use Prism\n        /** @type {(Token|string)[]} */ var _tokens = Prism.tokenize(code, {\n            \"interpolation\": {\n                pattern: RegExp(interpolationPattern),\n                lookbehind: true\n            }\n        }); // replace all interpolations with a placeholder which is not in the code already\n        var placeholderCounter = 0;\n        /** @type {Object<string, string>} */ var placeholderMap = {};\n        var embeddedCode = _tokens.map(function(token) {\n            if (typeof token === \"string\") {\n                return token;\n            } else {\n                var interpolationExpression = token.content;\n                var placeholder;\n                while(code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1){\n                /* noop */ }\n                placeholderMap[placeholder] = interpolationExpression;\n                return placeholder;\n            }\n        }).join(\"\"); // 2. Tokenize the embedded code\n        var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language); // 3. Re-insert the interpolation\n        var placeholders = Object.keys(placeholderMap);\n        placeholderCounter = 0;\n        /**\n     *\n     * @param {(Token|string)[]} tokens\n     * @returns {void}\n     */ function walkTokens(tokens) {\n            for(var i = 0; i < tokens.length; i++){\n                if (placeholderCounter >= placeholders.length) {\n                    return;\n                }\n                var token = tokens[i];\n                if (typeof token === \"string\" || typeof token.content === \"string\") {\n                    var placeholder = placeholders[placeholderCounter];\n                    var s = typeof token === \"string\" ? token : /** @type {string} */ token.content;\n                    var index = s.indexOf(placeholder);\n                    if (index !== -1) {\n                        ++placeholderCounter;\n                        var before = s.substring(0, index);\n                        var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n                        var after = s.substring(index + placeholder.length);\n                        var replacement = [];\n                        if (before) {\n                            replacement.push(before);\n                        }\n                        replacement.push(middle);\n                        if (after) {\n                            var afterTokens = [\n                                after\n                            ];\n                            walkTokens(afterTokens);\n                            replacement.push.apply(replacement, afterTokens);\n                        }\n                        if (typeof token === \"string\") {\n                            tokens.splice.apply(tokens, [\n                                i,\n                                1\n                            ].concat(replacement));\n                            i += replacement.length - 1;\n                        } else {\n                            token.content = replacement;\n                        }\n                    }\n                } else {\n                    var content = token.content;\n                    if (Array.isArray(content)) {\n                        walkTokens(content);\n                    } else {\n                        walkTokens([\n                            content\n                        ]);\n                    }\n                }\n            }\n        }\n        walkTokens(embeddedTokens);\n        return new Prism.Token(language, embeddedTokens, \"language-\" + language, code);\n    }\n    /**\n   * The languages for which JS templating will handle tagged template literals.\n   *\n   * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n   */ var supportedLanguages = {\n        \"javascript\": true,\n        \"js\": true,\n        \"typescript\": true,\n        \"ts\": true,\n        \"jsx\": true,\n        \"tsx\": true\n    };\n    Prism.hooks.add(\"after-tokenize\", function(env) {\n        if (!(env.language in supportedLanguages)) {\n            return;\n        }\n        /**\n     * Finds and tokenizes all template strings with an embedded languages.\n     *\n     * @param {(Token | string)[]} tokens\n     * @returns {void}\n     */ function findTemplateStrings(tokens) {\n            for(var i = 0, l = tokens.length; i < l; i++){\n                var token = tokens[i];\n                if (typeof token === \"string\") {\n                    continue;\n                }\n                var content = token.content;\n                if (!Array.isArray(content)) {\n                    if (typeof content !== \"string\") {\n                        findTemplateStrings([\n                            content\n                        ]);\n                    }\n                    continue;\n                }\n                if (token.type === \"template-string\") {\n                    /**\n           * A JavaScript template-string token will look like this:\n           *\n           * [\"template-string\", [\n           *     [\"template-punctuation\", \"`\"],\n           *     (\n           *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n           *         or\n           *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n           *                                  It also has an alias which is the language of the embedded code.\n           *     ),\n           *     [\"template-punctuation\", \"`\"]\n           * ]]\n           */ var embedded = content[1];\n                    if (content.length === 3 && typeof embedded !== \"string\" && embedded.type === \"embedded-code\") {\n                        // get string content\n                        var code = stringContent(embedded);\n                        var alias = embedded.alias;\n                        var language = Array.isArray(alias) ? alias[0] : alias;\n                        var grammar = Prism.languages[language];\n                        if (!grammar) {\n                            continue;\n                        }\n                        content[1] = tokenizeEmbedded(code, grammar, language);\n                    }\n                } else {\n                    findTemplateStrings(content);\n                }\n            }\n        }\n        findTemplateStrings(env.tokens);\n    });\n    /**\n   * Returns the string content of a token or token stream.\n   *\n   * @param {string | Token | (string | Token)[]} value\n   * @returns {string}\n   */ function stringContent(value) {\n        if (typeof value === \"string\") {\n            return value;\n        } else if (Array.isArray(value)) {\n            return value.map(stringContent).join(\"\");\n        } else {\n            return stringContent(value.content);\n        }\n    }\n})(prism);\n/* \"prismjs/components/prism-typescript\" */ (function(Prism) {\n    Prism.languages.typescript = Prism.languages.extend(\"javascript\", {\n        \"class-name\": {\n            pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n            lookbehind: true,\n            greedy: true,\n            inside: null // see below\n        },\n        \"builtin\": /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/\n    }); // The keywords TypeScript adds to JavaScript\n    Prism.languages.typescript.keyword.push(/\\b(?:abstract|declare|is|keyof|readonly|require)\\b/, /\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/, /\\btype\\b(?=\\s*(?:[\\{*]|$))/); // doesn't work with TS because TS is too complex\n    delete Prism.languages.typescript[\"parameter\"];\n    delete Prism.languages.typescript[\"literal-property\"]; // a version of typescript specifically for highlighting types\n    var typeInside = Prism.languages.extend(\"typescript\", {});\n    delete typeInside[\"class-name\"];\n    Prism.languages.typescript[\"class-name\"].inside = typeInside;\n    Prism.languages.insertBefore(\"typescript\", \"function\", {\n        \"decorator\": {\n            pattern: /@[$\\w\\xA0-\\uFFFF]+/,\n            inside: {\n                \"at\": {\n                    pattern: /^@/,\n                    alias: \"operator\"\n                },\n                \"function\": /^[\\s\\S]+/\n            }\n        },\n        \"generic-function\": {\n            // e.g. foo<T extends \"bar\" | \"baz\">( ...\n            pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n            greedy: true,\n            inside: {\n                \"function\": /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n                \"generic\": {\n                    pattern: /<[\\s\\S]+/,\n                    // everything after the first <\n                    alias: \"class-name\",\n                    inside: typeInside\n                }\n            }\n        }\n    });\n    Prism.languages.ts = Prism.languages.typescript;\n})(prism);\n/* \"prismjs/components/prism-js-extras\" */ (function(Prism) {\n    Prism.languages.insertBefore(\"javascript\", \"function-variable\", {\n        \"method-variable\": {\n            pattern: RegExp(\"(\\\\.\\\\s*)\" + Prism.languages.javascript[\"function-variable\"].pattern.source),\n            lookbehind: true,\n            alias: [\n                \"function-variable\",\n                \"method\",\n                \"function\",\n                \"property-access\"\n            ]\n        }\n    });\n    Prism.languages.insertBefore(\"javascript\", \"function\", {\n        \"method\": {\n            pattern: RegExp(\"(\\\\.\\\\s*)\" + Prism.languages.javascript[\"function\"].source),\n            lookbehind: true,\n            alias: [\n                \"function\",\n                \"property-access\"\n            ]\n        }\n    });\n    Prism.languages.insertBefore(\"javascript\", \"constant\", {\n        \"known-class-name\": [\n            {\n                // standard built-ins\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n                pattern: /\\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\\b/,\n                alias: \"class-name\"\n            },\n            {\n                // errors\n                pattern: /\\b(?:[A-Z]\\w*)Error\\b/,\n                alias: \"class-name\"\n            }\n        ]\n    });\n    /**\n   * Replaces the `<ID>` placeholder in the given pattern with a pattern for general JS identifiers.\n   *\n   * @param {string} source\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */ function withId(source, flags) {\n        return RegExp(source.replace(/<ID>/g, function() {\n            return /(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/.source;\n        }), flags);\n    }\n    Prism.languages.insertBefore(\"javascript\", \"keyword\", {\n        \"imports\": {\n            // https://tc39.es/ecma262/#sec-imports\n            pattern: withId(/(\\bimport\\b\\s*)(?:<ID>(?:\\s*,\\s*(?:\\*\\s*as\\s+<ID>|\\{[^{}]*\\}))?|\\*\\s*as\\s+<ID>|\\{[^{}]*\\})(?=\\s*\\bfrom\\b)/.source),\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        \"exports\": {\n            // https://tc39.es/ecma262/#sec-exports\n            pattern: withId(/(\\bexport\\b\\s*)(?:\\*(?:\\s*as\\s+<ID>)?(?=\\s*\\bfrom\\b)|\\{[^{}]*\\})/.source),\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        }\n    });\n    Prism.languages.javascript[\"keyword\"].unshift({\n        pattern: /\\b(?:as|default|export|from|import)\\b/,\n        alias: \"module\"\n    }, {\n        pattern: /\\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\\b/,\n        alias: \"control-flow\"\n    }, {\n        pattern: /\\bnull\\b/,\n        alias: [\n            \"null\",\n            \"nil\"\n        ]\n    }, {\n        pattern: /\\bundefined\\b/,\n        alias: \"nil\"\n    });\n    Prism.languages.insertBefore(\"javascript\", \"operator\", {\n        \"spread\": {\n            pattern: /\\.{3}/,\n            alias: \"operator\"\n        },\n        \"arrow\": {\n            pattern: /=>/,\n            alias: \"operator\"\n        }\n    });\n    Prism.languages.insertBefore(\"javascript\", \"punctuation\", {\n        \"property-access\": {\n            pattern: withId(/(\\.\\s*)#?<ID>/.source),\n            lookbehind: true\n        },\n        \"maybe-class-name\": {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])[A-Z][$\\w\\xA0-\\uFFFF]+/,\n            lookbehind: true\n        },\n        \"dom\": {\n            // this contains only a few commonly used DOM variables\n            pattern: /\\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\\b/,\n            alias: \"variable\"\n        },\n        \"console\": {\n            pattern: /\\bconsole(?=\\s*\\.)/,\n            alias: \"class-name\"\n        }\n    }); // add 'maybe-class-name' to tokens which might be a class name\n    var maybeClassNameTokens = [\n        \"function\",\n        \"function-variable\",\n        \"method\",\n        \"method-variable\",\n        \"property-access\"\n    ];\n    for(var i = 0; i < maybeClassNameTokens.length; i++){\n        var token = maybeClassNameTokens[i];\n        var value = Prism.languages.javascript[token]; // convert regex to object\n        if (Prism.util.type(value) === \"RegExp\") {\n            value = Prism.languages.javascript[token] = {\n                pattern: value\n            };\n        } // keep in mind that we don't support arrays\n        var inside = value.inside || {};\n        value.inside = inside;\n        inside[\"maybe-class-name\"] = /^[A-Z][\\s\\S]*/;\n    }\n})(prism);\n/* \"prismjs/components/prism-jsx\" */ (function(Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript);\n    var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\n    var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\n    var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\n    /**\n   * @param {string} source\n   * @param {string} [flags]\n   */ function re(source, flags) {\n        source = source.replace(/<S>/g, function() {\n            return space;\n        }).replace(/<BRACES>/g, function() {\n            return braces;\n        }).replace(/<SPREAD>/g, function() {\n            return spread;\n        });\n        return RegExp(source, flags);\n    }\n    spread = re(spread).source;\n    Prism.languages.jsx = Prism.languages.extend(\"markup\", javascript);\n    Prism.languages.jsx.tag.pattern = re(/<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/.source);\n    Prism.languages.jsx.tag.inside[\"tag\"].pattern = /^<\\/?[^\\s>\\/]*/;\n    Prism.languages.jsx.tag.inside[\"attr-value\"].pattern = /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/;\n    Prism.languages.jsx.tag.inside[\"tag\"].inside[\"class-name\"] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n    Prism.languages.jsx.tag.inside[\"comment\"] = javascript[\"comment\"];\n    Prism.languages.insertBefore(\"inside\", \"attr-name\", {\n        \"spread\": {\n            pattern: re(/<SPREAD>/.source),\n            inside: Prism.languages.jsx\n        }\n    }, Prism.languages.jsx.tag);\n    Prism.languages.insertBefore(\"inside\", \"special-attr\", {\n        \"script\": {\n            // Allow for two levels of nesting\n            pattern: re(/=<BRACES>/.source),\n            alias: \"language-javascript\",\n            inside: {\n                \"script-punctuation\": {\n                    pattern: /^=(?=\\{)/,\n                    alias: \"punctuation\"\n                },\n                rest: Prism.languages.jsx\n            }\n        }\n    }, Prism.languages.jsx.tag); // The following will handle plain text inside tags\n    var stringifyToken = function(token) {\n        if (!token) {\n            return \"\";\n        }\n        if (typeof token === \"string\") {\n            return token;\n        }\n        if (typeof token.content === \"string\") {\n            return token.content;\n        }\n        return token.content.map(stringifyToken).join(\"\");\n    };\n    var walkTokens = function(tokens) {\n        var openedTags = [];\n        for(var i = 0; i < tokens.length; i++){\n            var token = tokens[i];\n            var notTagNorBrace = false;\n            if (typeof token !== \"string\") {\n                if (token.type === \"tag\" && token.content[0] && token.content[0].type === \"tag\") {\n                    // We found a tag, now find its kind\n                    if (token.content[0].content[0].content === \"</\") {\n                        // Closing tag\n                        if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n                            // Pop matching opening tag\n                            openedTags.pop();\n                        }\n                    } else {\n                        if (token.content[token.content.length - 1].content === \"/>\") ;\n                        else {\n                            // Opening tag\n                            openedTags.push({\n                                tagName: stringifyToken(token.content[0].content[1]),\n                                openedBraces: 0\n                            });\n                        }\n                    }\n                } else if (openedTags.length > 0 && token.type === \"punctuation\" && token.content === \"{\") {\n                    // Here we might have entered a JSX context inside a tag\n                    openedTags[openedTags.length - 1].openedBraces++;\n                } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === \"punctuation\" && token.content === \"}\") {\n                    // Here we might have left a JSX context inside a tag\n                    openedTags[openedTags.length - 1].openedBraces--;\n                } else {\n                    notTagNorBrace = true;\n                }\n            }\n            if (notTagNorBrace || typeof token === \"string\") {\n                if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n                    // Here we are inside a tag, and not inside a JSX context.\n                    // That's plain text: drop any tokens matched.\n                    var plainText = stringifyToken(token); // And merge text with adjacent text\n                    if (i < tokens.length - 1 && (typeof tokens[i + 1] === \"string\" || tokens[i + 1].type === \"plain-text\")) {\n                        plainText += stringifyToken(tokens[i + 1]);\n                        tokens.splice(i + 1, 1);\n                    }\n                    if (i > 0 && (typeof tokens[i - 1] === \"string\" || tokens[i - 1].type === \"plain-text\")) {\n                        plainText = stringifyToken(tokens[i - 1]) + plainText;\n                        tokens.splice(i - 1, 1);\n                        i--;\n                    }\n                    tokens[i] = new Prism.Token(\"plain-text\", plainText, null, plainText);\n                }\n            }\n            if (token.content && typeof token.content !== \"string\") {\n                walkTokens(token.content);\n            }\n        }\n    };\n    Prism.hooks.add(\"after-tokenize\", function(env) {\n        if (env.language !== \"jsx\" && env.language !== \"tsx\") {\n            return;\n        }\n        walkTokens(env.tokens);\n    });\n})(prism);\n/* \"prismjs/components/prism-diff\" */ (function(Prism) {\n    Prism.languages.diff = {\n        \"coord\": [\n            /^(?:\\*{3}|-{3}|\\+{3}).*$/m,\n            /^@@.*@@$/m,\n            /^\\d.*$/m\n        ] // deleted, inserted, unchanged, diff\n    };\n    /**\n   * A map from the name of a block to its line prefix.\n   *\n   * @type {Object<string, string>}\n   */ var PREFIXES = {\n        \"deleted-sign\": \"-\",\n        \"deleted-arrow\": \"<\",\n        \"inserted-sign\": \"+\",\n        \"inserted-arrow\": \">\",\n        \"unchanged\": \" \",\n        \"diff\": \"!\"\n    }; // add a token for each prefix\n    Object.keys(PREFIXES).forEach(function(name) {\n        var prefix = PREFIXES[name];\n        var alias = [];\n        if (!/^\\w+$/.test(name)) {\n            // \"deleted-sign\" -> \"deleted\"\n            alias.push(/\\w+/.exec(name)[0]);\n        }\n        if (name === \"diff\") {\n            alias.push(\"bold\");\n        }\n        Prism.languages.diff[name] = {\n            pattern: RegExp(\"^(?:[\" + prefix + \"].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+\", \"m\"),\n            alias: alias,\n            inside: {\n                \"line\": {\n                    pattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n                    lookbehind: true\n                },\n                \"prefix\": {\n                    pattern: /[\\s\\S]/,\n                    alias: /\\w+/.exec(name)[0]\n                }\n            }\n        };\n    }); // make prefixes available to Diff plugin\n    Object.defineProperty(Prism.languages.diff, \"PREFIXES\", {\n        value: PREFIXES\n    });\n})(prism);\n/* \"prismjs/components/prism-git\" */ prism.languages.git = {\n    /*\n   * A simple one line comment like in a git status command\n   * For instance:\n   * $ git status\n   * # On branch infinite-scroll\n   * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,\n   * # and have 1 and 2 different commits each, respectively.\n   * nothing to commit (working directory clean)\n   */ \"comment\": /^#.*/m,\n    /*\n   * Regexp to match the changed lines in a git diff output. Check the example below.\n   */ \"deleted\": /^[-].*/m,\n    \"inserted\": /^\\+.*/m,\n    /*\n   * a string (double and simple quote)\n   */ \"string\": /(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    /*\n   * a git command. It starts with a random prompt finishing by a $, then \"git\" then some other parameters\n   * For instance:\n   * $ git add file.txt\n   */ \"command\": {\n        pattern: /^.*\\$ git .*$/m,\n        inside: {\n            /*\n       * A git command can contain a parameter starting by a single or a double dash followed by a string\n       * For instance:\n       * $ git diff --cached\n       * $ git log -p\n       */ \"parameter\": /\\s--?\\w+/\n        }\n    },\n    /*\n   * Coordinates displayed in a git diff command\n   * For instance:\n   * $ git diff\n   * diff --git file.txt file.txt\n   * index 6214953..1d54a52 100644\n   * --- file.txt\n   * +++ file.txt\n   * @@ -1 +1,2 @@\n   * -Here's my tetx file\n   * +Here's my text file\n   * +And this is the second line\n   */ \"coord\": /^@@.*@@$/m,\n    /*\n   * Match a \"commit [SHA1]\" line in a git log output.\n   * For instance:\n   * $ git log\n   * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09\n   * Author: lgiraudel\n   * Date:   Mon Feb 17 11:18:34 2014 +0100\n   *\n   *     Add of a new line\n   */ \"commit-sha1\": /^commit \\w{40}$/m\n};\n/* \"prismjs/components/prism-go\" */ prism.languages.go = prism.languages.extend(\"clike\", {\n    \"string\": {\n        pattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"|`[^`]*`/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"keyword\": /\\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\\b/,\n    \"boolean\": /\\b(?:_|false|iota|nil|true)\\b/,\n    \"number\": [\n        /\\b0(?:b[01_]+|o[0-7_]+)i?\\b/i,\n        /\\b0x(?:[a-f\\d_]+(?:\\.[a-f\\d_]*)?|\\.[a-f\\d_]+)(?:p[+-]?\\d+(?:_\\d+)*)?i?(?!\\w)/i,\n        /(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?[\\d_]+)?i?(?!\\w)/i\n    ],\n    \"operator\": /[*\\/%^!=]=?|\\+[=+]?|-[=-]?|\\|[=|]?|&(?:=|&|\\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\\.\\.\\./,\n    \"builtin\": /\\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\\b/\n});\nprism.languages.insertBefore(\"go\", \"string\", {\n    \"char\": {\n        pattern: /'(?:\\\\.|[^'\\\\\\r\\n]){0,10}'/,\n        greedy: true\n    }\n});\ndelete prism.languages.go[\"class-name\"];\n/* \"prismjs/components/prism-markup-templating\" */ (function(Prism) {\n    /**\n   * Returns the placeholder for the given language id and index.\n   *\n   * @param {string} language\n   * @param {string|number} index\n   * @returns {string}\n   */ function getPlaceholder(language, index) {\n        return \"___\" + language.toUpperCase() + index + \"___\";\n    }\n    Object.defineProperties(Prism.languages[\"markup-templating\"] = {}, {\n        buildPlaceholders: {\n            /**\n       * Tokenize all inline templating expressions matching `placeholderPattern`.\n       *\n       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n       * `true` will be replaced.\n       *\n       * @param {object} env The environment of the `before-tokenize` hook.\n       * @param {string} language The language id.\n       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n       * @param {(match: string) => boolean} [replaceFilter]\n       */ value: function(env, language, placeholderPattern, replaceFilter) {\n                if (env.language !== language) {\n                    return;\n                }\n                var tokenStack = env.tokenStack = [];\n                env.code = env.code.replace(placeholderPattern, function(match) {\n                    if (typeof replaceFilter === \"function\" && !replaceFilter(match)) {\n                        return match;\n                    }\n                    var i = tokenStack.length;\n                    var placeholder; // Check for existing strings\n                    while(env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1){\n                        ++i;\n                    } // Create a sparse array\n                    tokenStack[i] = match;\n                    return placeholder;\n                }); // Switch the grammar to markup\n                env.grammar = Prism.languages.markup;\n            }\n        },\n        tokenizePlaceholders: {\n            /**\n       * Replace placeholders with proper tokens after tokenizing.\n       *\n       * @param {object} env The environment of the `after-tokenize` hook.\n       * @param {string} language The language id.\n       */ value: function(env, language) {\n                if (env.language !== language || !env.tokenStack) {\n                    return;\n                } // Switch the grammar back\n                env.grammar = Prism.languages[language];\n                var j = 0;\n                var keys = Object.keys(env.tokenStack);\n                function walkTokens(tokens) {\n                    for(var i = 0; i < tokens.length; i++){\n                        // all placeholders are replaced already\n                        if (j >= keys.length) {\n                            break;\n                        }\n                        var token = tokens[i];\n                        if (typeof token === \"string\" || token.content && typeof token.content === \"string\") {\n                            var k = keys[j];\n                            var t = env.tokenStack[k];\n                            var s = typeof token === \"string\" ? token : token.content;\n                            var placeholder = getPlaceholder(language, k);\n                            var index = s.indexOf(placeholder);\n                            if (index > -1) {\n                                ++j;\n                                var before = s.substring(0, index);\n                                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), \"language-\" + language, t);\n                                var after = s.substring(index + placeholder.length);\n                                var replacement = [];\n                                if (before) {\n                                    replacement.push.apply(replacement, walkTokens([\n                                        before\n                                    ]));\n                                }\n                                replacement.push(middle);\n                                if (after) {\n                                    replacement.push.apply(replacement, walkTokens([\n                                        after\n                                    ]));\n                                }\n                                if (typeof token === \"string\") {\n                                    tokens.splice.apply(tokens, [\n                                        i,\n                                        1\n                                    ].concat(replacement));\n                                } else {\n                                    token.content = replacement;\n                                }\n                            }\n                        } else if (token.content) {\n                            walkTokens(token.content);\n                        }\n                    }\n                    return tokens;\n                }\n                walkTokens(env.tokens);\n            }\n        }\n    });\n})(prism);\n/* \"prismjs/components/prism-handlebars\" */ (function(Prism) {\n    Prism.languages.handlebars = {\n        \"comment\": /\\{\\{![\\s\\S]*?\\}\\}/,\n        \"delimiter\": {\n            pattern: /^\\{\\{\\{?|\\}\\}\\}?$/,\n            alias: \"punctuation\"\n        },\n        \"string\": /([\"'])(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        \"number\": /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee][+-]?\\d+)?/,\n        \"boolean\": /\\b(?:false|true)\\b/,\n        \"block\": {\n            pattern: /^(\\s*(?:~\\s*)?)[#\\/]\\S+?(?=\\s*(?:~\\s*)?$|\\s)/,\n            lookbehind: true,\n            alias: \"keyword\"\n        },\n        \"brackets\": {\n            pattern: /\\[[^\\]]+\\]/,\n            inside: {\n                punctuation: /\\[|\\]/,\n                variable: /[\\s\\S]+/\n            }\n        },\n        \"punctuation\": /[!\"#%&':()*+,.\\/;<=>@\\[\\\\\\]^`{|}~]/,\n        \"variable\": /[^!\"#%&'()*+,\\/;<=>@\\[\\\\\\]^`{|}~\\s]+/\n    };\n    Prism.hooks.add(\"before-tokenize\", function(env) {\n        var handlebarsPattern = /\\{\\{\\{[\\s\\S]+?\\}\\}\\}|\\{\\{[\\s\\S]+?\\}\\}/g;\n        Prism.languages[\"markup-templating\"].buildPlaceholders(env, \"handlebars\", handlebarsPattern);\n    });\n    Prism.hooks.add(\"after-tokenize\", function(env) {\n        Prism.languages[\"markup-templating\"].tokenizePlaceholders(env, \"handlebars\");\n    });\n    Prism.languages.hbs = Prism.languages.handlebars;\n})(prism);\n/* \"prismjs/components/prism-json\" */ // https://www.json.org/json-en.html\nprism.languages.json = {\n    \"property\": {\n        pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"string\": {\n        pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?!\\s*:)/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"comment\": {\n        pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n        greedy: true\n    },\n    \"number\": /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n    \"punctuation\": /[{}[\\],]/,\n    \"operator\": /:/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"null\": {\n        pattern: /\\bnull\\b/,\n        alias: \"keyword\"\n    }\n};\nprism.languages.webmanifest = prism.languages.json;\n/* \"prismjs/components/prism-less\" */ /* FIXME :\n :extend() is not handled specifically : its highlighting is buggy.\n Mixin usage must be inside a ruleset to be highlighted.\n At-rules (e.g. import) containing interpolations are buggy.\n Detached rulesets are highlighted as at-rules.\n A comment before a mixin usage prevents the latter to be properly highlighted.\n */ prism.languages.less = prism.languages.extend(\"css\", {\n    \"comment\": [\n        /\\/\\*[\\s\\S]*?\\*\\//,\n        {\n            pattern: /(^|[^\\\\])\\/\\/.*/,\n            lookbehind: true\n        }\n    ],\n    \"atrule\": {\n        pattern: /@[\\w-](?:\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n        inside: {\n            \"punctuation\": /[:()]/\n        }\n    },\n    // selectors and mixins are considered the same\n    \"selector\": {\n        pattern: /(?:@\\{[\\w-]+\\}|[^{};\\s@])(?:@\\{[\\w-]+\\}|\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};@\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n        inside: {\n            // mixin parameters\n            \"variable\": /@+[\\w-]+/\n        }\n    },\n    \"property\": /(?:@\\{[\\w-]+\\}|[\\w-])+(?:\\+_?)?(?=\\s*:)/,\n    \"operator\": /[+\\-*\\/]/\n});\nprism.languages.insertBefore(\"less\", \"property\", {\n    \"variable\": [\n        {\n            pattern: /@[\\w-]+\\s*:/,\n            inside: {\n                \"punctuation\": /:/\n            }\n        },\n        /@@?[\\w-]+/\n    ],\n    \"mixin-usage\": {\n        pattern: /([{;]\\s*)[.#](?!\\d)[\\w-].*?(?=[(;])/,\n        lookbehind: true,\n        alias: \"function\"\n    }\n});\n/* \"prismjs/components/prism-makefile\" */ prism.languages.makefile = {\n    \"comment\": {\n        pattern: /(^|[^\\\\])#(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n])*/,\n        lookbehind: true\n    },\n    \"string\": {\n        pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n    },\n    \"builtin-target\": {\n        pattern: /\\.[A-Z][^:#=\\s]+(?=\\s*:(?!=))/,\n        alias: \"builtin\"\n    },\n    \"target\": {\n        pattern: /^(?:[^:=\\s]|[ \\t]+(?![\\s:]))+(?=\\s*:(?!=))/m,\n        alias: \"symbol\",\n        inside: {\n            \"variable\": /\\$+(?:(?!\\$)[^(){}:#=\\s]+|(?=[({]))/\n        }\n    },\n    \"variable\": /\\$+(?:(?!\\$)[^(){}:#=\\s]+|\\([@*%<^+?][DF]\\)|(?=[({]))/,\n    // Directives\n    \"keyword\": /-include\\b|\\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\\b/,\n    \"function\": {\n        pattern: /(\\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \\t])/,\n        lookbehind: true\n    },\n    \"operator\": /(?:::|[?:+!])?=|[|@]/,\n    \"punctuation\": /[:;(){}]/\n};\n/* \"prismjs/components/prism-objectivec\" */ prism.languages.objectivec = prism.languages.extend(\"c\", {\n    \"string\": {\n        pattern: /@?\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n        greedy: true\n    },\n    \"keyword\": /\\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n    \"operator\": /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n});\ndelete prism.languages.objectivec[\"class-name\"];\nprism.languages.objc = prism.languages.objectivec;\n/* \"prismjs/components/prism-ocaml\" */ // https://ocaml.org/manual/lex.html\nprism.languages.ocaml = {\n    \"comment\": {\n        pattern: /\\(\\*[\\s\\S]*?\\*\\)/,\n        greedy: true\n    },\n    \"char\": {\n        pattern: /'(?:[^\\\\\\r\\n']|\\\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,\n        greedy: true\n    },\n    \"string\": [\n        {\n            pattern: /\"(?:\\\\(?:[\\s\\S]|\\r\\n)|[^\\\\\\r\\n\"])*\"/,\n            greedy: true\n        },\n        {\n            pattern: /\\{([a-z_]*)\\|[\\s\\S]*?\\|\\1\\}/,\n            greedy: true\n        }\n    ],\n    \"number\": [\n        /\\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\\b/i,\n        /\\b0x[a-f0-9][a-f0-9_]*(?:\\.[a-f0-9_]*)?(?:p[+-]?\\d[\\d_]*)?(?!\\w)/i,\n        /\\b\\d[\\d_]*(?:\\.[\\d_]*)?(?:e[+-]?\\d[\\d_]*)?(?!\\w)/i\n    ],\n    \"directive\": {\n        pattern: /\\B#\\w+/,\n        alias: \"property\"\n    },\n    \"label\": {\n        pattern: /\\B~\\w+/,\n        alias: \"property\"\n    },\n    \"type-variable\": {\n        pattern: /\\B'\\w+/,\n        alias: \"function\"\n    },\n    \"variant\": {\n        pattern: /`\\w+/,\n        alias: \"symbol\"\n    },\n    // For the list of keywords and operators,\n    // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84\n    \"keyword\": /\\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\\b/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"operator-like-punctuation\": {\n        pattern: /\\[[<>|]|[>|]\\]|\\{<|>\\}/,\n        alias: \"punctuation\"\n    },\n    // Custom operators are allowed\n    \"operator\": /\\.[.~]|:[=>]|[=<>@^|&+\\-*\\/$%!?~][!$%&*+\\-.\\/:<=>?@^|~]*|\\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\\b/,\n    \"punctuation\": /;;|::|[(){}\\[\\].,:;#]|\\b_\\b/\n};\n/* \"prismjs/components/prism-python\" */ prism.languages.python = {\n    \"comment\": {\n        pattern: /(^|[^\\\\])#.*/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"string-interpolation\": {\n        pattern: /(?:f|fr|rf)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n        greedy: true,\n        inside: {\n            \"interpolation\": {\n                // \"{\" <expression> <optional \"!s\", \"!r\", or \"!a\"> <optional \":\" format specifier> \"}\"\n                pattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n                lookbehind: true,\n                inside: {\n                    \"format-spec\": {\n                        pattern: /(:)[^:(){}]+(?=\\}$)/,\n                        lookbehind: true\n                    },\n                    \"conversion-option\": {\n                        pattern: /![sra](?=[:}]$)/,\n                        alias: \"punctuation\"\n                    },\n                    rest: null\n                }\n            },\n            \"string\": /[\\s\\S]+/\n        }\n    },\n    \"triple-quoted-string\": {\n        pattern: /(?:[rub]|br|rb)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n        greedy: true,\n        alias: \"string\"\n    },\n    \"string\": {\n        pattern: /(?:[rub]|br|rb)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n        greedy: true\n    },\n    \"function\": {\n        pattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n        lookbehind: true\n    },\n    \"class-name\": {\n        pattern: /(\\bclass\\s+)\\w+/i,\n        lookbehind: true\n    },\n    \"decorator\": {\n        pattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,\n        lookbehind: true,\n        alias: [\n            \"annotation\",\n            \"punctuation\"\n        ],\n        inside: {\n            \"punctuation\": /\\./\n        }\n    },\n    \"keyword\": /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n    \"builtin\": /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n    \"boolean\": /\\b(?:False|None|True)\\b/,\n    \"number\": /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,\n    \"operator\": /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n    \"punctuation\": /[{}[\\];(),.:]/\n};\nprism.languages.python[\"string-interpolation\"].inside[\"interpolation\"].inside.rest = prism.languages.python;\nprism.languages.py = prism.languages.python;\n/* \"prismjs/components/prism-reason\" */ prism.languages.reason = prism.languages.extend(\"clike\", {\n    \"string\": {\n        pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n\"])*\"/,\n        greedy: true\n    },\n    // 'class-name' must be matched *after* 'constructor' defined below\n    \"class-name\": /\\b[A-Z]\\w*/,\n    \"keyword\": /\\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\\b/,\n    \"operator\": /\\.{3}|:[:=]|\\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\\-*\\/]\\.?|\\b(?:asr|land|lor|lsl|lsr|lxor|mod)\\b/\n});\nprism.languages.insertBefore(\"reason\", \"class-name\", {\n    \"char\": {\n        pattern: /'(?:\\\\x[\\da-f]{2}|\\\\o[0-3][0-7][0-7]|\\\\\\d{3}|\\\\.|[^'\\\\\\r\\n])'/,\n        greedy: true\n    },\n    // Negative look-ahead prevents from matching things like String.capitalize\n    \"constructor\": /\\b[A-Z]\\w*\\b(?!\\s*\\.)/,\n    \"label\": {\n        pattern: /\\b[a-z]\\w*(?=::)/,\n        alias: \"symbol\"\n    }\n}); // We can't match functions property, so let's not even try.\ndelete prism.languages.reason.function;\n/* \"prismjs/components/prism-sass\" */ (function(Prism) {\n    Prism.languages.sass = Prism.languages.extend(\"css\", {\n        // Sass comments don't need to be closed, only indented\n        \"comment\": {\n            pattern: /^([ \\t]*)\\/[\\/*].*(?:(?:\\r?\\n|\\r)\\1[ \\t].+)*/m,\n            lookbehind: true,\n            greedy: true\n        }\n    });\n    Prism.languages.insertBefore(\"sass\", \"atrule\", {\n        // We want to consume the whole line\n        \"atrule-line\": {\n            // Includes support for = and + shortcuts\n            pattern: /^(?:[ \\t]*)[@+=].+/m,\n            greedy: true,\n            inside: {\n                \"atrule\": /(?:@[\\w-]+|[+=])/\n            }\n        }\n    });\n    delete Prism.languages.sass.atrule;\n    var variable = /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/;\n    var operator = [\n        /[+*\\/%]|[=!]=|<=?|>=?|\\b(?:and|not|or)\\b/,\n        {\n            pattern: /(\\s)-(?=\\s)/,\n            lookbehind: true\n        }\n    ];\n    Prism.languages.insertBefore(\"sass\", \"property\", {\n        // We want to consume the whole line\n        \"variable-line\": {\n            pattern: /^[ \\t]*\\$.+/m,\n            greedy: true,\n            inside: {\n                \"punctuation\": /:/,\n                \"variable\": variable,\n                \"operator\": operator\n            }\n        },\n        // We want to consume the whole line\n        \"property-line\": {\n            pattern: /^[ \\t]*(?:[^:\\s]+ *:.*|:[^:\\s].*)/m,\n            greedy: true,\n            inside: {\n                \"property\": [\n                    /[^:\\s]+(?=\\s*:)/,\n                    {\n                        pattern: /(:)[^:\\s]+/,\n                        lookbehind: true\n                    }\n                ],\n                \"punctuation\": /:/,\n                \"variable\": variable,\n                \"operator\": operator,\n                \"important\": Prism.languages.sass.important\n            }\n        }\n    });\n    delete Prism.languages.sass.property;\n    delete Prism.languages.sass.important; // Now that whole lines for other patterns are consumed,\n    // what's left should be selectors\n    Prism.languages.insertBefore(\"sass\", \"punctuation\", {\n        \"selector\": {\n            pattern: /^([ \\t]*)\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*(?:,(?:\\r?\\n|\\r)\\1[ \\t]+\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*)*/m,\n            lookbehind: true,\n            greedy: true\n        }\n    });\n})(prism);\n/* \"prismjs/components/prism-scss\" */ prism.languages.scss = prism.languages.extend(\"css\", {\n    \"comment\": {\n        pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n        lookbehind: true\n    },\n    \"atrule\": {\n        pattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\n        inside: {\n            \"rule\": /@[\\w-]+/ // See rest below\n        }\n    },\n    // url, compassified\n    \"url\": /(?:[-a-z]+-)?url(?=\\()/i,\n    // CSS selector regex is not appropriate for Sass\n    // since there can be lot more things (var, @ directive, nesting..)\n    // a selector must start at the end of a property or after a brace (end of other rules or nesting)\n    // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n    // the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n    // can \"pass\" as a selector- e.g: proper#{$erty})\n    // this one was hard to do, so please be careful if you edit this one :)\n    \"selector\": {\n        // Initial look-ahead is used to prevent matching of blank selectors\n        pattern: /(?=\\S)[^@;{}()]?(?:[^@;{}()\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/,\n        inside: {\n            \"parent\": {\n                pattern: /&/,\n                alias: \"important\"\n            },\n            \"placeholder\": /%[-\\w]+/,\n            \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n        }\n    },\n    \"property\": {\n        pattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\n        inside: {\n            \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n        }\n    }\n});\nprism.languages.insertBefore(\"scss\", \"atrule\", {\n    \"keyword\": [\n        /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\\b/i,\n        {\n            pattern: /( )(?:from|through)(?= )/,\n            lookbehind: true\n        }\n    ]\n});\nprism.languages.insertBefore(\"scss\", \"important\", {\n    // var and interpolated vars\n    \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n});\nprism.languages.insertBefore(\"scss\", \"function\", {\n    \"module-modifier\": {\n        pattern: /\\b(?:as|hide|show|with)\\b/i,\n        alias: \"keyword\"\n    },\n    \"placeholder\": {\n        pattern: /%[-\\w]+/,\n        alias: \"selector\"\n    },\n    \"statement\": {\n        pattern: /\\B!(?:default|optional)\\b/i,\n        alias: \"keyword\"\n    },\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"null\": {\n        pattern: /\\bnull\\b/,\n        alias: \"keyword\"\n    },\n    \"operator\": {\n        pattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|not|or)(?=\\s)/,\n        lookbehind: true\n    }\n});\nprism.languages.scss[\"atrule\"].inside.rest = prism.languages.scss;\n/* \"prismjs/components/prism-stylus\" */ (function(Prism) {\n    var unit = {\n        pattern: /(\\b\\d+)(?:%|[a-z]+)/,\n        lookbehind: true\n    }; // 123 -123 .123 -.123 12.3 -12.3\n    var number = {\n        pattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n        lookbehind: true\n    };\n    var inside = {\n        \"comment\": {\n            pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n            lookbehind: true\n        },\n        \"url\": {\n            pattern: /\\burl\\(([\"']?).*?\\1\\)/i,\n            greedy: true\n        },\n        \"string\": {\n            pattern: /(\"|')(?:(?!\\1)[^\\\\\\r\\n]|\\\\(?:\\r\\n|[\\s\\S]))*\\1/,\n            greedy: true\n        },\n        \"interpolation\": null,\n        // See below\n        \"func\": null,\n        // See below\n        \"important\": /\\B!(?:important|optional)\\b/i,\n        \"keyword\": {\n            pattern: /(^|\\s+)(?:(?:else|for|if|return|unless)(?=\\s|$)|@[\\w-]+)/,\n            lookbehind: true\n        },\n        \"hexcode\": /#[\\da-f]{3,6}/i,\n        \"color\": [\n            /\\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\\b/i,\n            {\n                pattern: /\\b(?:hsl|rgb)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:hsl|rgb)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n                inside: {\n                    \"unit\": unit,\n                    \"number\": number,\n                    \"function\": /[\\w-]+(?=\\()/,\n                    \"punctuation\": /[(),]/\n                }\n            }\n        ],\n        \"entity\": /\\\\[\\da-f]{1,8}/i,\n        \"unit\": unit,\n        \"boolean\": /\\b(?:false|true)\\b/,\n        \"operator\": [\n            // accepted in property names.\n            /~|[+!\\/%<>?=]=?|[-:]=|\\*[*=]?|\\.{2,3}|&&|\\|\\||\\B-\\B|\\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\\b/\n        ],\n        \"number\": number,\n        \"punctuation\": /[{}()\\[\\];:,]/\n    };\n    inside[\"interpolation\"] = {\n        pattern: /\\{[^\\r\\n}:]+\\}/,\n        alias: \"variable\",\n        inside: {\n            \"delimiter\": {\n                pattern: /^\\{|\\}$/,\n                alias: \"punctuation\"\n            },\n            rest: inside\n        }\n    };\n    inside[\"func\"] = {\n        pattern: /[\\w-]+\\([^)]*\\).*/,\n        inside: {\n            \"function\": /^[^(]+/,\n            rest: inside\n        }\n    };\n    Prism.languages.stylus = {\n        \"atrule-declaration\": {\n            pattern: /(^[ \\t]*)@.+/m,\n            lookbehind: true,\n            inside: {\n                \"atrule\": /^@[\\w-]+/,\n                rest: inside\n            }\n        },\n        \"variable-declaration\": {\n            pattern: /(^[ \\t]*)[\\w$-]+\\s*.?=[ \\t]*(?:\\{[^{}]*\\}|\\S.*|$)/m,\n            lookbehind: true,\n            inside: {\n                \"variable\": /^\\S+/,\n                rest: inside\n            }\n        },\n        \"statement\": {\n            pattern: /(^[ \\t]*)(?:else|for|if|return|unless)[ \\t].+/m,\n            lookbehind: true,\n            inside: {\n                \"keyword\": /^\\S+/,\n                rest: inside\n            }\n        },\n        // A property/value pair cannot end with a comma or a brace\n        // It cannot have indented content unless it ended with a semicolon\n        \"property-declaration\": {\n            pattern: /((?:^|\\{)([ \\t]*))(?:[\\w-]|\\{[^}\\r\\n]+\\})+(?:\\s*:\\s*|[ \\t]+)(?!\\s)[^{\\r\\n]*(?:;|[^{\\r\\n,]$(?!(?:\\r?\\n|\\r)(?:\\{|\\2[ \\t])))/m,\n            lookbehind: true,\n            inside: {\n                \"property\": {\n                    pattern: /^[^\\s:]+/,\n                    inside: {\n                        \"interpolation\": inside.interpolation\n                    }\n                },\n                rest: inside\n            }\n        },\n        // A selector can contain parentheses only as part of a pseudo-element\n        // It can span multiple lines.\n        // It must end with a comma or an accolade or have indented content.\n        \"selector\": {\n            pattern: /(^[ \\t]*)(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\)|(?![\\w-]))|\\{[^}\\r\\n]+\\})+)(?:(?:\\r?\\n|\\r)(?:\\1(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\)|(?![\\w-]))|\\{[^}\\r\\n]+\\})+)))*(?:,$|\\{|(?=(?:\\r?\\n|\\r)(?:\\{|\\1[ \\t])))/m,\n            lookbehind: true,\n            inside: {\n                \"interpolation\": inside.interpolation,\n                \"comment\": inside.comment,\n                \"punctuation\": /[{},]/\n            }\n        },\n        \"func\": inside.func,\n        \"string\": inside.string,\n        \"comment\": {\n            pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n            lookbehind: true,\n            greedy: true\n        },\n        \"interpolation\": inside.interpolation,\n        \"punctuation\": /[{}()\\[\\];:.]/\n    };\n})(prism);\n/* \"prismjs/components/prism-tsx\" */ (function(Prism) {\n    var typescript = Prism.util.clone(Prism.languages.typescript);\n    Prism.languages.tsx = Prism.languages.extend(\"jsx\", typescript); // doesn't work with TS because TS is too complex\n    delete Prism.languages.tsx[\"parameter\"];\n    delete Prism.languages.tsx[\"literal-property\"]; // This will prevent collisions between TSX tags and TS generic types.\n    // Idea by https://github.com/karlhorky\n    // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\n    var tag = Prism.languages.tsx.tag;\n    tag.pattern = RegExp(/(^|[^\\w$]|(?=<\\/))/.source + \"(?:\" + tag.pattern.source + \")\", tag.pattern.flags);\n    tag.lookbehind = true;\n})(prism);\n/* \"prismjs/components/prism-wasm\" */ prism.languages.wasm = {\n    \"comment\": [\n        /\\(;[\\s\\S]*?;\\)/,\n        {\n            pattern: /;;.*/,\n            greedy: true\n        }\n    ],\n    \"string\": {\n        pattern: /\"(?:\\\\[\\s\\S]|[^\"\\\\])*\"/,\n        greedy: true\n    },\n    \"keyword\": [\n        {\n            pattern: /\\b(?:align|offset)=/,\n            inside: {\n                \"operator\": /=/\n            }\n        },\n        {\n            pattern: /\\b(?:(?:f32|f64|i32|i64)(?:\\.(?:abs|add|and|ceil|clz|const|convert_[su]\\/i(?:32|64)|copysign|ctz|demote\\/f64|div(?:_[su])?|eqz?|extend_[su]\\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\\/f32|reinterpret\\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\\/f(?:32|64))?|wrap\\/i64|xor))?|memory\\.(?:grow|size))\\b/,\n            inside: {\n                \"punctuation\": /\\./\n            }\n        },\n        /\\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\\b/\n    ],\n    \"variable\": /\\$[\\w!#$%&'*+\\-./:<=>?@\\\\^`|~]+/,\n    \"number\": /[+-]?\\b(?:\\d(?:_?\\d)*(?:\\.\\d(?:_?\\d)*)?(?:[eE][+-]?\\d(?:_?\\d)*)?|0x[\\da-fA-F](?:_?[\\da-fA-F])*(?:\\.[\\da-fA-F](?:_?[\\da-fA-D])*)?(?:[pP][+-]?\\d(?:_?\\d)*)?)\\b|\\binf\\b|\\bnan(?::0x[\\da-fA-F](?:_?[\\da-fA-D])*)?\\b/,\n    \"punctuation\": /[()]/\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (prism);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJpc20tcmVhY3QtcmVuZGVyZXIvcHJpc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7O0NBT0MsR0FDRDs7Ozs7Ozs7O0NBU0MsR0FFQSxJQUFJQSxRQUFTO0lBRWIsc0JBQXNCO0lBQ3RCLElBQUlDLE9BQU87SUFDWCxJQUFJQyxXQUFXO0lBRWYsbUNBQW1DO0lBQ25DLElBQUlDLG1CQUFtQixDQUFDO0lBR3hCLElBQUlDLElBQUk7UUFDUDs7Ozs7Ozs7R0FRQyxHQUNEQyxNQUFNO1lBQ0xDLFFBQVEsU0FBU0EsT0FBT0MsTUFBTTtnQkFDN0IsSUFBSUEsa0JBQWtCQyxPQUFPO29CQUM1QixPQUFPLElBQUlBLE1BQU1ELE9BQU9FLElBQUksRUFBRUgsT0FBT0MsT0FBT0csT0FBTyxHQUFHSCxPQUFPSSxLQUFLO2dCQUNuRSxPQUFPLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ04sU0FBUztvQkFDakMsT0FBT0EsT0FBT08sR0FBRyxDQUFDUjtnQkFDbkIsT0FBTztvQkFDTixPQUFPQyxPQUFPUSxPQUFPLENBQUMsTUFBTSxTQUFTQSxPQUFPLENBQUMsTUFBTSxRQUFRQSxPQUFPLENBQUMsV0FBVztnQkFDL0U7WUFDRDtZQUVBOzs7Ozs7Ozs7Ozs7Ozs7SUFlQyxHQUNETixNQUFNLFNBQVVPLENBQUM7Z0JBQ2hCLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNKLEdBQUdLLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFDcEQ7WUFFQTs7Ozs7SUFLQyxHQUNEQyxPQUFPLFNBQVVDLEdBQUc7Z0JBQ25CLElBQUksQ0FBQ0EsR0FBRyxDQUFDLE9BQU8sRUFBRTtvQkFDakJOLE9BQU9PLGNBQWMsQ0FBQ0QsS0FBSyxRQUFRO3dCQUFFRSxPQUFPLEVBQUV2QjtvQkFBUztnQkFDeEQ7Z0JBQ0EsT0FBT3FCLEdBQUcsQ0FBQyxPQUFPO1lBQ25CO1lBRUE7Ozs7Ozs7OztJQVNDLEdBQ0RHLE9B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Q0FBQ2dCLEtBQUs7SUFDdEd2QixJQUFJUyxVQUFVLEdBQUc7QUFDbkIsR0FBR3NDO0FBQ0gsbUNBQW1DLEdBR25DQSxNQUFNM0YsU0FBUyxDQUFDeVIsSUFBSSxHQUFHO0lBQ3JCLFdBQVc7UUFBQztRQUFrQjtZQUM1QnRPLFNBQVM7WUFDVGMsUUFBUTtRQUNWO0tBQUU7SUFDRixVQUFVO1FBQ1JkLFNBQVM7UUFDVGMsUUFBUTtJQUNWO0lBQ0EsV0FBVztRQUFDO1lBQ1ZkLFNBQVM7WUFDVDNDLFFBQVE7Z0JBQ04sWUFBWTtZQUNkO1FBQ0Y7UUFBRztZQUNEMkMsU0FBUztZQUNUM0MsUUFBUTtnQkFDTixlQUFlO1lBQ2pCO1FBQ0Y7UUFBRztLQUEyUTtJQUM5USxZQUFZO0lBQ1osVUFBVTtJQUNWLGVBQWU7QUFDakI7QUFFQSxpRUFBZW1GLEtBQUtBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC1jbGllbnQvLi9ub2RlX21vZHVsZXMvcHJpc20tcmVhY3QtcmVuZGVyZXIvcHJpc20vaW5kZXguanM/ODgwOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByaXNtOiBMaWdodHdlaWdodCwgcm9idXN0LCBlbGVnYW50IHN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBAbGljZW5zZSBNSVQgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPlxuICogQGF1dGhvciBMZWEgVmVyb3UgPGh0dHBzOi8vbGVhLnZlcm91Lm1lPlxuICogQG5hbWVzcGFjZVxuICogQHB1YmxpY1xuICovXG4vKipcbiAqIHByaXNtLXJlYWN0LXJlbmRlcmVyOlxuICogVGhpcyBmaWxlIGhhcyBiZWVuIG1vZGlmaWVkIHRvIHJlbW92ZTpcbiAqIC0gZ2xvYmFscyBhbmQgd2luZG93IGRlcGVuZGVuY3lcbiAqIC0gd29ya2VyIHN1cHBvcnRcbiAqIC0gaGlnaGxpZ2h0QWxsIGFuZCBvdGhlciBlbGVtZW50IGRlcGVuZGVudCBtZXRob2RzXG4gKiAtIF8uaG9va3MgaGVscGVyc1xuICogLSBVTUQvbm9kZS1zcGVjaWZpYyBoYWNrc1xuICogSXQgaGFzIGFsc28gYmVlbiBydW4gdGhyb3VnaCBwcmV0dGllclxuICovXG5cbiB2YXIgUHJpc20gPSAoZnVuY3Rpb24gKCkge1xuXG5cdC8vIFByaXZhdGUgaGVscGVyIHZhcnNcblx0dmFyIGxhbmcgPSAvKD86XnxcXHMpbGFuZyg/OnVhZ2UpPy0oW1xcdy1dKykoPz1cXHN8JCkvaTtcblx0dmFyIHVuaXF1ZUlkID0gMDtcblxuXHQvLyBUaGUgZ3JhbW1hciBvYmplY3QgZm9yIHBsYWludGV4dFxuXHR2YXIgcGxhaW5UZXh0R3JhbW1hciA9IHt9O1xuXG5cblx0dmFyIF8gPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBuYW1lc3BhY2UgZm9yIHV0aWxpdHkgbWV0aG9kcy5cblx0XHQgKlxuXHRcdCAqIEFsbCBmdW5jdGlvbiBpbiB0aGlzIG5hbWVzcGFjZSB0aGF0IGFyZSBub3QgZXhwbGljaXRseSBtYXJrZWQgYXMgX3B1YmxpY18gYXJlIGZvciBfX2ludGVybmFsIHVzZSBvbmx5X18gYW5kIG1heVxuXHRcdCAqIGNoYW5nZSBvciBkaXNhcHBlYXIgYXQgYW55IHRpbWUuXG5cdFx0ICpcblx0XHQgKiBAbmFtZXNwYWNlXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICovXG5cdFx0dXRpbDoge1xuXHRcdFx0ZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGUodG9rZW5zKSB7XG5cdFx0XHRcdGlmICh0b2tlbnMgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgVG9rZW4odG9rZW5zLnR5cGUsIGVuY29kZSh0b2tlbnMuY29udGVudCksIHRva2Vucy5hbGlhcyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRva2Vucy5tYXAoZW5jb2RlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoL1xcdTAwYTAvZywgJyAnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSB0eXBlIG9mIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge2FueX0gb1xuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiB0eXBlKG51bGwpICAgICAgPT09ICdOdWxsJ1xuXHRcdFx0ICogdHlwZSh1bmRlZmluZWQpID09PSAnVW5kZWZpbmVkJ1xuXHRcdFx0ICogdHlwZSgxMjMpICAgICAgID09PSAnTnVtYmVyJ1xuXHRcdFx0ICogdHlwZSgnZm9vJykgICAgID09PSAnU3RyaW5nJ1xuXHRcdFx0ICogdHlwZSh0cnVlKSAgICAgID09PSAnQm9vbGVhbidcblx0XHRcdCAqIHR5cGUoWzEsIDJdKSAgICA9PT0gJ0FycmF5J1xuXHRcdFx0ICogdHlwZSh7fSkgICAgICAgID09PSAnT2JqZWN0J1xuXHRcdFx0ICogdHlwZShTdHJpbmcpICAgID09PSAnRnVuY3Rpb24nXG5cdFx0XHQgKiB0eXBlKC9hYmMrLykgICAgPT09ICdSZWdFeHAnXG5cdFx0XHQgKi9cblx0XHRcdHR5cGU6IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIGEgdW5pcXVlIG51bWJlciBmb3IgdGhlIGdpdmVuIG9iamVjdC4gTGF0ZXIgY2FsbHMgd2lsbCBzdGlsbCByZXR1cm4gdGhlIHNhbWUgbnVtYmVyLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0XHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0XHRcdG9iaklkOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdGlmICghb2JqWydfX2lkJ10pIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnX19pZCcsIHsgdmFsdWU6ICsrdW5pcXVlSWQgfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9ialsnX19pZCddO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBtYWluIGludGVuZGVkIHVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGNsb25lIGxhbmd1YWdlIGRlZmluaXRpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7VH0gb1xuXHRcdFx0ICogQHBhcmFtIHtSZWNvcmQ8bnVtYmVyLCBhbnk+fSBbdmlzaXRlZF1cblx0XHRcdCAqIEByZXR1cm5zIHtUfVxuXHRcdFx0ICogQHRlbXBsYXRlIFRcblx0XHRcdCAqL1xuXHRcdFx0Y2xvbmU6IGZ1bmN0aW9uIGRlZXBDbG9uZShvLCB2aXNpdGVkKSB7XG5cdFx0XHRcdHZpc2l0ZWQgPSB2aXNpdGVkIHx8IHt9O1xuXG5cdFx0XHRcdHZhciBjbG9uZTsgdmFyIGlkO1xuXHRcdFx0XHRzd2l0Y2ggKF8udXRpbC50eXBlKG8pKSB7XG5cdFx0XHRcdFx0Y2FzZSAnT2JqZWN0Jzpcblx0XHRcdFx0XHRcdGlkID0gXy51dGlsLm9iaklkKG8pO1xuXHRcdFx0XHRcdFx0aWYgKHZpc2l0ZWRbaWRdKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2aXNpdGVkW2lkXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNsb25lID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqLyAoe30pO1xuXHRcdFx0XHRcdFx0dmlzaXRlZFtpZF0gPSBjbG9uZTtcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG8pIHtcblx0XHRcdFx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0XHRcdGNsb25lW2tleV0gPSBkZWVwQ2xvbmUob1trZXldLCB2aXNpdGVkKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChjbG9uZSk7XG5cblx0XHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0XHRpZCA9IF8udXRpbC5vYmpJZChvKTtcblx0XHRcdFx0XHRcdGlmICh2aXNpdGVkW2lkXSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmlzaXRlZFtpZF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjbG9uZSA9IFtdO1xuXHRcdFx0XHRcdFx0dmlzaXRlZFtpZF0gPSBjbG9uZTtcblxuXHRcdFx0XHRcdFx0KC8qKiBAdHlwZSB7QXJyYXl9ICovKC8qKiBAdHlwZSB7YW55fSAqLyhvKSkpLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcblx0XHRcdFx0XHRcdFx0Y2xvbmVbaV0gPSBkZWVwQ2xvbmUodiwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoY2xvbmUpO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgdGhlIFByaXNtIGxhbmd1YWdlIG9mIHRoZSBnaXZlbiBlbGVtZW50IHNldCBieSBhIGBsYW5ndWFnZS14eHh4YCBvciBgbGFuZy14eHh4YCBjbGFzcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBJZiBubyBsYW5ndWFnZSBpcyBzZXQgZm9yIHRoZSBlbGVtZW50IG9yIHRoZSBlbGVtZW50IGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgYG5vbmVgIHdpbGwgYmUgcmV0dXJuZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdFx0ICovXG5cdFx0XHRnZXRMYW5ndWFnZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdFx0d2hpbGUgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHR2YXIgbSA9IGxhbmcuZXhlYyhlbGVtZW50LmNsYXNzTmFtZSk7XG5cdFx0XHRcdFx0aWYgKG0pIHtcblx0XHRcdFx0XHRcdHJldHVybiBtWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICdub25lJztcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0cyB0aGUgUHJpc20gYGxhbmd1YWdlLXh4eHhgIGNsYXNzIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG5cdFx0XHQgKiBAcmV0dXJucyB7dm9pZH1cblx0XHRcdCAqL1xuXHRcdFx0c2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uIChlbGVtZW50LCBsYW5ndWFnZSkge1xuXHRcdFx0XHQvLyByZW1vdmUgYWxsIGBsYW5ndWFnZS14eHh4YCBjbGFzc2VzXG5cdFx0XHRcdC8vICh0aGlzIG1pZ2h0IGxlYXZlIGJlaGluZCBhIGxlYWRpbmcgc3BhY2UpXG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShSZWdFeHAobGFuZywgJ2dpJyksICcnKTtcblxuXHRcdFx0XHQvLyBhZGQgdGhlIG5ldyBgbGFuZ3VhZ2UteHh4eGAgY2xhc3Ncblx0XHRcdFx0Ly8gKHVzaW5nIGBjbGFzc0xpc3RgIHdpbGwgYXV0b21hdGljYWxseSBjbGVhbiB1cCBzcGFjZXMgZm9yIHVzKVxuXHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhbmd1YWdlLScgKyBsYW5ndWFnZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgd2hldGhlciBhIGdpdmVuIGNsYXNzIGlzIGFjdGl2ZSBmb3IgYGVsZW1lbnRgLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBjbGFzcyBjYW4gYmUgYWN0aXZhdGVkIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIGdpdmVuIGNsYXNzIGFuZCBpdCBjYW4gYmUgZGVhY3RpdmF0ZWRcblx0XHRcdCAqIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gY2xhc3MuIFRoZSBfbmVnYXRlZCB2ZXJzaW9uXyBvZiB0aGVcblx0XHRcdCAqIGdpdmVuIGNsYXNzIGlzIGp1c3QgdGhlIGdpdmVuIGNsYXNzIHdpdGggYSBgbm8tYCBwcmVmaXguXG5cdFx0XHQgKlxuXHRcdFx0ICogV2hldGhlciB0aGUgY2xhc3MgaXMgYWN0aXZlIGlzIGRldGVybWluZWQgYnkgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgYGVsZW1lbnRgICh3aGVyZSBgZWxlbWVudGAgaXRzZWxmIGlzXG5cdFx0XHQgKiBjbG9zZXN0IGFuY2VzdG9yKSB0aGF0IGhhcyB0aGUgZ2l2ZW4gY2xhc3Mgb3IgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiBpdC4gSWYgbmVpdGhlciBgZWxlbWVudGAgbm9yIGFueSBvZiBpdHNcblx0XHRcdCAqIGFuY2VzdG9ycyBoYXZlIHRoZSBnaXZlbiBjbGFzcyBvciB0aGUgbmVnYXRlZCB2ZXJzaW9uIG9mIGl0LCB0aGVuIHRoZSBkZWZhdWx0IGFjdGl2YXRpb24gd2lsbCBiZSByZXR1cm5lZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBJbiB0aGUgcGFyYWRveGljYWwgc2l0dWF0aW9uIHdoZXJlIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGNvbnRhaW5zIF9fYm90aF9fIHRoZSBnaXZlbiBjbGFzcyBhbmQgdGhlIG5lZ2F0ZWRcblx0XHRcdCAqIHZlcnNpb24gb2YgaXQsIHRoZSBjbGFzcyBpcyBjb25zaWRlcmVkIGFjdGl2ZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmF1bHRBY3RpdmF0aW9uPWZhbHNlXVxuXHRcdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0XHRcdGlzQWN0aXZlOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lLCBkZWZhdWx0QWN0aXZhdGlvbikge1xuXHRcdFx0XHR2YXIgbm8gPSAnbm8tJyArIGNsYXNzTmFtZTtcblxuXHRcdFx0XHR3aGlsZSAoZWxlbWVudCkge1xuXHRcdFx0XHRcdHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcblx0XHRcdFx0XHRpZiAoY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY2xhc3NMaXN0LmNvbnRhaW5zKG5vKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAhIWRlZmF1bHRBY3RpdmF0aW9uO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIG5hbWVzcGFjZSBjb250YWlucyBhbGwgY3VycmVudGx5IGxvYWRlZCBsYW5ndWFnZXMgYW5kIHRoZSBzb21lIGhlbHBlciBmdW5jdGlvbnMgdG8gY3JlYXRlIGFuZCBtb2RpZnkgbGFuZ3VhZ2VzLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRsYW5ndWFnZXM6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIGdyYW1tYXIgZm9yIHBsYWluLCB1bmZvcm1hdHRlZCB0ZXh0LlxuXHRcdFx0ICovXG5cdFx0XHRwbGFpbjogcGxhaW5UZXh0R3JhbW1hcixcblx0XHRcdHBsYWludGV4dDogcGxhaW5UZXh0R3JhbW1hcixcblx0XHRcdHRleHQ6IHBsYWluVGV4dEdyYW1tYXIsXG5cdFx0XHR0eHQ6IHBsYWluVGV4dEdyYW1tYXIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiB0aGUgbGFuZ3VhZ2Ugd2l0aCB0aGUgZ2l2ZW4gaWQgYW5kIGFwcGVuZHMgdGhlIGdpdmVuIHRva2Vucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBJZiBhIHRva2VuIGluIGByZWRlZmAgYWxzbyBhcHBlYXJzIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2UsIHRoZW4gdGhlIGV4aXN0aW5nIHRva2VuIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2Vcblx0XHRcdCAqIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYXQgaXRzIG9yaWdpbmFsIHBvc2l0aW9uLlxuXHRcdFx0ICpcblx0XHRcdCAqICMjIEJlc3QgcHJhY3RpY2VzXG5cdFx0XHQgKlxuXHRcdFx0ICogU2luY2UgdGhlIHBvc2l0aW9uIG9mIG92ZXJ3cml0aW5nIHRva2VucyAodG9rZW4gaW4gYHJlZGVmYCB0aGF0IG92ZXJ3cml0ZSB0b2tlbnMgaW4gdGhlIGNvcGllZCBsYW5ndWFnZSlcblx0XHRcdCAqIGRvZXNuJ3QgbWF0dGVyLCB0aGV5IGNhbiB0ZWNobmljYWxseSBiZSBpbiBhbnkgb3JkZXIuIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIGNvbmZ1c2luZyB0byBvdGhlcnMgdGhhdCB0cnlpbmcgdG9cblx0XHRcdCAqIHVuZGVyc3RhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gYmVjYXVzZSwgbm9ybWFsbHksIHRoZSBvcmRlciBvZiB0b2tlbnMgbWF0dGVycyBpbiBQcmlzbSBncmFtbWFycy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGVyZWZvcmUsIGl0IGlzIGVuY291cmFnZWQgdG8gb3JkZXIgb3ZlcndyaXRpbmcgdG9rZW5zIGFjY29yZGluZyB0byB0aGUgcG9zaXRpb25zIG9mIHRoZSBvdmVyd3JpdHRlbiB0b2tlbnMuXG5cdFx0XHQgKiBGdXJ0aGVybW9yZSwgYWxsIG5vbi1vdmVyd3JpdGluZyB0b2tlbnMgc2hvdWxkIGJlIHBsYWNlZCBhZnRlciB0aGUgb3ZlcndyaXRpbmcgb25lcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBsYW5ndWFnZSB0byBleHRlbmQuIFRoaXMgaGFzIHRvIGJlIGEga2V5IGluIGBQcmlzbS5sYW5ndWFnZXNgLlxuXHRcdFx0ICogQHBhcmFtIHtHcmFtbWFyfSByZWRlZiBUaGUgbmV3IHRva2VucyB0byBhcHBlbmQuXG5cdFx0XHQgKiBAcmV0dXJucyB7R3JhbW1hcn0gVGhlIG5ldyBsYW5ndWFnZSBjcmVhdGVkLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlc1snY3NzLXdpdGgtY29sb3JzJ10gPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG5cdFx0XHQgKiAgICAgLy8gUHJpc20ubGFuZ3VhZ2VzLmNzcyBhbHJlYWR5IGhhcyBhICdjb21tZW50JyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIG92ZXJ3cml0ZSBDU1MnICdjb21tZW50JyB0b2tlblxuXHRcdFx0ICogICAgIC8vIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdFx0ICogICAgICdjb21tZW50JzogeyAuLi4gfSxcblx0XHRcdCAqICAgICAvLyBDU1MgZG9lc24ndCBoYXZlIGEgJ2NvbG9yJyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIGJlIGFwcGVuZGVkXG5cdFx0XHQgKiAgICAgJ2NvbG9yJzogL1xcYig/OnJlZHxncmVlbnxibHVlKVxcYi9cblx0XHRcdCAqIH0pO1xuXHRcdFx0ICovXG5cdFx0XHRleHRlbmQ6IGZ1bmN0aW9uIChpZCwgcmVkZWYpIHtcblx0XHRcdFx0dmFyIGxhbmcgPSBfLnV0aWwuY2xvbmUoXy5sYW5ndWFnZXNbaWRdKTtcblxuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gcmVkZWYpIHtcblx0XHRcdFx0XHRsYW5nW2tleV0gPSByZWRlZltrZXldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGxhbmc7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEluc2VydHMgdG9rZW5zIF9iZWZvcmVfIGFub3RoZXIgdG9rZW4gaW4gYSBsYW5ndWFnZSBkZWZpbml0aW9uIG9yIGFueSBvdGhlciBncmFtbWFyLlxuXHRcdFx0ICpcblx0XHRcdCAqICMjIFVzYWdlXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhpcyBoZWxwZXIgbWV0aG9kIG1ha2VzIGl0IGVhc3kgdG8gbW9kaWZ5IGV4aXN0aW5nIGxhbmd1YWdlcy4gRm9yIGV4YW1wbGUsIHRoZSBDU1MgbGFuZ3VhZ2UgZGVmaW5pdGlvblxuXHRcdFx0ICogbm90IG9ubHkgZGVmaW5lcyBDU1MgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZG9jdW1lbnRzLCBidXQgYWxzbyBuZWVkcyB0byBkZWZpbmUgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZW1iZWRkZWRcblx0XHRcdCAqIGluIEhUTUwgdGhyb3VnaCBgPHN0eWxlPmAgZWxlbWVudHMuIFRvIGRvIHRoaXMsIGl0IG5lZWRzIHRvIG1vZGlmeSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAgYW5kIGFkZCB0aGVcblx0XHRcdCAqIGFwcHJvcHJpYXRlIHRva2Vucy4gSG93ZXZlciwgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgIGlzIGEgcmVndWxhciBKYXZhU2NyaXB0IG9iamVjdCBsaXRlcmFsLCBzbyBpZiB5b3UgZG9cblx0XHRcdCAqIHRoaXM6XG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuc3R5bGUgPSB7XG5cdFx0XHQgKiAgICAgLy8gdG9rZW5cblx0XHRcdCAqIH07XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiB0aGVuIHRoZSBgc3R5bGVgIHRva2VuIHdpbGwgYmUgYWRkZWQgKGFuZCBwcm9jZXNzZWQpIGF0IHRoZSBlbmQuIGBpbnNlcnRCZWZvcmVgIGFsbG93cyB5b3UgdG8gaW5zZXJ0IHRva2Vuc1xuXHRcdFx0ICogYmVmb3JlIGV4aXN0aW5nIHRva2Vucy4gRm9yIHRoZSBDU1MgZXhhbXBsZSBhYm92ZSwgeW91IHdvdWxkIHVzZSBpdCBsaWtlIHRoaXM6XG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIHtcblx0XHRcdCAqICAgICAnc3R5bGUnOiB7XG5cdFx0XHQgKiAgICAgICAgIC8vIHRva2VuXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogfSk7XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBTcGVjaWFsIGNhc2VzXG5cdFx0XHQgKlxuXHRcdFx0ICogSWYgdGhlIGdyYW1tYXJzIG9mIGBpbnNpZGVgIGFuZCBgaW5zZXJ0YCBoYXZlIHRva2VucyB3aXRoIHRoZSBzYW1lIG5hbWUsIHRoZSB0b2tlbnMgaW4gYGluc2lkZWAncyBncmFtbWFyXG5cdFx0XHQgKiB3aWxsIGJlIGlnbm9yZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhpcyBiZWhhdmlvciBjYW4gYmUgdXNlZCB0byBpbnNlcnQgdG9rZW5zIGFmdGVyIGBiZWZvcmVgOlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY29tbWVudCcsIHtcblx0XHRcdCAqICAgICAnY29tbWVudCc6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuY29tbWVudCxcblx0XHRcdCAqICAgICAvLyB0b2tlbnMgYWZ0ZXIgJ2NvbW1lbnQnXG5cdFx0XHQgKiB9KTtcblx0XHRcdCAqIGBgYFxuXHRcdFx0ICpcblx0XHRcdCAqICMjIExpbWl0YXRpb25zXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIG1haW4gcHJvYmxlbSBgaW5zZXJ0QmVmb3JlYCBoYXMgdG8gc29sdmUgaXMgaXRlcmF0aW9uIG9yZGVyLiBTaW5jZSBFUzIwMTUsIHRoZSBpdGVyYXRpb24gb3JkZXIgZm9yIG9iamVjdFxuXHRcdFx0ICogcHJvcGVydGllcyBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSBpbnNlcnRpb24gb3JkZXIgKGV4Y2VwdCBmb3IgaW50ZWdlciBrZXlzKSBidXQgc29tZSBicm93c2VycyBiZWhhdmVcblx0XHRcdCAqIGRpZmZlcmVudGx5IHdoZW4ga2V5cyBhcmUgZGVsZXRlZCBhbmQgcmUtaW5zZXJ0ZWQuIFNvIGBpbnNlcnRCZWZvcmVgIGNhbid0IGJlIGltcGxlbWVudGVkIGJ5IHRlbXBvcmFyaWx5XG5cdFx0XHQgKiBkZWxldGluZyBwcm9wZXJ0aWVzIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBpbnNlcnQgYXQgYXJiaXRyYXJ5IHBvc2l0aW9ucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIGBpbnNlcnRCZWZvcmVgIGRvZXNuJ3QgYWN0dWFsbHkgaW5zZXJ0IHRoZSBnaXZlbiB0b2tlbnMgaW50byB0aGUgdGFyZ2V0IG9iamVjdC5cblx0XHRcdCAqIEluc3RlYWQsIGl0IHdpbGwgY3JlYXRlIGEgbmV3IG9iamVjdCBhbmQgcmVwbGFjZSBhbGwgcmVmZXJlbmNlcyB0byB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBuZXcgb25lLiBUaGlzXG5cdFx0XHQgKiBjYW4gYmUgZG9uZSB3aXRob3V0IHRlbXBvcmFyaWx5IGRlbGV0aW5nIHByb3BlcnRpZXMsIHNvIHRoZSBpdGVyYXRpb24gb3JkZXIgaXMgd2VsbC1kZWZpbmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEhvd2V2ZXIsIG9ubHkgcmVmZXJlbmNlcyB0aGF0IGNhbiBiZSByZWFjaGVkIGZyb20gYFByaXNtLmxhbmd1YWdlc2Agb3IgYGluc2VydGAgd2lsbCBiZSByZXBsYWNlZC4gSS5lLiBpZlxuXHRcdFx0ICogeW91IGhvbGQgdGhlIHRhcmdldCBvYmplY3QgaW4gYSB2YXJpYWJsZSwgdGhlbiB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIHdpbGwgbm90IGNoYW5nZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBgYGBqc1xuXHRcdFx0ICogdmFyIG9sZE1hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cdFx0XHQgKiB2YXIgbmV3TWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NvbW1lbnQnLCB7IC4uLiB9KTtcblx0XHRcdCAqXG5cdFx0XHQgKiBhc3NlcnQob2xkTWFya3VwICE9PSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKTtcblx0XHRcdCAqIGFzc2VydChuZXdNYXJrdXAgPT09IFByaXNtLmxhbmd1YWdlcy5tYXJrdXApO1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGluc2lkZSBUaGUgcHJvcGVydHkgb2YgYHJvb3RgIChlLmcuIGEgbGFuZ3VhZ2UgaWQgaW4gYFByaXNtLmxhbmd1YWdlc2ApIHRoYXQgY29udGFpbnMgdGhlXG5cdFx0XHQgKiBvYmplY3QgdG8gYmUgbW9kaWZpZWQuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYmVmb3JlIFRoZSBrZXkgdG8gaW5zZXJ0IGJlZm9yZS5cblx0XHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gaW5zZXJ0IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXktdmFsdWUgcGFpcnMgdG8gYmUgaW5zZXJ0ZWQuXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtyb290XSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgYGluc2lkZWAsIGkuZS4gdGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuXHRcdFx0ICogb2JqZWN0IHRvIGJlIG1vZGlmaWVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIERlZmF1bHRzIHRvIGBQcmlzbS5sYW5ndWFnZXNgLlxuXHRcdFx0ICogQHJldHVybnMge0dyYW1tYXJ9IFRoZSBuZXcgZ3JhbW1hciBvYmplY3QuXG5cdFx0XHQgKiBAcHVibGljXG5cdFx0XHQgKi9cblx0XHRcdGluc2VydEJlZm9yZTogZnVuY3Rpb24gKGluc2lkZSwgYmVmb3JlLCBpbnNlcnQsIHJvb3QpIHtcblx0XHRcdFx0cm9vdCA9IHJvb3QgfHwgLyoqIEB0eXBlIHthbnl9ICovIChfLmxhbmd1YWdlcyk7XG5cdFx0XHRcdHZhciBncmFtbWFyID0gcm9vdFtpbnNpZGVdO1xuXHRcdFx0XHQvKiogQHR5cGUge0dyYW1tYXJ9ICovXG5cdFx0XHRcdHZhciByZXQgPSB7fTtcblxuXHRcdFx0XHRmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG5cdFx0XHRcdFx0aWYgKGdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG5cblx0XHRcdFx0XHRcdGlmICh0b2tlbiA9PSBiZWZvcmUpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGluc2VydC5oYXNPd25Qcm9wZXJ0eShuZXdUb2tlbikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldFtuZXdUb2tlbl0gPSBpbnNlcnRbbmV3VG9rZW5dO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBEbyBub3QgaW5zZXJ0IHRva2VuIHdoaWNoIGFsc28gb2NjdXIgaW4gaW5zZXJ0LiBTZWUgIzE1MjVcblx0XHRcdFx0XHRcdGlmICghaW5zZXJ0Lmhhc093blByb3BlcnR5KHRva2VuKSkge1xuXHRcdFx0XHRcdFx0XHRyZXRbdG9rZW5dID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG9sZCA9IHJvb3RbaW5zaWRlXTtcblx0XHRcdFx0cm9vdFtpbnNpZGVdID0gcmV0O1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSByZWZlcmVuY2VzIGluIG90aGVyIGxhbmd1YWdlIGRlZmluaXRpb25zXG5cdFx0XHRcdF8ubGFuZ3VhZ2VzLkRGUyhfLmxhbmd1YWdlcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG9sZCAmJiBrZXkgIT0gaW5zaWRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzW2tleV0gPSByZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVHJhdmVyc2UgYSBsYW5ndWFnZSBkZWZpbml0aW9uIHdpdGggRGVwdGggRmlyc3QgU2VhcmNoXG5cdFx0XHRERlM6IGZ1bmN0aW9uIERGUyhvLCBjYWxsYmFjaywgdHlwZSwgdmlzaXRlZCkge1xuXHRcdFx0XHR2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcblxuXHRcdFx0XHR2YXIgb2JqSWQgPSBfLnV0aWwub2JqSWQ7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvKSB7XG5cdFx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwobywgaSwgb1tpXSwgdHlwZSB8fCBpKTtcblxuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5ID0gb1tpXTtcblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eVR5cGUgPSBfLnV0aWwudHlwZShwcm9wZXJ0eSk7XG5cblx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eVR5cGUgPT09ICdPYmplY3QnICYmICF2aXNpdGVkW29iaklkKHByb3BlcnR5KV0pIHtcblx0XHRcdFx0XHRcdFx0dmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0REZTKHByb3BlcnR5LCBjYWxsYmFjaywgbnVsbCwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb3BlcnR5VHlwZSA9PT0gJ0FycmF5JyAmJiAhdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldKSB7XG5cdFx0XHRcdFx0XHRcdHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIGksIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRwbHVnaW5zOiB7fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogTG93LWxldmVsIGZ1bmN0aW9uLCBvbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdeKAmXJlIGRvaW5nLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcblx0XHQgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgSFRNTCBwcm9kdWNlZC5cblx0XHQgKlxuXHRcdCAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG5cdFx0ICogMS4gYGJlZm9yZS10b2tlbml6ZWBcblx0XHQgKiAyLiBgYWZ0ZXItdG9rZW5pemVgXG5cdFx0ICogMy4gYHdyYXBgOiBPbiBlYWNoIHtAbGluayBUb2tlbn0uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBBIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGJlIGhpZ2hsaWdodGVkLlxuXHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gZ3JhbW1hciBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW5zIHRvIHVzZS5cblx0XHQgKlxuXHRcdCAqIFVzdWFsbHkgYSBsYW5ndWFnZSBkZWZpbml0aW9uIGxpa2UgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbmFtZSBvZiB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBwYXNzZWQgdG8gYGdyYW1tYXJgLlxuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBoaWdobGlnaHRlZCBIVE1MLlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIFByaXNtLmhpZ2hsaWdodCgndmFyIGZvbyA9IHRydWU7JywgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsICdqYXZhc2NyaXB0Jyk7XG5cdFx0ICovXG5cdFx0aGlnaGxpZ2h0OiBmdW5jdGlvbiAodGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcblx0XHRcdHZhciBlbnYgPSB7XG5cdFx0XHRcdGNvZGU6IHRleHQsXG5cdFx0XHRcdGdyYW1tYXI6IGdyYW1tYXIsXG5cdFx0XHRcdGxhbmd1YWdlOiBsYW5ndWFnZVxuXHRcdFx0fTtcblx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtdG9rZW5pemUnLCBlbnYpO1xuXHRcdFx0ZW52LnRva2VucyA9IF8udG9rZW5pemUoZW52LmNvZGUsIGVudi5ncmFtbWFyKTtcblx0XHRcdF8uaG9va3MucnVuKCdhZnRlci10b2tlbml6ZScsIGVudik7XG5cdFx0XHRyZXR1cm4gVG9rZW4uc3RyaW5naWZ5KF8udXRpbC5lbmNvZGUoZW52LnRva2VucyksIGVudi5sYW5ndWFnZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaXMgdGhlIGhlYXJ0IG9mIFByaXNtLCBhbmQgdGhlIG1vc3QgbG93LWxldmVsIGZ1bmN0aW9uIHlvdSBjYW4gdXNlLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcblx0XHQgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgdG9rZW5pemVkIGNvZGUuXG5cdFx0ICpcblx0XHQgKiBXaGVuIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIGluY2x1ZGVzIG5lc3RlZCB0b2tlbnMsIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgcmVjdXJzaXZlbHkgb24gZWFjaCBvZiB0aGVzZSB0b2tlbnMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIG1ldGhvZCBjb3VsZCBiZSB1c2VmdWwgaW4gb3RoZXIgY29udGV4dHMgYXMgd2VsbCwgYXMgYSB2ZXJ5IGNydWRlIHBhcnNlci5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IEEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWQuXG5cdFx0ICogQHBhcmFtIHtHcmFtbWFyfSBncmFtbWFyIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbnMgdG8gdXNlLlxuXHRcdCAqXG5cdFx0ICogVXN1YWxseSBhIGxhbmd1YWdlIGRlZmluaXRpb24gbGlrZSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAuXG5cdFx0ICogQHJldHVybnMge1Rva2VuU3RyZWFtfSBBbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB0b2tlbnMsIGEgdG9rZW4gc3RyZWFtLlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIGxldCBjb2RlID0gYHZhciBmb28gPSAwO2A7XG5cdFx0ICogbGV0IHRva2VucyA9IFByaXNtLnRva2VuaXplKGNvZGUsIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcblx0XHQgKiB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XG5cdFx0ICogICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFByaXNtLlRva2VuICYmIHRva2VuLnR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0ICogICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgbnVtZXJpYyBsaXRlcmFsOiAke3Rva2VuLmNvbnRlbnR9YCk7XG5cdFx0ICogICAgIH1cblx0XHQgKiB9KTtcblx0XHQgKi9cblx0XHR0b2tlbml6ZTogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIpIHtcblx0XHRcdHZhciByZXN0ID0gZ3JhbW1hci5yZXN0O1xuXHRcdFx0aWYgKHJlc3QpIHtcblx0XHRcdFx0Zm9yICh2YXIgdG9rZW4gaW4gcmVzdCkge1xuXHRcdFx0XHRcdGdyYW1tYXJbdG9rZW5dID0gcmVzdFt0b2tlbl07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZ3JhbW1hci5yZXN0O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdG9rZW5MaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcblx0XHRcdGFkZEFmdGVyKHRva2VuTGlzdCwgdG9rZW5MaXN0LmhlYWQsIHRleHQpO1xuXG5cdFx0XHRtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCB0b2tlbkxpc3QuaGVhZCwgMCk7XG5cblx0XHRcdHJldHVybiB0b0FycmF5KHRva2VuTGlzdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBuYW1lc3BhY2Vcblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0aG9va3M6IHtcblx0XHRcdGFsbDoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gdGhlIGxpc3Qgb2YgY2FsbGJhY2tzIGZvciB0aGUgZ2l2ZW4gaG9vay5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGhvb2sgaXQgaXMgcmVnaXN0ZXJlZCBmb3IgaXMgcnVuLlxuXHRcdFx0ICogSG9va3MgYXJlIHVzdWFsbHkgZGlyZWN0bHkgcnVuIGJ5IGEgaGlnaGxpZ2h0IGZ1bmN0aW9uIGJ1dCB5b3UgY2FuIGFsc28gcnVuIGhvb2tzIHlvdXJzZWxmLlxuXHRcdFx0ICpcblx0XHRcdCAqIE9uZSBjYWxsYmFjayBmdW5jdGlvbiBjYW4gYmUgcmVnaXN0ZXJlZCB0byBtdWx0aXBsZSBob29rcyBhbmQgdGhlIHNhbWUgaG9vayBtdWx0aXBsZSB0aW1lcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vay5cblx0XHRcdCAqIEBwYXJhbSB7SG9va0NhbGxiYWNrfSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICovXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgaG9va3MgPSBfLmhvb2tzLmFsbDtcblxuXHRcdFx0XHRob29rc1tuYW1lXSA9IGhvb2tzW25hbWVdIHx8IFtdO1xuXG5cdFx0XHRcdGhvb2tzW25hbWVdLnB1c2goY2FsbGJhY2spO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSdW5zIGEgaG9vayBpbnZva2luZyBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIENhbGxiYWNrcyB3aWxsIGJlIGludm9rZWQgc3luY2hyb25vdXNseSBhbmQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBlbnYgVGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvZiB0aGUgaG9vayBwYXNzZWQgdG8gYWxsIGNhbGxiYWNrcyByZWdpc3RlcmVkLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICovXG5cdFx0XHRydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcblx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuXG5cdFx0XHRcdGlmICghY2FsbGJhY2tzIHx8ICFjYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGNhbGxiYWNrOyAoY2FsbGJhY2sgPSBjYWxsYmFja3NbaSsrXSk7KSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZW52KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRUb2tlbjogVG9rZW5cblx0fTtcblxuXG5cdC8vIFR5cGVzY3JpcHQgbm90ZTpcblx0Ly8gVGhlIGZvbGxvd2luZyBjYW4gYmUgdXNlZCB0byBpbXBvcnQgdGhlIFRva2VuIHR5cGUgaW4gSlNEb2M6XG5cdC8vXG5cdC8vICAgQHR5cGVkZWYge0luc3RhbmNlVHlwZTxpbXBvcnQoXCIuL3ByaXNtLWNvcmVcIilbXCJUb2tlblwiXT59IFRva2VuXG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgdG9rZW4uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFNlZSB7QGxpbmsgVG9rZW4jdHlwZSB0eXBlfVxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IFRva2VuU3RyZWFtfSBjb250ZW50IFNlZSB7QGxpbmsgVG9rZW4jY29udGVudCBjb250ZW50fVxuXHQgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW2FsaWFzXSBUaGUgYWxpYXMoZXMpIG9mIHRoZSB0b2tlbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFttYXRjaGVkU3RyPVwiXCJdIEEgY29weSBvZiB0aGUgZnVsbCBzdHJpbmcgdGhpcyB0b2tlbiB3YXMgY3JlYXRlZCBmcm9tLlxuXHQgKiBAY2xhc3Ncblx0ICogQGdsb2JhbFxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiBUb2tlbih0eXBlLCBjb250ZW50LCBhbGlhcywgbWF0Y2hlZFN0cikge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIFRoaXMgaXMgdXN1YWxseSB0aGUga2V5IG9mIGEgcGF0dGVybiBpbiBhIHtAbGluayBHcmFtbWFyfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHNlZSBHcmFtbWFyVG9rZW5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHQvKipcblx0XHQgKiBUaGUgc3RyaW5ncyBvciB0b2tlbnMgY29udGFpbmVkIGJ5IHRoaXMgdG9rZW4uXG5cdFx0ICpcblx0XHQgKiBUaGlzIHdpbGwgYmUgYSB0b2tlbiBzdHJlYW0gaWYgdGhlIHBhdHRlcm4gbWF0Y2hlZCBhbHNvIGRlZmluZWQgYW4gYGluc2lkZWAgZ3JhbW1hci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmcgfCBUb2tlblN0cmVhbX1cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy5jb250ZW50ID0gY29udGVudDtcblx0XHQvKipcblx0XHQgKiBUaGUgYWxpYXMoZXMpIG9mIHRoZSB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd8c3RyaW5nW119XG5cdFx0ICogQHNlZSBHcmFtbWFyVG9rZW5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy5hbGlhcyA9IGFsaWFzO1xuXHRcdC8vIENvcHkgb2YgdGhlIGZ1bGwgc3RyaW5nIHRoaXMgdG9rZW4gd2FzIGNyZWF0ZWQgZnJvbVxuXHRcdHRoaXMubGVuZ3RoID0gKG1hdGNoZWRTdHIgfHwgJycpLmxlbmd0aCB8IDA7XG5cdH1cblxuXHQvKipcblx0ICogQSB0b2tlbiBzdHJlYW0gaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQge0BsaW5rIFRva2VuIFRva2VufSBvYmplY3RzLlxuXHQgKlxuXHQgKiBUb2tlbiBzdHJlYW1zIGhhdmUgdG8gZnVsZmlsbCBhIGZldyBwcm9wZXJ0aWVzIHRoYXQgYXJlIGFzc3VtZWQgYnkgbW9zdCBmdW5jdGlvbnMgKG1vc3RseSBpbnRlcm5hbCBvbmVzKSB0aGF0IHByb2Nlc3Ncblx0ICogdGhlbS5cblx0ICpcblx0ICogMS4gTm8gYWRqYWNlbnQgc3RyaW5ncy5cblx0ICogMi4gTm8gZW1wdHkgc3RyaW5ncy5cblx0ICpcblx0ICogICAgVGhlIG9ubHkgZXhjZXB0aW9uIGhlcmUgaXMgdGhlIHRva2VuIHN0cmVhbSB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGVtcHR5IHN0cmluZyBhbmQgbm90aGluZyBlbHNlLlxuXHQgKlxuXHQgKiBAdHlwZWRlZiB7QXJyYXk8c3RyaW5nIHwgVG9rZW4+fSBUb2tlblN0cmVhbVxuXHQgKiBAZ2xvYmFsXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiB0b2tlbiBvciB0b2tlbiBzdHJlYW0gdG8gYW4gSFRNTCByZXByZXNlbnRhdGlvbi5cblx0ICpcblx0ICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcblx0ICogMS4gYHdyYXBgOiBPbiBlYWNoIHtAbGluayBUb2tlbn0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgVG9rZW4gfCBUb2tlblN0cmVhbX0gbyBUaGUgdG9rZW4gb3IgdG9rZW4gc3RyZWFtIHRvIGJlIGNvbnZlcnRlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBuYW1lIG9mIGN1cnJlbnQgbGFuZ3VhZ2UuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBIVE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b2tlbiBvciB0b2tlbiBzdHJlYW0uXG5cdCAqIEBtZW1iZXJvZiBUb2tlblxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUb2tlbi5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkobywgbGFuZ3VhZ2UpIHtcblx0XHRpZiAodHlwZW9mIG8gPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBvO1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuXHRcdFx0dmFyIHMgPSAnJztcblx0XHRcdG8uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRzICs9IHN0cmluZ2lmeShlLCBsYW5ndWFnZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzO1xuXHRcdH1cblxuXHRcdHZhciBlbnYgPSB7XG5cdFx0XHR0eXBlOiBvLnR5cGUsXG5cdFx0XHRjb250ZW50OiBzdHJpbmdpZnkoby5jb250ZW50LCBsYW5ndWFnZSksXG5cdFx0XHR0YWc6ICdzcGFuJyxcblx0XHRcdGNsYXNzZXM6IFsndG9rZW4nLCBvLnR5cGVdLFxuXHRcdFx0YXR0cmlidXRlczoge30sXG5cdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2Vcblx0XHR9O1xuXG5cdFx0dmFyIGFsaWFzZXMgPSBvLmFsaWFzO1xuXHRcdGlmIChhbGlhc2VzKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGlhc2VzKSkge1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbnYuY2xhc3Nlcy5wdXNoKGFsaWFzZXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF8uaG9va3MucnVuKCd3cmFwJywgZW52KTtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gJyc7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBlbnYuYXR0cmlidXRlcykge1xuXHRcdFx0YXR0cmlidXRlcyArPSAnICcgKyBuYW1lICsgJz1cIicgKyAoZW52LmF0dHJpYnV0ZXNbbmFtZV0gfHwgJycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSArICdcIic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICc8JyArIGVudi50YWcgKyAnIGNsYXNzPVwiJyArIGVudi5jbGFzc2VzLmpvaW4oJyAnKSArICdcIicgKyBhdHRyaWJ1dGVzICsgJz4nICsgZW52LmNvbnRlbnQgKyAnPC8nICsgZW52LnRhZyArICc+Jztcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb2tiZWhpbmRcblx0ICogQHJldHVybnMge1JlZ0V4cEV4ZWNBcnJheSB8IG51bGx9XG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcG9zLCB0ZXh0LCBsb29rYmVoaW5kKSB7XG5cdFx0cGF0dGVybi5sYXN0SW5kZXggPSBwb3M7XG5cdFx0dmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHRleHQpO1xuXHRcdGlmIChtYXRjaCAmJiBsb29rYmVoaW5kICYmIG1hdGNoWzFdKSB7XG5cdFx0XHQvLyBjaGFuZ2UgdGhlIG1hdGNoIHRvIHJlbW92ZSB0aGUgdGV4dCBtYXRjaGVkIGJ5IHRoZSBQcmlzbSBsb29rYmVoaW5kIGdyb3VwXG5cdFx0XHR2YXIgbG9va2JlaGluZExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcblx0XHRcdG1hdGNoLmluZGV4ICs9IGxvb2tiZWhpbmRMZW5ndGg7XG5cdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKGxvb2tiZWhpbmRMZW5ndGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2g7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHRcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PHN0cmluZyB8IFRva2VuPn0gdG9rZW5MaXN0XG5cdCAqIEBwYXJhbSB7YW55fSBncmFtbWFyXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8c3RyaW5nIHwgVG9rZW4+fSBzdGFydE5vZGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zXG5cdCAqIEBwYXJhbSB7UmVtYXRjaE9wdGlvbnN9IFtyZW1hdGNoXVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHR5cGVkZWYgUmVtYXRjaE9wdGlvbnNcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdXNlXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWFjaFxuXHQgKi9cblx0ZnVuY3Rpb24gbWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgc3RhcnROb2RlLCBzdGFydFBvcywgcmVtYXRjaCkge1xuXHRcdGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcblx0XHRcdGlmICghZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikgfHwgIWdyYW1tYXJbdG9rZW5dKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGF0dGVybnMgPSBncmFtbWFyW3Rva2VuXTtcblx0XHRcdHBhdHRlcm5zID0gQXJyYXkuaXNBcnJheShwYXR0ZXJucykgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc107XG5cblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcGF0dGVybnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0aWYgKHJlbWF0Y2ggJiYgcmVtYXRjaC5jYXVzZSA9PSB0b2tlbiArICcsJyArIGopIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcGF0dGVybk9iaiA9IHBhdHRlcm5zW2pdO1xuXHRcdFx0XHR2YXIgaW5zaWRlID0gcGF0dGVybk9iai5pbnNpZGU7XG5cdFx0XHRcdHZhciBsb29rYmVoaW5kID0gISFwYXR0ZXJuT2JqLmxvb2tiZWhpbmQ7XG5cdFx0XHRcdHZhciBncmVlZHkgPSAhIXBhdHRlcm5PYmouZ3JlZWR5O1xuXHRcdFx0XHR2YXIgYWxpYXMgPSBwYXR0ZXJuT2JqLmFsaWFzO1xuXG5cdFx0XHRcdGlmIChncmVlZHkgJiYgIXBhdHRlcm5PYmoucGF0dGVybi5nbG9iYWwpIHtcblx0XHRcdFx0XHQvLyBXaXRob3V0IHRoZSBnbG9iYWwgZmxhZywgbGFzdEluZGV4IHdvbid0IHdvcmtcblx0XHRcdFx0XHR2YXIgZmxhZ3MgPSBwYXR0ZXJuT2JqLnBhdHRlcm4udG9TdHJpbmcoKS5tYXRjaCgvW2ltc3V5XSokLylbMF07XG5cdFx0XHRcdFx0cGF0dGVybk9iai5wYXR0ZXJuID0gUmVnRXhwKHBhdHRlcm5PYmoucGF0dGVybi5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKiBAdHlwZSB7UmVnRXhwfSAqL1xuXHRcdFx0XHR2YXIgcGF0dGVybiA9IHBhdHRlcm5PYmoucGF0dGVybiB8fCBwYXR0ZXJuT2JqO1xuXG5cdFx0XHRcdGZvciAoIC8vIGl0ZXJhdGUgdGhlIHRva2VuIGxpc3QgYW5kIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgdG9rZW4vc3RyaW5nIHBvc2l0aW9uXG5cdFx0XHRcdFx0dmFyIGN1cnJlbnROb2RlID0gc3RhcnROb2RlLm5leHQsIHBvcyA9IHN0YXJ0UG9zO1xuXHRcdFx0XHRcdGN1cnJlbnROb2RlICE9PSB0b2tlbkxpc3QudGFpbDtcblx0XHRcdFx0XHRwb3MgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoLCBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHRcblx0XHRcdFx0KSB7XG5cblx0XHRcdFx0XHRpZiAocmVtYXRjaCAmJiBwb3MgPj0gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHN0ciA9IGN1cnJlbnROb2RlLnZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKHRva2VuTGlzdC5sZW5ndGggPiB0ZXh0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Ly8gU29tZXRoaW5nIHdlbnQgdGVycmlibHkgd3JvbmcsIEFCT1JULCBBQk9SVCFcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoc3RyIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciByZW1vdmVDb3VudCA9IDE7IC8vIHRoaXMgaXMgdGhlIHRvIHBhcmFtZXRlciBvZiByZW1vdmVCZXR3ZWVuXG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXG5cdFx0XHRcdFx0aWYgKGdyZWVkeSkge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcG9zLCB0ZXh0LCBsb29rYmVoaW5kKTtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggPj0gdGV4dC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBmcm9tID0gbWF0Y2guaW5kZXg7XG5cdFx0XHRcdFx0XHR2YXIgdG8gPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFx0XHRcdHZhciBwID0gcG9zO1xuXG5cdFx0XHRcdFx0XHQvLyBmaW5kIHRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIG1hdGNoXG5cdFx0XHRcdFx0XHRwICs9IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChmcm9tID49IHApIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xuXHRcdFx0XHRcdFx0XHRwICs9IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGFkanVzdCBwb3MgKGFuZCBwKVxuXHRcdFx0XHRcdFx0cCAtPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRwb3MgPSBwO1xuXG5cdFx0XHRcdFx0XHQvLyB0aGUgY3VycmVudCBub2RlIGlzIGEgVG9rZW4sIHRoZW4gdGhlIG1hdGNoIHN0YXJ0cyBpbnNpZGUgYW5vdGhlciBUb2tlbiwgd2hpY2ggaXMgaW52YWxpZFxuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnROb2RlLnZhbHVlIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGZpbmQgdGhlIGxhc3Qgbm9kZSB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIG1hdGNoXG5cdFx0XHRcdFx0XHRmb3IgKFxuXHRcdFx0XHRcdFx0XHR2YXIgayA9IGN1cnJlbnROb2RlO1xuXHRcdFx0XHRcdFx0XHRrICE9PSB0b2tlbkxpc3QudGFpbCAmJiAocCA8IHRvIHx8IHR5cGVvZiBrLnZhbHVlID09PSAnc3RyaW5nJyk7XG5cdFx0XHRcdFx0XHRcdGsgPSBrLm5leHRcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVDb3VudCsrO1xuXHRcdFx0XHRcdFx0XHRwICs9IGsudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVtb3ZlQ291bnQtLTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVwbGFjZSB3aXRoIHRoZSBuZXcgbWF0Y2hcblx0XHRcdFx0XHRcdHN0ciA9IHRleHQuc2xpY2UocG9zLCBwKTtcblx0XHRcdFx0XHRcdG1hdGNoLmluZGV4IC09IHBvcztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgMCwgc3RyLCBsb29rYmVoaW5kKTtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXHRcdFx0XHRcdHZhciBmcm9tID0gbWF0Y2guaW5kZXg7XG5cdFx0XHRcdFx0dmFyIG1hdGNoU3RyID0gbWF0Y2hbMF07XG5cdFx0XHRcdFx0dmFyIGJlZm9yZSA9IHN0ci5zbGljZSgwLCBmcm9tKTtcblx0XHRcdFx0XHR2YXIgYWZ0ZXIgPSBzdHIuc2xpY2UoZnJvbSArIG1hdGNoU3RyLmxlbmd0aCk7XG5cblx0XHRcdFx0XHR2YXIgcmVhY2ggPSBwb3MgKyBzdHIubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChyZW1hdGNoICYmIHJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0cmVtYXRjaC5yZWFjaCA9IHJlYWNoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciByZW1vdmVGcm9tID0gY3VycmVudE5vZGUucHJldjtcblxuXHRcdFx0XHRcdGlmIChiZWZvcmUpIHtcblx0XHRcdFx0XHRcdHJlbW92ZUZyb20gPSBhZGRBZnRlcih0b2tlbkxpc3QsIHJlbW92ZUZyb20sIGJlZm9yZSk7XG5cdFx0XHRcdFx0XHRwb3MgKz0gYmVmb3JlLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZW1vdmVSYW5nZSh0b2tlbkxpc3QsIHJlbW92ZUZyb20sIHJlbW92ZUNvdW50KTtcblxuXHRcdFx0XHRcdHZhciB3cmFwcGVkID0gbmV3IFRva2VuKHRva2VuLCBpbnNpZGUgPyBfLnRva2VuaXplKG1hdGNoU3RyLCBpbnNpZGUpIDogbWF0Y2hTdHIsIGFsaWFzLCBtYXRjaFN0cik7XG5cdFx0XHRcdFx0Y3VycmVudE5vZGUgPSBhZGRBZnRlcih0b2tlbkxpc3QsIHJlbW92ZUZyb20sIHdyYXBwZWQpO1xuXG5cdFx0XHRcdFx0aWYgKGFmdGVyKSB7XG5cdFx0XHRcdFx0XHRhZGRBZnRlcih0b2tlbkxpc3QsIGN1cnJlbnROb2RlLCBhZnRlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHJlbW92ZUNvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0Ly8gYXQgbGVhc3Qgb25lIFRva2VuIG9iamVjdCB3YXMgcmVtb3ZlZCwgc28gd2UgaGF2ZSB0byBkbyBzb21lIHJlbWF0Y2hpbmdcblx0XHRcdFx0XHRcdC8vIHRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBjdXJyZW50IHBhdHRlcm4gaXMgZ3JlZWR5XG5cblx0XHRcdFx0XHRcdC8qKiBAdHlwZSB7UmVtYXRjaE9wdGlvbnN9ICovXG5cdFx0XHRcdFx0XHR2YXIgbmVzdGVkUmVtYXRjaCA9IHtcblx0XHRcdFx0XHRcdFx0Y2F1c2U6IHRva2VuICsgJywnICsgaixcblx0XHRcdFx0XHRcdFx0cmVhY2g6IHJlYWNoXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0bWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgY3VycmVudE5vZGUucHJldiwgcG9zLCBuZXN0ZWRSZW1hdGNoKTtcblxuXHRcdFx0XHRcdFx0Ly8gdGhlIHJlYWNoIG1pZ2h0IGhhdmUgYmVlbiBleHRlbmRlZCBiZWNhdXNlIG9mIHRoZSByZW1hdGNoaW5nXG5cdFx0XHRcdFx0XHRpZiAocmVtYXRjaCAmJiBuZXN0ZWRSZW1hdGNoLnJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0XHRyZW1hdGNoLnJlYWNoID0gbmVzdGVkUmVtYXRjaC5yZWFjaDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGVkZWYgTGlua2VkTGlzdE5vZGVcblx0ICogQHByb3BlcnR5IHtUfSB2YWx1ZVxuXHQgKiBAcHJvcGVydHkge0xpbmtlZExpc3ROb2RlPFQ+IHwgbnVsbH0gcHJldiBUaGUgcHJldmlvdXMgbm9kZS5cblx0ICogQHByb3BlcnR5IHtMaW5rZWRMaXN0Tm9kZTxUPiB8IG51bGx9IG5leHQgVGhlIG5leHQgbm9kZS5cblx0ICogQHRlbXBsYXRlIFRcblx0ICogQHByaXZhdGVcblx0ICovXG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBMaW5rZWRMaXN0KCkge1xuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dmFyIGhlYWQgPSB7IHZhbHVlOiBudWxsLCBwcmV2OiBudWxsLCBuZXh0OiBudWxsIH07XG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR2YXIgdGFpbCA9IHsgdmFsdWU6IG51bGwsIHByZXY6IGhlYWQsIG5leHQ6IG51bGwgfTtcblx0XHRoZWFkLm5leHQgPSB0YWlsO1xuXG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR0aGlzLmhlYWQgPSBoZWFkO1xuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dGhpcy50YWlsID0gdGFpbDtcblx0XHR0aGlzLmxlbmd0aCA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG5ldyBub2RlIHdpdGggdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBsaXN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8VD59IGxpc3Rcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0Tm9kZTxUPn0gbm9kZVxuXHQgKiBAcGFyYW0ge1R9IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtMaW5rZWRMaXN0Tm9kZTxUPn0gVGhlIGFkZGVkIG5vZGUuXG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRBZnRlcihsaXN0LCBub2RlLCB2YWx1ZSkge1xuXHRcdC8vIGFzc3VtZXMgdGhhdCBub2RlICE9IGxpc3QudGFpbCAmJiB2YWx1ZXMubGVuZ3RoID49IDBcblx0XHR2YXIgbmV4dCA9IG5vZGUubmV4dDtcblxuXHRcdHZhciBuZXdOb2RlID0geyB2YWx1ZTogdmFsdWUsIHByZXY6IG5vZGUsIG5leHQ6IG5leHQgfTtcblx0XHRub2RlLm5leHQgPSBuZXdOb2RlO1xuXHRcdG5leHQucHJldiA9IG5ld05vZGU7XG5cdFx0bGlzdC5sZW5ndGgrKztcblxuXHRcdHJldHVybiBuZXdOb2RlO1xuXHR9XG5cdC8qKlxuXHQgKiBSZW1vdmVzIGBjb3VudGAgbm9kZXMgYWZ0ZXIgdGhlIGdpdmVuIG5vZGUuIFRoZSBnaXZlbiBub2RlIHdpbGwgbm90IGJlIHJlbW92ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdDxUPn0gbGlzdFxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3ROb2RlPFQ+fSBub2RlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlUmFuZ2UobGlzdCwgbm9kZSwgY291bnQpIHtcblx0XHR2YXIgbmV4dCA9IG5vZGUubmV4dDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICYmIG5leHQgIT09IGxpc3QudGFpbDsgaSsrKSB7XG5cdFx0XHRuZXh0ID0gbmV4dC5uZXh0O1xuXHRcdH1cblx0XHRub2RlLm5leHQgPSBuZXh0O1xuXHRcdG5leHQucHJldiA9IG5vZGU7XG5cdFx0bGlzdC5sZW5ndGggLT0gaTtcblx0fVxuXHQvKipcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG5cdCAqIEByZXR1cm5zIHtUW119XG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FycmF5KGxpc3QpIHtcblx0XHR2YXIgYXJyYXkgPSBbXTtcblx0XHR2YXIgbm9kZSA9IGxpc3QuaGVhZC5uZXh0O1xuXHRcdHdoaWxlIChub2RlICE9PSBsaXN0LnRhaWwpIHtcblx0XHRcdGFycmF5LnB1c2gobm9kZS52YWx1ZSk7XG5cdFx0XHRub2RlID0gbm9kZS5uZXh0O1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXk7XG5cdH1cblxuXHRyZXR1cm4gXztcblxufSgpKTtcblxudmFyIHByaXNtID0gUHJpc207XG5QcmlzbS5kZWZhdWx0ID0gUHJpc207XG5cbi8qIFRoaXMgY29udGVudCBpcyBhdXRvLWdlbmVyYXRlZCB0byBpbmNsdWRlIHNvbWUgcHJpc21qcyBsYW5ndWFnZSBjb21wb25lbnRzOiAqL1xuXG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1tYXJrdXBcIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvPCEtLSg/Oig/ITwhLS0pW1xcc1xcU10pKj8tLT4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAncHJvbG9nJzoge1xuICAgIHBhdHRlcm46IC88XFw/W1xcc1xcU10rP1xcPz4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnZG9jdHlwZSc6IHtcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNOVC1kb2N0eXBlZGVjbFxuICAgIHBhdHRlcm46IC88IURPQ1RZUEUoPzpbXj5cIidbXFxdXXxcIlteXCJdKlwifCdbXiddKicpKyg/OlxcWyg/OltePFwiJ1xcXV18XCJbXlwiXSpcInwnW14nXSonfDwoPyEhLS0pfDwhLS0oPzpbXi1dfC0oPyEtPikpKi0tPikqXFxdXFxzKik/Pi9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdpbnRlcm5hbC1zdWJzZXQnOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXlteXFxbXSpcXFspW1xcc1xcU10rKD89XFxdPiQpLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG5cbiAgICAgIH0sXG4gICAgICAnc3RyaW5nJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXCJbXlwiXSpcInwnW14nXSonLyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgICB9LFxuICAgICAgJ3B1bmN0dWF0aW9uJzogL148IXw+JHxbW1xcXV0vLFxuICAgICAgJ2RvY3R5cGUtdGFnJzogL15ET0NUWVBFL2ksXG4gICAgICAnbmFtZSc6IC9bXlxcczw+J1wiXSsvXG4gICAgfVxuICB9LFxuICAnY2RhdGEnOiB7XG4gICAgcGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAndGFnJzoge1xuICAgIHBhdHRlcm46IC88XFwvPyg/IVxcZClbXlxccz5cXC89JDwlXSsoPzpcXHMoPzpcXHMqW15cXHM+XFwvPV0rKD86XFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpfCg/PVtcXHMvPl0pKSkrKT9cXHMqXFwvPz4vLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICd0YWcnOiB7XG4gICAgICAgIHBhdHRlcm46IC9ePFxcLz9bXlxccz5cXC9dKy8sXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9ePFxcLz8vLFxuICAgICAgICAgICduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnc3BlY2lhbC1hdHRyJzogW10sXG4gICAgICAnYXR0ci12YWx1ZSc6IHtcbiAgICAgICAgcGF0dGVybjogLz1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKykvLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAncHVuY3R1YXRpb24nOiBbe1xuICAgICAgICAgICAgcGF0dGVybjogL149LyxcbiAgICAgICAgICAgIGFsaWFzOiAnYXR0ci1lcXVhbHMnXG4gICAgICAgICAgfSwgL1wifCcvXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLz8+LyxcbiAgICAgICdhdHRyLW5hbWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC9bXlxccz5cXC9dKy8sXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICdlbnRpdHknOiBbe1xuICAgIHBhdHRlcm46IC8mW1xcZGEtel17MSw4fTsvaSxcbiAgICBhbGlhczogJ25hbWVkLWVudGl0eSdcbiAgfSwgLyYjeD9bXFxkYS1mXXsxLDh9Oy9pXVxufTtcbnByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ3RhZyddLmluc2lkZVsnYXR0ci12YWx1ZSddLmluc2lkZVsnZW50aXR5J10gPSBwcmlzbS5sYW5ndWFnZXMubWFya3VwWydlbnRpdHknXTtcbnByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2RvY3R5cGUnXS5pbnNpZGVbJ2ludGVybmFsLXN1YnNldCddLmluc2lkZSA9IHByaXNtLmxhbmd1YWdlcy5tYXJrdXA7IC8vIFBsdWdpbiB0byBtYWtlIGVudGl0eSB0aXRsZSBzaG93IHRoZSByZWFsIGVudGl0eSwgaWRlYSBieSBSb21hbiBLb21hcm92XG5cbnByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uIChlbnYpIHtcbiAgaWYgKGVudi50eXBlID09PSAnZW50aXR5Jykge1xuICAgIGVudi5hdHRyaWJ1dGVzWyd0aXRsZSddID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCAnJicpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZywgJ2FkZElubGluZWQnLCB7XG4gIC8qKlxuICAgKiBBZGRzIGFuIGlubGluZWQgbGFuZ3VhZ2UgdG8gbWFya3VwLlxuICAgKlxuICAgKiBBbiBleGFtcGxlIG9mIGFuIGlubGluZWQgbGFuZ3VhZ2UgaXMgQ1NTIHdpdGggYDxzdHlsZT5gIHRhZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWcgdGhhdCBjb250YWlucyB0aGUgaW5saW5lZCBsYW5ndWFnZS4gVGhpcyBuYW1lIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgKiBjYXNlIGluc2Vuc2l0aXZlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZyBUaGUgbGFuZ3VhZ2Uga2V5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBhZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcbiAgICovXG4gIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmxpbmVkKHRhZ05hbWUsIGxhbmcpIHtcbiAgICB2YXIgaW5jbHVkZWRDZGF0YUluc2lkZSA9IHt9O1xuICAgIGluY2x1ZGVkQ2RhdGFJbnNpZGVbJ2xhbmd1YWdlLScgKyBsYW5nXSA9IHtcbiAgICAgIHBhdHRlcm46IC8oXjwhXFxbQ0RBVEFcXFspW1xcc1xcU10rPyg/PVxcXVxcXT4kKS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzW2xhbmddXG4gICAgfTtcbiAgICBpbmNsdWRlZENkYXRhSW5zaWRlWydjZGF0YSddID0gL148IVxcW0NEQVRBXFxbfFxcXVxcXT4kL2k7XG4gICAgdmFyIGluc2lkZSA9IHtcbiAgICAgICdpbmNsdWRlZC1jZGF0YSc6IHtcbiAgICAgICAgcGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuICAgICAgICBpbnNpZGU6IGluY2x1ZGVkQ2RhdGFJbnNpZGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGluc2lkZVsnbGFuZ3VhZ2UtJyArIGxhbmddID0ge1xuICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlc1tsYW5nXVxuICAgIH07XG4gICAgdmFyIGRlZiA9IHt9O1xuICAgIGRlZlt0YWdOYW1lXSA9IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKDxfX1tePl0qPikoPzo8IVxcW0NEQVRBXFxbKD86W15cXF1dfFxcXSg/IVxcXT4pKSpcXF1cXF0+fCg/ITwhXFxbQ0RBVEFcXFspW1xcc1xcU10pKj8oPz08XFwvX18+KS8uc291cmNlLnJlcGxhY2UoL19fL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWU7XG4gICAgICB9KSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IGluc2lkZVxuICAgIH07XG4gICAgcHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NkYXRhJywgZGVmKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRBdHRyaWJ1dGUnLCB7XG4gIC8qKlxuICAgKiBBZGRzIGFuIHBhdHRlcm4gdG8gaGlnaGxpZ2h0IGxhbmd1YWdlcyBlbWJlZGRlZCBpbiBIVE1MIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEFuIGV4YW1wbGUgb2YgYW4gaW5saW5lZCBsYW5ndWFnZSBpcyBDU1Mgd2l0aCBgc3R5bGVgIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgY29udGFpbnMgdGhlIGlubGluZWQgbGFuZ3VhZ2UuIFRoaXMgbmFtZSB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICogY2FzZSBpbnNlbnNpdGl2ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgVGhlIGxhbmd1YWdlIGtleS5cbiAgICogQGV4YW1wbGVcbiAgICogYWRkQXR0cmlidXRlKCdzdHlsZScsICdjc3MnKTtcbiAgICovXG4gIHZhbHVlOiBmdW5jdGlvbiAoYXR0ck5hbWUsIGxhbmcpIHtcbiAgICBwcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5pbnNpZGVbJ3NwZWNpYWwtYXR0ciddLnB1c2goe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXCInXFxzXSkvLnNvdXJjZSArICcoPzonICsgYXR0ck5hbWUgKyAnKScgKyAvXFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpLy5zb3VyY2UsICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdhdHRyLW5hbWUnOiAvXlteXFxzPV0rLyxcbiAgICAgICAgJ2F0dHItdmFsdWUnOiB7XG4gICAgICAgICAgcGF0dGVybjogLz1bXFxzXFxTXSsvLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3ZhbHVlJzoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiAvKF49XFxzKihbXCInXXwoPyFbXCInXSkpKVxcU1tcXHNcXFNdKig/PVxcMiQpLyxcbiAgICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICAgICAgYWxpYXM6IFtsYW5nLCAnbGFuZ3VhZ2UtJyArIGxhbmddLFxuICAgICAgICAgICAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlc1tsYW5nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IFt7XG4gICAgICAgICAgICAgIHBhdHRlcm46IC9ePS8sXG4gICAgICAgICAgICAgIGFsaWFzOiAnYXR0ci1lcXVhbHMnXG4gICAgICAgICAgICB9LCAvXCJ8Jy9dXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmh0bWwgPSBwcmlzbS5sYW5ndWFnZXMubWFya3VwO1xucHJpc20ubGFuZ3VhZ2VzLm1hdGhtbCA9IHByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5wcmlzbS5sYW5ndWFnZXMuc3ZnID0gcHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcbnByaXNtLmxhbmd1YWdlcy54bWwgPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCB7fSk7XG5wcmlzbS5sYW5ndWFnZXMuc3NtbCA9IHByaXNtLmxhbmd1YWdlcy54bWw7XG5wcmlzbS5sYW5ndWFnZXMuYXRvbSA9IHByaXNtLmxhbmd1YWdlcy54bWw7XG5wcmlzbS5sYW5ndWFnZXMucnNzID0gcHJpc20ubGFuZ3VhZ2VzLnhtbDtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWJhc2hcIiAqL1xuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIC8vICQgc2V0IHwgZ3JlcCAnXltBLVpdW15bOnNwYWNlOl1dKj0nIHwgY3V0IC1kPSAtZjEgfCB0ciAnXFxuJyAnfCdcbiAgLy8gKyBMQ19BTEwsIFJBTkRPTSwgUkVQTFksIFNFQ09ORFMuXG4gIC8vICsgbWFrZSBzdXJlIFBTMS4uNCBhcmUgaGVyZSBhcyB0aGV5IGFyZSBub3QgYWx3YXlzIHNldCxcbiAgLy8gLSBzb21lIHVzZWxlc3MgdGhpbmdzLlxuICB2YXIgZW52VmFycyA9ICdcXFxcYig/OkJBU0h8QkFTSE9QVFN8QkFTSF9BTElBU0VTfEJBU0hfQVJHQ3xCQVNIX0FSR1Z8QkFTSF9DTURTfEJBU0hfQ09NUExFVElPTl9DT01QQVRfRElSfEJBU0hfTElORU5PfEJBU0hfUkVNQVRDSHxCQVNIX1NPVVJDRXxCQVNIX1ZFUlNJTkZPfEJBU0hfVkVSU0lPTnxDT0xPUlRFUk18Q09MVU1OU3xDT01QX1dPUkRCUkVBS1N8REJVU19TRVNTSU9OX0JVU19BRERSRVNTfERFRkFVTFRTX1BBVEh8REVTS1RPUF9TRVNTSU9OfERJUlNUQUNLfERJU1BMQVl8RVVJRHxHRE1TRVNTSU9OfEdETV9MQU5HfEdOT01FX0tFWVJJTkdfQ09OVFJPTHxHTk9NRV9LRVlSSU5HX1BJRHxHUEdfQUdFTlRfSU5GT3xHUk9VUFN8SElTVENPTlRST0x8SElTVEZJTEV8SElTVEZJTEVTSVpFfEhJU1RTSVpFfEhPTUV8SE9TVE5BTUV8SE9TVFRZUEV8SUZTfElOU1RBTkNFfEpPQnxMQU5HfExBTkdVQUdFfExDX0FERFJFU1N8TENfQUxMfExDX0lERU5USUZJQ0FUSU9OfExDX01FQVNVUkVNRU5UfExDX01PTkVUQVJZfExDX05BTUV8TENfTlVNRVJJQ3xMQ19QQVBFUnxMQ19URUxFUEhPTkV8TENfVElNRXxMRVNTQ0xPU0V8TEVTU09QRU58TElORVN8TE9HTkFNRXxMU19DT0xPUlN8TUFDSFRZUEV8TUFJTENIRUNLfE1BTkRBVE9SWV9QQVRIfE5PX0FUX0JSSURHRXxPTERQV0R8T1BURVJSfE9QVElORHxPUkJJVF9TT0NLRVRESVJ8T1NUWVBFfFBBUEVSU0laRXxQQVRIfFBJUEVTVEFUVVN8UFBJRHxQUzF8UFMyfFBTM3xQUzR8UFdEfFJBTkRPTXxSRVBMWXxTRUNPTkRTfFNFTElOVVhfSU5JVHxTRVNTSU9OfFNFU1NJT05UWVBFfFNFU1NJT05fTUFOQUdFUnxTSEVMTHxTSEVMTE9QVFN8U0hMVkx8U1NIX0FVVEhfU09DS3xURVJNfFVJRHxVUFNUQVJUX0VWRU5UU3xVUFNUQVJUX0lOU1RBTkNFfFVQU1RBUlRfSk9CfFVQU1RBUlRfU0VTU0lPTnxVU0VSfFdJTkRPV0lEfFhBVVRIT1JJVFl8WERHX0NPTkZJR19ESVJTfFhER19DVVJSRU5UX0RFU0tUT1B8WERHX0RBVEFfRElSU3xYREdfR1JFRVRFUl9EQVRBX0RJUnxYREdfTUVOVV9QUkVGSVh8WERHX1JVTlRJTUVfRElSfFhER19TRUFUfFhER19TRUFUX1BBVEh8WERHX1NFU1NJT05fREVTS1RPUHxYREdfU0VTU0lPTl9JRHxYREdfU0VTU0lPTl9QQVRIfFhER19TRVNTSU9OX1RZUEV8WERHX1ZUTlJ8WE1PRElGSUVSUylcXFxcYic7XG4gIHZhciBjb21tYW5kQWZ0ZXJIZXJlZG9jID0ge1xuICAgIHBhdHRlcm46IC8oXihbXCInXT8pXFx3K1xcMilbIFxcdF0rXFxTLiovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdwdW5jdHVhdGlvbicsXG4gICAgLy8gdGhpcyBsb29rcyByZWFzb25hYmx5IHdlbGwgaW4gYWxsIHRoZW1lc1xuICAgIGluc2lkZTogbnVsbCAvLyBzZWUgYmVsb3dcblxuICB9O1xuICB2YXIgaW5zaWRlU3RyaW5nID0ge1xuICAgICdiYXNoJzogY29tbWFuZEFmdGVySGVyZWRvYyxcbiAgICAnZW52aXJvbm1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJ1xcXFwkJyArIGVudlZhcnMpLFxuICAgICAgYWxpYXM6ICdjb25zdGFudCdcbiAgICB9LFxuICAgICd2YXJpYWJsZSc6IFsvLyBbMF06IEFyaXRobWV0aWMgRW52aXJvbm1lbnRcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvXFwkP1xcKFxcKFtcXHNcXFNdKz9cXClcXCkvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgJCBzaWduIGF0IHRoZSBiZWdpbm5pbmcgaGlnaGxpZ2h0ICQoKCBhbmQgKSkgYXMgdmFyaWFibGVcbiAgICAgICAgJ3ZhcmlhYmxlJzogW3tcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5cXCRcXChcXChbXFxzXFxTXSspXFwpXFwpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sIC9eXFwkXFwoXFwoL10sXG4gICAgICAgICdudW1iZXInOiAvXFxiMHhbXFxkQS1GYS1mXStcXGJ8KD86XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrKSg/OltFZV0tP1xcZCspPy8sXG4gICAgICAgIC8vIE9wZXJhdG9ycyBhY2NvcmRpbmcgdG8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9iYXNocmVmLmh0bWwjU2hlbGwtQXJpdGhtZXRpY1xuICAgICAgICAnb3BlcmF0b3InOiAvLS18XFwrXFwrfFxcKlxcKj0/fDw8PT98Pj49P3wmJnxcXHxcXHx8Wz0hK1xcLSovJTw+XiZ8XT0/fFs/fjpdLyxcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gJCBzaWduIGF0IHRoZSBiZWdpbm5pbmcgaGlnaGxpZ2h0ICgoIGFuZCApKSBhcyBwdW5jdHVhdGlvblxuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFwoXFwoP3xcXClcXCk/fCx8Oy9cbiAgICAgIH1cbiAgICB9LCAvLyBbMV06IENvbW1hbmQgU3Vic3RpdHV0aW9uXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcJFxcKCg/OlxcKFteKV0rXFwpfFteKCldKStcXCl8YFteYF0rYC8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3ZhcmlhYmxlJzogL15cXCRcXCh8XmB8XFwpJHxgJC9cbiAgICAgIH1cbiAgICB9LCAvLyBbMl06IEJyYWNlIGV4cGFuc2lvblxuICAgIHtcbiAgICAgIHBhdHRlcm46IC9cXCRcXHtbXn1dK1xcfS8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ29wZXJhdG9yJzogLzpbLT0/K10/fFshXFwvXXwjIz98JSU/fFxcXlxcXj98LCw/LyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1tcXFtcXF1dLyxcbiAgICAgICAgJ2Vudmlyb25tZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCgnKFxcXFx7KScgKyBlbnZWYXJzKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGFsaWFzOiAnY29uc3RhbnQnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAvXFwkKD86XFx3K3xbIz8qIUAkXSkvXSxcbiAgICAvLyBFc2NhcGUgc2VxdWVuY2VzIGZyb20gZWNobyBhbmQgcHJpbnRmJ3MgbWFudWFscywgYW5kIGVzY2FwZWQgcXVvdGVzLlxuICAgICdlbnRpdHknOiAvXFxcXCg/OlthYmNlRWZucnR2XFxcXFwiXXxPP1swLTddezEsM318VVswLTlhLWZBLUZdezh9fHVbMC05YS1mQS1GXXs0fXx4WzAtOWEtZkEtRl17MSwyfSkvXG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5iYXNoID0ge1xuICAgICdzaGViYW5nJzoge1xuICAgICAgcGF0dGVybjogL14jIVxccypcXC8uKi8sXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICB9LFxuICAgICdjb21tZW50Jzoge1xuICAgICAgcGF0dGVybjogLyhefFteXCJ7XFxcXCRdKSMuKi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnZnVuY3Rpb24tbmFtZSc6IFsvLyBhKSBmdW5jdGlvbiBmb28ge1xuICAgIC8vIGIpIGZvbygpIHtcbiAgICAvLyBjKSBmdW5jdGlvbiBmb28oKSB7XG4gICAgLy8gYnV0IG5vdCDigJxmb28ge+KAnVxuICAgIHtcbiAgICAgIC8vIGEpIGFuZCBjKVxuICAgICAgcGF0dGVybjogLyhcXGJmdW5jdGlvblxccyspW1xcdy1dKyg/PSg/OlxccypcXCg/OlxccypcXCkpP1xccypcXHspLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICAgIH0sIHtcbiAgICAgIC8vIGIpXG4gICAgICBwYXR0ZXJuOiAvXFxiW1xcdy1dKyg/PVxccypcXChcXHMqXFwpXFxzKlxceykvLFxuICAgICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgICB9XSxcbiAgICAvLyBIaWdobGlnaHQgdmFyaWFibGUgbmFtZXMgYXMgdmFyaWFibGVzIGluIGZvciBhbmQgc2VsZWN0IGJlZ2lubmluZ3MuXG4gICAgJ2Zvci1vci1zZWxlY3QnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmZvcnxzZWxlY3QpXFxzKylcXHcrKD89XFxzK2luXFxzKS8sXG4gICAgICBhbGlhczogJ3ZhcmlhYmxlJyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgIC8vIEhpZ2hsaWdodCB2YXJpYWJsZSBuYW1lcyBhcyB2YXJpYWJsZXMgaW4gdGhlIGxlZnQtaGFuZCBwYXJ0XG4gICAgLy8gb2YgYXNzaWdubWVudHMgKOKAnD3igJ0gYW5kIOKAnCs94oCdKS5cbiAgICAnYXNzaWduLWxlZnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKClcXHcrKD89XFwrPz0pLyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZW52aXJvbm1lbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCcoXnxbXFxcXHM7fCZdfFs8Pl1cXFxcKCknICsgZW52VmFycyksXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBhbGlhczogJ2NvbnN0YW50J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWxpYXM6ICd2YXJpYWJsZScsXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnc3RyaW5nJzogWy8vIFN1cHBvcnQgZm9yIEhlcmUtZG9jdW1lbnRzIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlcmVfZG9jdW1lbnRcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58W148XSk8PC0/XFxzKikoXFx3KylcXHNbXFxzXFxTXSo/KD86XFxyP1xcbnxcXHIpXFwyLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IGluc2lkZVN0cmluZ1xuICAgIH0sIC8vIEhlcmUtZG9jdW1lbnQgd2l0aCBxdW90ZXMgYXJvdW5kIHRoZSB0YWdcbiAgICAvLyDihpIgTm8gZXhwYW5zaW9uIChzbyBubyDigJxpbnNpZGXigJ0pLlxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oKD86XnxbXjxdKTw8LT9cXHMqKShbXCInXSkoXFx3KylcXDJcXHNbXFxzXFxTXSo/KD86XFxyP1xcbnxcXHIpXFwzLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Jhc2gnOiBjb21tYW5kQWZ0ZXJIZXJlZG9jXG4gICAgICB9XG4gICAgfSwgLy8g4oCcTm9ybWFs4oCdIHN0cmluZ1xuICAgIHtcbiAgICAgIC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL0RvdWJsZS1RdW90ZXMuaHRtbFxuICAgICAgcGF0dGVybjogLyhefFteXFxcXF0oPzpcXFxcXFxcXCkqKVwiKD86XFxcXFtcXHNcXFNdfFxcJFxcKFteKV0rXFwpfFxcJCg/IVxcKCl8YFteYF0rYHxbXlwiXFxcXGAkXSkqXCIvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogaW5zaWRlU3RyaW5nXG4gICAgfSwge1xuICAgICAgLy8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvU2luZ2xlLVF1b3Rlcy5odG1sXG4gICAgICBwYXR0ZXJuOiAvKF58W14kXFxcXF0pJ1teJ10qJy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgLy8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvQU5TSV8wMDJkQy1RdW90aW5nLmh0bWxcbiAgICAgIHBhdHRlcm46IC9cXCQnKD86W14nXFxcXF18XFxcXFtcXHNcXFNdKSonLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZW50aXR5JzogaW5zaWRlU3RyaW5nLmVudGl0eVxuICAgICAgfVxuICAgIH1dLFxuICAgICdlbnZpcm9ubWVudCc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXFxcXCQ/JyArIGVudlZhcnMpLFxuICAgICAgYWxpYXM6ICdjb25zdGFudCdcbiAgICB9LFxuICAgICd2YXJpYWJsZSc6IGluc2lkZVN0cmluZy52YXJpYWJsZSxcbiAgICAnZnVuY3Rpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzphZGR8YXByb3Bvc3xhcHR8YXB0LWNhY2hlfGFwdC1nZXR8YXB0aXR1ZGV8YXNwZWxsfGF1dG9teXNxbGJhY2t1cHxhd2t8YmFzZW5hbWV8YmFzaHxiY3xiY29uc29sZXxiZ3xiemlwMnxjYWx8Y2F0fGNmZGlza3xjaGdycHxjaGtjb25maWd8Y2htb2R8Y2hvd258Y2hyb290fGNrc3VtfGNsZWFyfGNtcHxjb2x1bW58Y29tbXxjb21wb3NlcnxjcHxjcm9ufGNyb250YWJ8Y3NwbGl0fGN1cmx8Y3V0fGRhdGV8ZGN8ZGR8ZGRyZXNjdWV8ZGVib290c3RyYXB8ZGZ8ZGlmZnxkaWZmM3xkaWd8ZGlyfGRpcmNvbG9yc3xkaXJuYW1lfGRpcnN8ZG1lc2d8ZG9ja2VyfGRvY2tlci1jb21wb3NlfGR1fGVncmVwfGVqZWN0fGVudnxldGh0b29sfGV4cGFuZHxleHBlY3R8ZXhwcnxmZGZvcm1hdHxmZGlza3xmZ3xmZ3JlcHxmaWxlfGZpbmR8Zm10fGZvbGR8Zm9ybWF0fGZyZWV8ZnNja3xmdHB8ZnVzZXJ8Z2F3a3xnaXR8Z3BhcnRlZHxncmVwfGdyb3VwYWRkfGdyb3VwZGVsfGdyb3VwbW9kfGdyb3Vwc3xncnViLW1rY29uZmlnfGd6aXB8aGFsdHxoZWFkfGhnfGhpc3Rvcnl8aG9zdHxob3N0bmFtZXxodG9wfGljb252fGlkfGlmY29uZmlnfGlmZG93bnxpZnVwfGltcG9ydHxpbnN0YWxsfGlwfGpvYnN8am9pbnxraWxsfGtpbGxhbGx8bGVzc3xsaW5rfGxufGxvY2F0ZXxsb2duYW1lfGxvZ3JvdGF0ZXxsb29rfGxwY3xscHJ8bHByaW50fGxwcmludGR8bHByaW50cXxscHJtfGxzfGxzb2Z8bHlueHxtYWtlfG1hbnxtY3xtZGFkbXxta2NvbmZpZ3xta2Rpcnxta2UyZnN8bWtmaWZvfG1rZnN8bWtpc29mc3xta25vZHxta3N3YXB8bW12fG1vcmV8bW9zdHxtb3VudHxtdG9vbHN8bXRyfG11dHR8bXZ8bmFub3xuY3xuZXRzdGF0fG5pY2V8bmx8bm9kZXxub2h1cHxub3RpZnktc2VuZHxucG18bnNsb29rdXB8b3B8b3BlbnxwYXJ0ZWR8cGFzc3dkfHBhc3RlfHBhdGhjaGt8cGluZ3xwa2lsbHxwbnBtfHBvZG1hbnxwb2RtYW4tY29tcG9zZXxwb3BkfHByfHByaW50Y2FwfHByaW50ZW52fHBzfHB1c2hkfHB2fHF1b3RhfHF1b3RhY2hlY2t8cXVvdGFjdGx8cmFtfHJhcnxyY3B8cmVib290fHJlbXN5bmN8cmVuYW1lfHJlbmljZXxyZXZ8cm18cm1kaXJ8cnBtfHJzeW5jfHNjcHxzY3JlZW58c2RpZmZ8c2VkfHNlbmRtYWlsfHNlcXxzZXJ2aWNlfHNmdHB8c2h8c2hlbGxjaGVja3xzaHVmfHNodXRkb3dufHNsZWVwfHNsb2NhdGV8c29ydHxzcGxpdHxzc2h8c3RhdHxzdHJhY2V8c3V8c3Vkb3xzdW18c3VzcGVuZHxzd2Fwb258c3luY3x0YWN8dGFpbHx0YXJ8dGVlfHRpbWV8dGltZW91dHx0b3B8dG91Y2h8dHJ8dHJhY2Vyb3V0ZXx0c29ydHx0dHl8dW1vdW50fHVuYW1lfHVuZXhwYW5kfHVuaXF8dW5pdHN8dW5yYXJ8dW5zaGFyfHVuemlwfHVwZGF0ZS1ncnVifHVwdGltZXx1c2VyYWRkfHVzZXJkZWx8dXNlcm1vZHx1c2Vyc3x1dWRlY29kZXx1dWVuY29kZXx2fHZjcGtnfHZkaXJ8dml8dmltfHZpcnNofHZtc3RhdHx3YWl0fHdhdGNofHdjfHdnZXR8d2hlcmVpc3x3aGljaHx3aG98d2hvYW1pfHdyaXRlfHhhcmdzfHhkZy1vcGVufHlhcm58eWVzfHplbml0eXx6aXB8enNofHp5cHBlcikoPz0kfFspXFxzO3wmXSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2tleXdvcmQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpjYXNlfGRvfGRvbmV8ZWxpZnxlbHNlfGVzYWN8Zml8Zm9yfGZ1bmN0aW9ufGlmfGlufHNlbGVjdHx0aGVufHVudGlsfHdoaWxlKSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAvLyBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9TaGVsbC1CdWlsdGluLUNvbW1hbmRzLmh0bWxcbiAgICAnYnVpbHRpbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKSg/OlxcLnw6fGFsaWFzfGJpbmR8YnJlYWt8YnVpbHRpbnxjYWxsZXJ8Y2R8Y29tbWFuZHxjb250aW51ZXxkZWNsYXJlfGVjaG98ZW5hYmxlfGV2YWx8ZXhlY3xleGl0fGV4cG9ydHxnZXRvcHRzfGhhc2h8aGVscHxsZXR8bG9jYWx8bG9nb3V0fG1hcGZpbGV8cHJpbnRmfHB3ZHxyZWFkfHJlYWRhcnJheXxyZWFkb25seXxyZXR1cm58c2V0fHNoaWZ0fHNob3B0fHNvdXJjZXx0ZXN0fHRpbWVzfHRyYXB8dHlwZXx0eXBlc2V0fHVsaW1pdHx1bWFza3x1bmFsaWFzfHVuc2V0KSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgLy8gQWxpYXMgYWRkZWQgdG8gbWFrZSB0aG9zZSBlYXNpZXIgdG8gZGlzdGluZ3Vpc2ggZnJvbSBzdHJpbmdzLlxuICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICAgIH0sXG4gICAgJ2Jvb2xlYW4nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpmYWxzZXx0cnVlKSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnZmlsZS1kZXNjcmlwdG9yJzoge1xuICAgICAgcGF0dGVybjogL1xcQiZcXGRcXGIvLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgfSxcbiAgICAnb3BlcmF0b3InOiB7XG4gICAgICAvLyBMb3RzIG9mIHJlZGlyZWN0aW9ucyBoZXJlLCBidXQgbm90IGp1c3QgdGhhdC5cbiAgICAgIHBhdHRlcm46IC9cXGQ/PD58PlxcfHxcXCs9fD1bPX5dP3whPT98PDxbPC1dP3xbJlxcZF0/Pj58XFxkWzw+XSY/fFs8Pl1bJj1dP3wmWz4mXT98XFx8WyZ8XT8vLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdmaWxlLWRlc2NyaXB0b3InOiB7XG4gICAgICAgICAgcGF0dGVybjogL15cXGQvLFxuICAgICAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAncHVuY3R1YXRpb24nOiAvXFwkP1xcKFxcKD98XFwpXFwpP3xcXC5cXC58W3t9W1xcXTtcXFxcXS8sXG4gICAgJ251bWJlcic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxcXHMpKD86WzEtOV1cXGQqfDApKD86Wy4sXVxcZCspP1xcYi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfVxuICB9O1xuICBjb21tYW5kQWZ0ZXJIZXJlZG9jLmluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5iYXNoO1xuICAvKiBQYXR0ZXJucyBpbiBjb21tYW5kIHN1YnN0aXR1dGlvbi4gKi9cblxuICB2YXIgdG9CZUNvcGllZCA9IFsnY29tbWVudCcsICdmdW5jdGlvbi1uYW1lJywgJ2Zvci1vci1zZWxlY3QnLCAnYXNzaWduLWxlZnQnLCAnc3RyaW5nJywgJ2Vudmlyb25tZW50JywgJ2Z1bmN0aW9uJywgJ2tleXdvcmQnLCAnYnVpbHRpbicsICdib29sZWFuJywgJ2ZpbGUtZGVzY3JpcHRvcicsICdvcGVyYXRvcicsICdwdW5jdHVhdGlvbicsICdudW1iZXInXTtcbiAgdmFyIGluc2lkZSA9IGluc2lkZVN0cmluZy52YXJpYWJsZVsxXS5pbnNpZGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0JlQ29waWVkLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zaWRlW3RvQmVDb3BpZWRbaV1dID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2hbdG9CZUNvcGllZFtpXV07XG4gIH1cblxuICBQcmlzbS5sYW5ndWFnZXMuc2hlbGwgPSBQcmlzbS5sYW5ndWFnZXMuYmFzaDtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNsaWtlXCIgKi9cblxuXG5wcmlzbS5sYW5ndWFnZXMuY2xpa2UgPSB7XG4gICdjb21tZW50JzogW3tcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LCB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXDpdKVxcL1xcLy4qLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnY2xhc3MtbmFtZSc6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXd8dHJhaXQpXFxzK3xcXGJjYXRjaFxccytcXCgpW1xcdy5cXFxcXSsvaSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL1suXFxcXF0vXG4gICAgfVxuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzpicmVha3xjYXRjaHxjb250aW51ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fG51bGx8cmV0dXJufHRocm93fHRyeXx3aGlsZSlcXGIvLFxuICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICdmdW5jdGlvbic6IC9cXGJcXHcrKD89XFwoKS8sXG4gICdudW1iZXInOiAvXFxiMHhbXFxkYS1mXStcXGJ8KD86XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrKSg/OmVbKy1dP1xcZCspPy9pLFxuICAnb3BlcmF0b3InOiAvWzw+XT0/fFshPV09Pz0/fC0tP3xcXCtcXCs/fCYmP3xcXHxcXHw/fFs/Ki9+XiVdLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1t7fVtcXF07KCksLjpdL1xufTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNcIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMuYyA9IHByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvXFwvXFwvKD86W15cXHJcXG5cXFxcXXxcXFxcKD86XFxyXFxuP3xcXG58KD8hW1xcclxcbl0pKSkqfFxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnc3RyaW5nJzoge1xuICAgIC8vIGh0dHBzOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2MvbGFuZ3VhZ2Uvc3RyaW5nX2xpdGVyYWxcbiAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwiLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgcGF0dGVybjogLyhcXGIoPzplbnVtfHN0cnVjdClcXHMrKD86X19hdHRyaWJ1dGVfX1xccypcXChcXChbXFxzXFxTXSo/XFwpXFwpXFxzKik/KVxcdyt8XFxiW2Etel1cXHcqX3RcXGIvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86X0FsaWduYXN8X0FsaWdub2Z8X0F0b21pY3xfQm9vbHxfQ29tcGxleHxfR2VuZXJpY3xfSW1hZ2luYXJ5fF9Ob3JldHVybnxfU3RhdGljX2Fzc2VydHxfVGhyZWFkX2xvY2FsfF9fYXR0cmlidXRlX198YXNtfGF1dG98YnJlYWt8Y2FzZXxjaGFyfGNvbnN0fGNvbnRpbnVlfGRlZmF1bHR8ZG98ZG91YmxlfGVsc2V8ZW51bXxleHRlcm58ZmxvYXR8Zm9yfGdvdG98aWZ8aW5saW5lfGludHxsb25nfHJlZ2lzdGVyfHJldHVybnxzaG9ydHxzaWduZWR8c2l6ZW9mfHN0YXRpY3xzdHJ1Y3R8c3dpdGNofHR5cGVkZWZ8dHlwZW9mfHVuaW9ufHVuc2lnbmVkfHZvaWR8dm9sYXRpbGV8d2hpbGUpXFxiLyxcbiAgJ2Z1bmN0aW9uJzogL1xcYlthLXpfXVxcdyooPz1cXHMqXFwoKS9pLFxuICAnbnVtYmVyJzogLyg/OlxcYjB4KD86W1xcZGEtZl0rKD86XFwuW1xcZGEtZl0qKT98XFwuW1xcZGEtZl0rKSg/OnBbKy1dP1xcZCspP3woPzpcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86ZVsrLV0/XFxkKyk/KVtmdWxdezAsNH0vaSxcbiAgJ29wZXJhdG9yJzogLz4+PT98PDw9P3wtPnwoWy0rJnw6XSlcXDF8Wz86fl18Wy0rKi8lJnxeIT08Pl09Py9cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnYycsICdzdHJpbmcnLCB7XG4gICdjaGFyJzoge1xuICAgIC8vIGh0dHBzOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2MvbGFuZ3VhZ2UvY2hhcmFjdGVyX2NvbnN0YW50XG4gICAgcGF0dGVybjogLycoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXidcXFxcXFxyXFxuXSl7MCwzMn0nLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfVxufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjJywgJ3N0cmluZycsIHtcbiAgJ21hY3JvJzoge1xuICAgIC8vIGFsbG93IGZvciBtdWx0aWxpbmUgbWFjcm8gZGVmaW5pdGlvbnNcbiAgICAvLyBzcGFjZXMgYWZ0ZXIgdGhlICMgY2hhcmFjdGVyIGNvbXBpbGUgZmluZSB3aXRoIGdjY1xuICAgIHBhdHRlcm46IC8oXltcXHQgXSopI1xccypbYS16XSg/OlteXFxyXFxuXFxcXC9dfFxcLyg/IVxcKil8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC98XFxcXCg/OlxcclxcbnxbXFxzXFxTXSkpKi9pbSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBhbGlhczogJ3Byb3BlcnR5JyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdzdHJpbmcnOiBbe1xuICAgICAgICAvLyBoaWdobGlnaHQgdGhlIHBhdGggb2YgdGhlIGluY2x1ZGUgc3RhdGVtZW50IGFzIGEgc3RyaW5nXG4gICAgICAgIHBhdHRlcm46IC9eKCNcXHMqaW5jbHVkZVxccyopPFtePl0rPi8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgIH0sIHByaXNtLmxhbmd1YWdlcy5jWydzdHJpbmcnXV0sXG4gICAgICAnY2hhcic6IHByaXNtLmxhbmd1YWdlcy5jWydjaGFyJ10sXG4gICAgICAnY29tbWVudCc6IHByaXNtLmxhbmd1YWdlcy5jWydjb21tZW50J10sXG4gICAgICAnbWFjcm8tbmFtZSc6IFt7XG4gICAgICAgIHBhdHRlcm46IC8oXiNcXHMqZGVmaW5lXFxzKylcXHcrXFxiKD8hXFwoKS9pLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHBhdHRlcm46IC8oXiNcXHMqZGVmaW5lXFxzKylcXHcrXFxiKD89XFwoKS9pLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICAgICAgfV0sXG4gICAgICAvLyBoaWdobGlnaHQgbWFjcm8gZGlyZWN0aXZlcyBhcyBrZXl3b3Jkc1xuICAgICAgJ2RpcmVjdGl2ZSc6IHtcbiAgICAgICAgcGF0dGVybjogL14oI1xccyopW2Etel0rLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdrZXl3b3JkJ1xuICAgICAgfSxcbiAgICAgICdkaXJlY3RpdmUtaGFzaCc6IC9eIy8sXG4gICAgICAncHVuY3R1YXRpb24nOiAvIyN8XFxcXCg/PVtcXHJcXG5dKS8sXG4gICAgICAnZXhwcmVzc2lvbic6IHtcbiAgICAgICAgcGF0dGVybjogL1xcU1tcXHNcXFNdKi8sXG4gICAgICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzLmNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnYycsICdmdW5jdGlvbicsIHtcbiAgLy8gaGlnaGxpZ2h0IHByZWRlZmluZWQgbWFjcm9zIGFzIGNvbnN0YW50c1xuICAnY29uc3RhbnQnOiAvXFxiKD86RU9GfE5VTEx8U0VFS19DVVJ8U0VFS19FTkR8U0VFS19TRVR8X19EQVRFX198X19GSUxFX198X19MSU5FX198X19USU1FU1RBTVBfX3xfX1RJTUVfX3xfX2Z1bmNfX3xzdGRlcnJ8c3RkaW58c3Rkb3V0KVxcYi9cbn0pO1xuZGVsZXRlIHByaXNtLmxhbmd1YWdlcy5jWydib29sZWFuJ107XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jcHBcIiAqL1xuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciBrZXl3b3JkID0gL1xcYig/OmFsaWduYXN8YWxpZ25vZnxhc218YXV0b3xib29sfGJyZWFrfGNhc2V8Y2F0Y2h8Y2hhcnxjaGFyMTZfdHxjaGFyMzJfdHxjaGFyOF90fGNsYXNzfGNvX2F3YWl0fGNvX3JldHVybnxjb195aWVsZHxjb21wbHxjb25jZXB0fGNvbnN0fGNvbnN0X2Nhc3R8Y29uc3RldmFsfGNvbnN0ZXhwcnxjb25zdGluaXR8Y29udGludWV8ZGVjbHR5cGV8ZGVmYXVsdHxkZWxldGV8ZG98ZG91YmxlfGR5bmFtaWNfY2FzdHxlbHNlfGVudW18ZXhwbGljaXR8ZXhwb3J0fGV4dGVybnxmaW5hbHxmbG9hdHxmb3J8ZnJpZW5kfGdvdG98aWZ8aW1wb3J0fGlubGluZXxpbnR8aW50MTZfdHxpbnQzMl90fGludDY0X3R8aW50OF90fGxvbmd8bW9kdWxlfG11dGFibGV8bmFtZXNwYWNlfG5ld3xub2V4Y2VwdHxudWxscHRyfG9wZXJhdG9yfG92ZXJyaWRlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZWdpc3RlcnxyZWludGVycHJldF9jYXN0fHJlcXVpcmVzfHJldHVybnxzaG9ydHxzaWduZWR8c2l6ZW9mfHN0YXRpY3xzdGF0aWNfYXNzZXJ0fHN0YXRpY19jYXN0fHN0cnVjdHxzd2l0Y2h8dGVtcGxhdGV8dGhpc3x0aHJlYWRfbG9jYWx8dGhyb3d8dHJ5fHR5cGVkZWZ8dHlwZWlkfHR5cGVuYW1lfHVpbnQxNl90fHVpbnQzMl90fHVpbnQ2NF90fHVpbnQ4X3R8dW5pb258dW5zaWduZWR8dXNpbmd8dmlydHVhbHx2b2lkfHZvbGF0aWxlfHdjaGFyX3R8d2hpbGUpXFxiLztcbiAgdmFyIG1vZE5hbWUgPSAvXFxiKD8hPGtleXdvcmQ+KVxcdysoPzpcXHMqXFwuXFxzKlxcdyspKlxcYi8uc291cmNlLnJlcGxhY2UoLzxrZXl3b3JkPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGtleXdvcmQuc291cmNlO1xuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmNwcCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2MnLCB7XG4gICAgJ2NsYXNzLW5hbWUnOiBbe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXFxiKD86Y2xhc3N8Y29uY2VwdHxlbnVtfHN0cnVjdHx0eXBlbmFtZSlcXHMrKSg/ITxrZXl3b3JkPilcXHcrLy5zb3VyY2UucmVwbGFjZSgvPGtleXdvcmQ+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGtleXdvcmQuc291cmNlO1xuICAgICAgfSkpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIC8vIFRoaXMgaXMgaW50ZW5kZWQgdG8gY2FwdHVyZSB0aGUgY2xhc3MgbmFtZSBvZiBtZXRob2QgaW1wbGVtZW50YXRpb25zIGxpa2U6XG4gICAgLy8gICB2b2lkIGZvbzo6YmFyKCkgY29uc3Qge31cbiAgICAvLyBIb3dldmVyISBUaGUgYGZvb2AgaW4gdGhlIGFib3ZlIGV4YW1wbGUgY291bGQgYWxzbyBiZSBhIG5hbWVzcGFjZSwgc28gd2Ugb25seSBjYXB0dXJlIHRoZSBjbGFzcyBuYW1lIGlmXG4gICAgLy8gaXQgc3RhcnRzIHdpdGggYW4gdXBwZXJjYXNlIGxldHRlci4gVGhpcyBhcHByb3hpbWF0aW9uIHNob3VsZCBnaXZlIGRlY2VudCByZXN1bHRzLlxuICAgIC9cXGJbQS1aXVxcdyooPz1cXHMqOjpcXHMqXFx3K1xccypcXCgpLywgLy8gVGhpcyB3aWxsIGNhcHR1cmUgdGhlIGNsYXNzIG5hbWUgYmVmb3JlIGRlc3RydWN0b3JzIGxpa2U6XG4gICAgLy8gICBGb286On5Gb28oKSB7fVxuICAgIC9cXGJbQS1aX11cXHcqKD89XFxzKjo6XFxzKn5cXHcrXFxzKlxcKCkvaSwgLy8gVGhpcyBhbHNvIGludGVuZHMgdG8gY2FwdHVyZSB0aGUgY2xhc3MgbmFtZSBvZiBtZXRob2QgaW1wbGVtZW50YXRpb25zIGJ1dCBoZXJlIHRoZSBjbGFzcyBoYXMgdGVtcGxhdGVcbiAgICAvLyBwYXJhbWV0ZXJzLCBzbyBpdCBjYW4ndCBiZSBhIG5hbWVzcGFjZSAodW50aWwgQysrIGFkZHMgZ2VuZXJpYyBuYW1lc3BhY2VzKS5cbiAgICAvXFxiXFx3Kyg/PVxccyo8KD86W148Pl18PCg/OltePD5dfDxbXjw+XSo+KSo+KSo+XFxzKjo6XFxzKlxcdytcXHMqXFwoKS9dLFxuICAgICdrZXl3b3JkJzoga2V5d29yZCxcbiAgICAnbnVtYmVyJzoge1xuICAgICAgcGF0dGVybjogLyg/OlxcYjBiWzAxJ10rfFxcYjB4KD86W1xcZGEtZiddKyg/OlxcLltcXGRhLWYnXSopP3xcXC5bXFxkYS1mJ10rKSg/OnBbKy1dP1tcXGQnXSspP3woPzpcXGJbXFxkJ10rKD86XFwuW1xcZCddKik/fFxcQlxcLltcXGQnXSspKD86ZVsrLV0/W1xcZCddKyk/KVtmdWxdezAsNH0vaSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sXG4gICAgJ29wZXJhdG9yJzogLz4+PT98PDw9P3wtPnwtLXxcXCtcXCt8JiZ8XFx8XFx8fFs/On5dfDw9PnxbLSsqLyUmfF4hPTw+XT0/fFxcYig/OmFuZHxhbmRfZXF8Yml0YW5kfGJpdG9yfG5vdHxub3RfZXF8b3J8b3JfZXF8eG9yfHhvcl9lcSlcXGIvLFxuICAgICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiL1xuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3BwJywgJ3N0cmluZycsIHtcbiAgICAnbW9kdWxlJzoge1xuICAgICAgLy8gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL21vZHVsZXNcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKFxcYig/OmltcG9ydHxtb2R1bGUpXFxzKykvLnNvdXJjZSArICcoPzonICsgLy8gaGVhZGVyLW5hbWVcbiAgICAgIC9cIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCJ8PFtePD5cXHJcXG5dKj4vLnNvdXJjZSArICd8JyArIC8vIG1vZHVsZSBuYW1lIG9yIHBhcnRpdGlvbiBvciBib3RoXG4gICAgICAvPG1vZC1uYW1lPig/Olxccyo6XFxzKjxtb2QtbmFtZT4pP3w6XFxzKjxtb2QtbmFtZT4vLnNvdXJjZS5yZXBsYWNlKC88bW9kLW5hbWU+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vZE5hbWU7XG4gICAgICB9KSArICcpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdzdHJpbmcnOiAvXls8XCJdW1xcc1xcU10rLyxcbiAgICAgICAgJ29wZXJhdG9yJzogLzovLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFwuL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3Jhdy1zdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiAvUlwiKFteKClcXFxcIF17MCwxNn0pXFwoW1xcc1xcU10qP1xcKVxcMVwiLyxcbiAgICAgIGFsaWFzOiAnc3RyaW5nJyxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdrZXl3b3JkJywge1xuICAgICdnZW5lcmljLWZ1bmN0aW9uJzoge1xuICAgICAgcGF0dGVybjogL1xcYig/IW9wZXJhdG9yXFxiKVthLXpfXVxcdypcXHMqPCg/OltePD5dfDxbXjw+XSo+KSo+KD89XFxzKlxcKCkvaSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZnVuY3Rpb24nOiAvXlxcdysvLFxuICAgICAgICAnZ2VuZXJpYyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvPFtcXHNcXFNdKy8sXG4gICAgICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJyxcbiAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jcHBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdvcGVyYXRvcicsIHtcbiAgICAnZG91YmxlLWNvbG9uJzoge1xuICAgICAgcGF0dGVybjogLzo6LyxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3BwJywgJ2NsYXNzLW5hbWUnLCB7XG4gICAgLy8gdGhlIGJhc2UgY2xhdXNlIGlzIGFuIG9wdGlvbmFsIGxpc3Qgb2YgcGFyZW50IGNsYXNzZXNcbiAgICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvbGFuZ3VhZ2UvY2xhc3NcbiAgICAnYmFzZS1jbGF1c2UnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfHN0cnVjdClcXHMrXFx3K1xccyo6XFxzKilbXjt7fVwiJ1xcc10rKD86XFxzK1teO3t9XCInXFxzXSspKig/PVxccypbO3tdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjcHAnLCB7fSlcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdpbnNpZGUnLCAnZG91YmxlLWNvbG9uJywge1xuICAgIC8vIEFsbCB1bnRva2VuaXplZCB3b3JkcyB0aGF0IGFyZSBub3QgbmFtZXNwYWNlcyBzaG91bGQgYmUgY2xhc3MgbmFtZXNcbiAgICAnY2xhc3MtbmFtZSc6IC9cXGJbYS16X11cXHcqXFxiKD8hXFxzKjo6KS9pXG4gIH0sIFByaXNtLmxhbmd1YWdlcy5jcHBbJ2Jhc2UtY2xhdXNlJ10pO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY3NzXCIgKi9cblxuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciBzdHJpbmcgPSAvKD86XCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwifCcoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXidcXFxcXFxyXFxuXSkqJykvO1xuICBQcmlzbS5sYW5ndWFnZXMuY3NzID0ge1xuICAgICdjb21tZW50JzogL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vLFxuICAgICdhdHJ1bGUnOiB7XG4gICAgICBwYXR0ZXJuOiAvQFtcXHctXSg/OlteO3tcXHNdfFxccysoPyFbXFxze10pKSooPzo7fCg/PVxccypcXHspKS8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3J1bGUnOiAvXkBbXFx3LV0rLyxcbiAgICAgICAgJ3NlbGVjdG9yLWZ1bmN0aW9uLWFyZ3VtZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXFxic2VsZWN0b3JcXHMqXFwoXFxzKig/IVtcXHMpXSkpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCkpKyg/PVxccypcXCkpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGFsaWFzOiAnc2VsZWN0b3InXG4gICAgICAgIH0sXG4gICAgICAgICdrZXl3b3JkJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXnxbXlxcdy1dKSg/OmFuZHxub3R8b25seXxvcikoPyFbXFx3LV0pLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0gLy8gU2VlIHJlc3QgYmVsb3dcblxuICAgICAgfVxuICAgIH0sXG4gICAgJ3VybCc6IHtcbiAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXFxcXGJ1cmxcXFxcKCg/OicgKyBzdHJpbmcuc291cmNlICsgJ3wnICsgLyg/OlteXFxcXFxcclxcbigpXCInXXxcXFxcW1xcc1xcU10pKi8uc291cmNlICsgJylcXFxcKScsICdpJyksXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Z1bmN0aW9uJzogL151cmwvaSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL15cXCh8XFwpJC8sXG4gICAgICAgICdzdHJpbmcnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCdeJyArIHN0cmluZy5zb3VyY2UgKyAnJCcpLFxuICAgICAgICAgIGFsaWFzOiAndXJsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnc2VsZWN0b3InOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJyhefFt7fVxcXFxzXSlbXnt9XFxcXHNdKD86W157fTtcIlxcJ1xcXFxzXXxcXFxccysoPyFbXFxcXHN7XSl8JyArIHN0cmluZy5zb3VyY2UgKyAnKSooPz1cXFxccypcXFxceyknKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdzdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiBzdHJpbmcsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdwcm9wZXJ0eSc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXi1cXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpWy1fYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWy1cXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnaW1wb3J0YW50JzogLyFpbXBvcnRhbnRcXGIvaSxcbiAgICAnZnVuY3Rpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14tYS16MC05XSlbLWEtejAtOV0rKD89XFwoKS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ3B1bmN0dWF0aW9uJzogL1soKXt9OzosXS9cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmNzc1snYXRydWxlJ10uaW5zaWRlLnJlc3QgPSBQcmlzbS5sYW5ndWFnZXMuY3NzO1xuICB2YXIgbWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuICBpZiAobWFya3VwKSB7XG4gICAgbWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcbiAgICBtYXJrdXAudGFnLmFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG4gIH1cbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNzcy1leHRyYXNcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIHN0cmluZyA9IC8oXCJ8JykoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLztcbiAgdmFyIHNlbGVjdG9ySW5zaWRlO1xuICBQcmlzbS5sYW5ndWFnZXMuY3NzLnNlbGVjdG9yID0ge1xuICAgIHBhdHRlcm46IFByaXNtLmxhbmd1YWdlcy5jc3Muc2VsZWN0b3IucGF0dGVybixcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogc2VsZWN0b3JJbnNpZGUgPSB7XG4gICAgICAncHNldWRvLWVsZW1lbnQnOiAvOig/OmFmdGVyfGJlZm9yZXxmaXJzdC1sZXR0ZXJ8Zmlyc3QtbGluZXxzZWxlY3Rpb24pfDo6Wy1cXHddKy8sXG4gICAgICAncHNldWRvLWNsYXNzJzogLzpbLVxcd10rLyxcbiAgICAgICdjbGFzcyc6IC9cXC5bLVxcd10rLyxcbiAgICAgICdpZCc6IC8jWy1cXHddKy8sXG4gICAgICAnYXR0cmlidXRlJzoge1xuICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ1xcXFxbKD86W15bXFxcXF1cIlxcJ118JyArIHN0cmluZy5zb3VyY2UgKyAnKSpcXFxcXScpLFxuICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9eXFxbfFxcXSQvLFxuICAgICAgICAgICdjYXNlLXNlbnNpdGl2aXR5Jzoge1xuICAgICAgICAgICAgcGF0dGVybjogLyhcXHMpW3NpXSQvaSxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnbmFtZXNwYWNlJzoge1xuICAgICAgICAgICAgcGF0dGVybjogL14oXFxzKikoPzooPyFcXHMpWy0qXFx3XFx4QTAtXFx1RkZGRl0pKlxcfCg/IT0pLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcfCQvXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnYXR0ci1uYW1lJzoge1xuICAgICAgICAgICAgcGF0dGVybjogL14oXFxzKikoPzooPyFcXHMpWy1cXHdcXHhBMC1cXHVGRkZGXSkrLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgICdhdHRyLXZhbHVlJzogW3N0cmluZywge1xuICAgICAgICAgICAgcGF0dGVybjogLyg9XFxzKikoPzooPyFcXHMpWy1cXHdcXHhBMC1cXHVGRkZGXSkrKD89XFxzKiQpLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgICB9XSxcbiAgICAgICAgICAnb3BlcmF0b3InOiAvW3x+Kl4kXT89L1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ24tdGgnOiBbe1xuICAgICAgICBwYXR0ZXJuOiAvKFxcKFxccyopWystXT9cXGQqW1xcZG5dKD86XFxzKlsrLV1cXHMqXFxkKyk/KD89XFxzKlxcKSkvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAnbnVtYmVyJzogL1tcXGRuXSsvLFxuICAgICAgICAgICdvcGVyYXRvcic6IC9bKy1dL1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHBhdHRlcm46IC8oXFwoXFxzKikoPzpldmVufG9kZCkoPz1cXHMqXFwpKS9pLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICB9XSxcbiAgICAgICdjb21iaW5hdG9yJzogLz58XFwrfH58XFx8XFx8LyxcbiAgICAgIC8vIHRoZSBgdGFnYCB0b2tlbiBoYXMgYmVlbiBleGlzdGVkIGFuZCByZW1vdmVkLlxuICAgICAgLy8gYmVjYXVzZSB3ZSBjYW4ndCBmaW5kIGEgcGVyZmVjdCB0b2tlbml6ZSB0byBtYXRjaCBpdC5cbiAgICAgIC8vIGlmIHlvdSB3YW50IHRvIGFkZCBpdCwgcGxlYXNlIHJlYWQgaHR0cHM6Ly9naXRodWIuY29tL1ByaXNtSlMvcHJpc20vcHVsbC8yMzczIGZpcnN0LlxuICAgICAgJ3B1bmN0dWF0aW9uJzogL1soKSxdL1xuICAgIH1cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmNzc1snYXRydWxlJ10uaW5zaWRlWydzZWxlY3Rvci1mdW5jdGlvbi1hcmd1bWVudCddLmluc2lkZSA9IHNlbGVjdG9ySW5zaWRlO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjc3MnLCAncHJvcGVydHknLCB7XG4gICAgJ3ZhcmlhYmxlJzoge1xuICAgICAgcGF0dGVybjogLyhefFteLVxcd1xceEEwLVxcdUZGRkZdKS0tKD8hXFxzKVstX2EtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVstXFx3XFx4QTAtXFx1RkZGRl0pKi9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bml0ID0ge1xuICAgIHBhdHRlcm46IC8oXFxiXFxkKykoPzolfFthLXpdKyg/IVtcXHctXSkpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH07IC8vIDEyMyAtMTIzIC4xMjMgLS4xMjMgMTIuMyAtMTIuM1xuXG4gIHZhciBudW1iZXIgPSB7XG4gICAgcGF0dGVybjogLyhefFteXFx3Li1dKS0/KD86XFxkKyg/OlxcLlxcZCspP3xcXC5cXGQrKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjc3MnLCAnZnVuY3Rpb24nLCB7XG4gICAgJ29wZXJhdG9yJzoge1xuICAgICAgcGF0dGVybjogLyhcXHMpWytcXC0qXFwvXSg/PVxccykvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gQ0FSRUZVTCFcbiAgICAvLyBQcmV2aWV3ZXJzIGFuZCBJbmxpbmUgY29sb3IgdXNlIGhleGNvZGUgYW5kIGNvbG9yLlxuICAgICdoZXhjb2RlJzoge1xuICAgICAgcGF0dGVybjogL1xcQiNbXFxkYS1mXXszLDh9XFxiL2ksXG4gICAgICBhbGlhczogJ2NvbG9yJ1xuICAgIH0sXG4gICAgJ2NvbG9yJzogW3tcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcdy1dKSg/OkFsaWNlQmx1ZXxBbnRpcXVlV2hpdGV8QXF1YXxBcXVhbWFyaW5lfEF6dXJlfEJlaWdlfEJpc3F1ZXxCbGFja3xCbGFuY2hlZEFsbW9uZHxCbHVlfEJsdWVWaW9sZXR8QnJvd258QnVybHlXb29kfENhZGV0Qmx1ZXxDaGFydHJldXNlfENob2NvbGF0ZXxDb3JhbHxDb3JuZmxvd2VyQmx1ZXxDb3Juc2lsa3xDcmltc29ufEN5YW58RGFya0JsdWV8RGFya0N5YW58RGFya0dvbGRlblJvZHxEYXJrR3JbYWVdeXxEYXJrR3JlZW58RGFya0toYWtpfERhcmtNYWdlbnRhfERhcmtPbGl2ZUdyZWVufERhcmtPcmFuZ2V8RGFya09yY2hpZHxEYXJrUmVkfERhcmtTYWxtb258RGFya1NlYUdyZWVufERhcmtTbGF0ZUJsdWV8RGFya1NsYXRlR3JbYWVdeXxEYXJrVHVycXVvaXNlfERhcmtWaW9sZXR8RGVlcFBpbmt8RGVlcFNreUJsdWV8RGltR3JbYWVdeXxEb2RnZXJCbHVlfEZpcmVCcmlja3xGbG9yYWxXaGl0ZXxGb3Jlc3RHcmVlbnxGdWNoc2lhfEdhaW5zYm9yb3xHaG9zdFdoaXRlfEdvbGR8R29sZGVuUm9kfEdyW2FlXXl8R3JlZW58R3JlZW5ZZWxsb3d8SG9uZXlEZXd8SG90UGlua3xJbmRpYW5SZWR8SW5kaWdvfEl2b3J5fEtoYWtpfExhdmVuZGVyfExhdmVuZGVyQmx1c2h8TGF3bkdyZWVufExlbW9uQ2hpZmZvbnxMaWdodEJsdWV8TGlnaHRDb3JhbHxMaWdodEN5YW58TGlnaHRHb2xkZW5Sb2RZZWxsb3d8TGlnaHRHclthZV15fExpZ2h0R3JlZW58TGlnaHRQaW5rfExpZ2h0U2FsbW9ufExpZ2h0U2VhR3JlZW58TGlnaHRTa3lCbHVlfExpZ2h0U2xhdGVHclthZV15fExpZ2h0U3RlZWxCbHVlfExpZ2h0WWVsbG93fExpbWV8TGltZUdyZWVufExpbmVufE1hZ2VudGF8TWFyb29ufE1lZGl1bUFxdWFNYXJpbmV8TWVkaXVtQmx1ZXxNZWRpdW1PcmNoaWR8TWVkaXVtUHVycGxlfE1lZGl1bVNlYUdyZWVufE1lZGl1bVNsYXRlQmx1ZXxNZWRpdW1TcHJpbmdHcmVlbnxNZWRpdW1UdXJxdW9pc2V8TWVkaXVtVmlvbGV0UmVkfE1pZG5pZ2h0Qmx1ZXxNaW50Q3JlYW18TWlzdHlSb3NlfE1vY2Nhc2lufE5hdmFqb1doaXRlfE5hdnl8T2xkTGFjZXxPbGl2ZXxPbGl2ZURyYWJ8T3JhbmdlfE9yYW5nZVJlZHxPcmNoaWR8UGFsZUdvbGRlblJvZHxQYWxlR3JlZW58UGFsZVR1cnF1b2lzZXxQYWxlVmlvbGV0UmVkfFBhcGF5YVdoaXB8UGVhY2hQdWZmfFBlcnV8UGlua3xQbHVtfFBvd2RlckJsdWV8UHVycGxlfFJlZHxSb3N5QnJvd258Um95YWxCbHVlfFNhZGRsZUJyb3dufFNhbG1vbnxTYW5keUJyb3dufFNlYUdyZWVufFNlYVNoZWxsfFNpZW5uYXxTaWx2ZXJ8U2t5Qmx1ZXxTbGF0ZUJsdWV8U2xhdGVHclthZV15fFNub3d8U3ByaW5nR3JlZW58U3RlZWxCbHVlfFRhbnxUZWFsfFRoaXN0bGV8VG9tYXRvfFRyYW5zcGFyZW50fFR1cnF1b2lzZXxWaW9sZXR8V2hlYXR8V2hpdGV8V2hpdGVTbW9rZXxZZWxsb3d8WWVsbG93R3JlZW4pKD8hW1xcdy1dKS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC9cXGIoPzpoc2x8cmdiKVxcKFxccypcXGR7MSwzfVxccyosXFxzKlxcZHsxLDN9JT9cXHMqLFxccypcXGR7MSwzfSU/XFxzKlxcKVxcQnxcXGIoPzpoc2x8cmdiKWFcXChcXHMqXFxkezEsM31cXHMqLFxccypcXGR7MSwzfSU/XFxzKixcXHMqXFxkezEsM30lP1xccyosXFxzKig/OjB8MD9cXC5cXGQrfDEpXFxzKlxcKVxcQi9pLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICd1bml0JzogdW5pdCxcbiAgICAgICAgJ251bWJlcic6IG51bWJlcixcbiAgICAgICAgJ2Z1bmN0aW9uJzogL1tcXHctXSsoPz1cXCgpLyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1soKSxdL1xuICAgICAgfVxuICAgIH1dLFxuICAgIC8vIGl0J3MgaW1wb3J0YW50IHRoYXQgdGhlcmUgaXMgbm8gYm91bmRhcnkgYXNzZXJ0aW9uIGFmdGVyIHRoZSBoZXggZGlnaXRzXG4gICAgJ2VudGl0eSc6IC9cXFxcW1xcZGEtZl17MSw4fS9pLFxuICAgICd1bml0JzogdW5pdCxcbiAgICAnbnVtYmVyJzogbnVtYmVyXG4gIH0pO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tamF2YXNjcmlwdFwiICovXG5cblxucHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQgPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgJ2NsYXNzLW5hbWUnOiBbcHJpc20ubGFuZ3VhZ2VzLmNsaWtlWydjbGFzcy1uYW1lJ10sIHtcbiAgICBwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJEEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxcLig/OmNvbnN0cnVjdG9yfHByb3RvdHlwZSkpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dLFxuICAna2V5d29yZCc6IFt7XG4gICAgcGF0dGVybjogLygoPzpefFxcfSlcXHMqKWNhdGNoXFxiLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKF58W14uXXxcXC5cXC5cXC5cXHMqKVxcYig/OmFzfGFzc2VydCg/PVxccypcXHspfGFzeW5jKD89XFxzKig/OmZ1bmN0aW9uXFxifFxcKHxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxhd2FpdHxicmVha3xjYXNlfGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5KD89XFxzKig/Olxce3wkKSl8Zm9yfGZyb20oPz1cXHMqKD86WydcIl18JCkpfGZ1bmN0aW9ufCg/OmdldHxzZXQpKD89XFxzKig/OlsjXFxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKVxcYi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XSxcbiAgLy8gQWxsb3cgZm9yIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycyAoU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMDg0NDQpXG4gICdmdW5jdGlvbic6IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqKD86XFwuXFxzKig/OmFwcGx5fGJpbmR8Y2FsbClcXHMqKT9cXCgpLyxcbiAgJ251bWJlcic6IHtcbiAgICBwYXR0ZXJuOiBSZWdFeHAoLyhefFteXFx3JF0pLy5zb3VyY2UgKyAnKD86JyArICggLy8gY29uc3RhbnRcbiAgICAvTmFOfEluZmluaXR5Ly5zb3VyY2UgKyAnfCcgKyAvLyBiaW5hcnkgaW50ZWdlclxuICAgIC8wW2JCXVswMV0rKD86X1swMV0rKSpuPy8uc291cmNlICsgJ3wnICsgLy8gb2N0YWwgaW50ZWdlclxuICAgIC8wW29PXVswLTddKyg/Ol9bMC03XSspKm4/Ly5zb3VyY2UgKyAnfCcgKyAvLyBoZXhhZGVjaW1hbCBpbnRlZ2VyXG4gICAgLzBbeFhdW1xcZEEtRmEtZl0rKD86X1tcXGRBLUZhLWZdKykqbj8vLnNvdXJjZSArICd8JyArIC8vIGRlY2ltYWwgYmlnaW50XG4gICAgL1xcZCsoPzpfXFxkKykqbi8uc291cmNlICsgJ3wnICsgLy8gZGVjaW1hbCBudW1iZXIgKGludGVnZXIgb3IgZmxvYXQpIGJ1dCBubyBiaWdpbnRcbiAgICAvKD86XFxkKyg/Ol9cXGQrKSooPzpcXC4oPzpcXGQrKD86X1xcZCspKik/KT98XFwuXFxkKyg/Ol9cXGQrKSopKD86W0VlXVsrLV0/XFxkKyg/Ol9cXGQrKSopPy8uc291cmNlKSArICcpJyArIC8oPyFbXFx3JF0pLy5zb3VyY2UpLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ29wZXJhdG9yJzogLy0tfFxcK1xcK3xcXCpcXCo9P3w9PnwmJj0/fFxcfFxcfD0/fFshPV09PXw8PD0/fD4+Pj89P3xbLSsqLyUmfF4hPTw+XT0/fFxcLnszfXxcXD9cXD89P3xcXD9cXC4/fFt+Ol0vXG59KTtcbnByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0WydjbGFzcy1uYW1lJ11bMF0ucGF0dGVybiA9IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ldylcXHMrKVtcXHcuXFxcXF0rLztcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAna2V5d29yZCcsIHtcbiAgJ3JlZ2V4Jzoge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZHVwZS1jaGFyYWN0ZXJzLWNoYXJhY3Rlci1jbGFzc1xuICAgIHBhdHRlcm46IC8oKD86XnxbXiRcXHdcXHhBMC1cXHVGRkZGLlwiJ1xcXSlcXHNdfFxcYig/OnJldHVybnx5aWVsZCkpXFxzKilcXC8oPzpcXFsoPzpbXlxcXVxcXFxcXHJcXG5dfFxcXFwuKSpcXF18XFxcXC58W14vXFxcXFxcW1xcclxcbl0pK1xcL1tkZ2lteXVzXXswLDd9KD89KD86XFxzfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvKSooPzokfFtcXHJcXG4sLjs6fSlcXF1dfFxcL1xcLykpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdyZWdleC1zb3VyY2UnOiB7XG4gICAgICAgIHBhdHRlcm46IC9eKFxcLylbXFxzXFxTXSsoPz1cXC9bYS16XSokKS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGFsaWFzOiAnbGFuZ3VhZ2UtcmVnZXgnLFxuICAgICAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlcy5yZWdleFxuICAgICAgfSxcbiAgICAgICdyZWdleC1kZWxpbWl0ZXInOiAvXlxcL3xcXC8kLyxcbiAgICAgICdyZWdleC1mbGFncyc6IC9eW2Etel0rJC9cbiAgICB9XG4gIH0sXG4gIC8vIFRoaXMgbXVzdCBiZSBkZWNsYXJlZCBiZWZvcmUga2V5d29yZCBiZWNhdXNlIHdlIHVzZSBcImZ1bmN0aW9uXCIgaW5zaWRlIHRoZSBsb29rLWZvcndhcmRcbiAgJ2Z1bmN0aW9uLXZhcmlhYmxlJzoge1xuICAgIHBhdHRlcm46IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqWz06XVxccyooPzphc3luY1xccyopPyg/OlxcYmZ1bmN0aW9uXFxifCg/OlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfCg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSopXFxzKj0+KSkvLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH0sXG4gICdwYXJhbWV0ZXInOiBbe1xuICAgIHBhdHRlcm46IC8oZnVuY3Rpb24oPzpcXHMrKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKik/XFxzKlxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICB9LCB7XG4gICAgcGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbXyRhLXpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqPT4pL2ksXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKFxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKVxccyo9PikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICB9LCB7XG4gICAgcGF0dGVybjogLygoPzpcXGJ8XFxzfF4pKD8hKD86YXN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseXxmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpKD8hWyRcXHdcXHhBMC1cXHVGRkZGXSkpKD86KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKlxccyopXFwoXFxzKnxcXF1cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpXFxzKlxceykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICB9XSxcbiAgJ2NvbnN0YW50JzogL1xcYltBLVpdKD86W0EtWl9dfFxcZHg/KSpcXGIvXG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnc3RyaW5nJywge1xuICAnaGFzaGJhbmcnOiB7XG4gICAgcGF0dGVybjogL14jIS4qLyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgYWxpYXM6ICdjb21tZW50J1xuICB9LFxuICAndGVtcGxhdGUtc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC9gKD86XFxcXFtcXHNcXFNdfFxcJFxceyg/Oltee31dfFxceyg/Oltee31dfFxce1tefV0qXFx9KSpcXH0pK1xcfXwoPyFcXCRcXHspW15cXFxcYF0pKmAvLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICd0ZW1wbGF0ZS1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgcGF0dGVybjogL15gfGAkLyxcbiAgICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgICB9LFxuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC8oKD86XnxbXlxcXFxdKSg/OlxcXFx7Mn0pKilcXCRcXHsoPzpbXnt9XXxcXHsoPzpbXnt9XXxcXHtbXn1dKlxcfSkqXFx9KStcXH0vLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC9eXFwkXFx7fFxcfSQvLFxuICAgICAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc3Q6IHByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnc3RyaW5nJzogL1tcXHNcXFNdKy9cbiAgICB9XG4gIH0sXG4gICdzdHJpbmctcHJvcGVydHknOiB7XG4gICAgcGF0dGVybjogLygoPzpefFsse10pWyBcXHRdKikoW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwyKVteXFxcXFxcclxcbl0pKlxcMig/PVxccyo6KS9tLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGFsaWFzOiAncHJvcGVydHknXG4gIH1cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdvcGVyYXRvcicsIHtcbiAgJ2xpdGVyYWwtcHJvcGVydHknOiB7XG4gICAgcGF0dGVybjogLygoPzpefFsse10pWyBcXHRdKikoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL20sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogJ3Byb3BlcnR5J1xuICB9XG59KTtcblxuaWYgKHByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcbiAgcHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkSW5saW5lZCgnc2NyaXB0JywgJ2phdmFzY3JpcHQnKTsgLy8gYWRkIGF0dHJpYnV0ZSBzdXBwb3J0IGZvciBhbGwgRE9NIGV2ZW50cy5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzI1N0YW5kYXJkX2V2ZW50c1xuXG4gIHByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZEF0dHJpYnV0ZSgvb24oPzphYm9ydHxibHVyfGNoYW5nZXxjbGlja3xjb21wb3NpdGlvbig/OmVuZHxzdGFydHx1cGRhdGUpfGRibGNsaWNrfGVycm9yfGZvY3VzKD86aW58b3V0KT98a2V5KD86ZG93bnx1cCl8bG9hZHxtb3VzZSg/OmRvd258ZW50ZXJ8bGVhdmV8bW92ZXxvdXR8b3Zlcnx1cCl8cmVzZXR8cmVzaXplfHNjcm9sbHxzZWxlY3R8c2xvdGNoYW5nZXxzdWJtaXR8dW5sb2FkfHdoZWVsKS8uc291cmNlLCAnamF2YXNjcmlwdCcpO1xufVxuXG5wcmlzbS5sYW5ndWFnZXMuanMgPSBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdDtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNvZmZlZXNjcmlwdFwiICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgLy8gSWdub3JlIGNvbW1lbnRzIHN0YXJ0aW5nIHdpdGggeyB0byBwcml2aWxlZ2Ugc3RyaW5nIGludGVycG9sYXRpb24gaGlnaGxpZ2h0aW5nXG4gIHZhciBjb21tZW50ID0gLyMoPyFcXHspLisvO1xuICB2YXIgaW50ZXJwb2xhdGlvbiA9IHtcbiAgICBwYXR0ZXJuOiAvI1xce1tefV0rXFx9LyxcbiAgICBhbGlhczogJ3ZhcmlhYmxlJ1xuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMuY29mZmVlc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnamF2YXNjcmlwdCcsIHtcbiAgICAnY29tbWVudCc6IGNvbW1lbnQsXG4gICAgJ3N0cmluZyc6IFsvLyBTdHJpbmdzIGFyZSBtdWx0aWxpbmVcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvJyg/OlxcXFxbXFxzXFxTXXxbXlxcXFwnXSkqJy8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAvLyBTdHJpbmdzIGFyZSBtdWx0aWxpbmVcbiAgICAgIHBhdHRlcm46IC9cIig/OlxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwiLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnaW50ZXJwb2xhdGlvbic6IGludGVycG9sYXRpb25cbiAgICAgIH1cbiAgICB9XSxcbiAgICAna2V5d29yZCc6IC9cXGIoPzphbmR8YnJlYWt8Ynl8Y2F0Y2h8Y2xhc3N8Y29udGludWV8ZGVidWdnZXJ8ZGVsZXRlfGRvfGVhY2h8ZWxzZXxleHRlbmR8ZXh0ZW5kc3xmYWxzZXxmaW5hbGx5fGZvcnxpZnxpbnxpbnN0YW5jZW9mfGlzfGlzbnR8bGV0fGxvb3B8bmFtZXNwYWNlfG5ld3xub3xub3R8bnVsbHxvZnxvZmZ8b258b3J8b3dufHJldHVybnxzdXBlcnxzd2l0Y2h8dGhlbnx0aGlzfHRocm93fHRydWV8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dW5sZXNzfHVudGlsfHdoZW58d2hpbGV8d2luZG93fHdpdGh8eWVzfHlpZWxkKVxcYi8sXG4gICAgJ2NsYXNzLW1lbWJlcic6IHtcbiAgICAgIHBhdHRlcm46IC9AKD8hXFxkKVxcdysvLFxuICAgICAgYWxpYXM6ICd2YXJpYWJsZSdcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjb2ZmZWVzY3JpcHQnLCAnY29tbWVudCcsIHtcbiAgICAnbXVsdGlsaW5lLWNvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvIyMjW1xcc1xcU10rPyMjIy8sXG4gICAgICBhbGlhczogJ2NvbW1lbnQnXG4gICAgfSxcbiAgICAvLyBCbG9jayByZWdleHAgY2FuIGNvbnRhaW4gY29tbWVudHMgYW5kIGludGVycG9sYXRpb25cbiAgICAnYmxvY2stcmVnZXgnOiB7XG4gICAgICBwYXR0ZXJuOiAvXFwvezN9W1xcc1xcU10qP1xcL3szfS8sXG4gICAgICBhbGlhczogJ3JlZ2V4JyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29tbWVudCc6IGNvbW1lbnQsXG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW50ZXJwb2xhdGlvblxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NvZmZlZXNjcmlwdCcsICdzdHJpbmcnLCB7XG4gICAgJ2lubGluZS1qYXZhc2NyaXB0Jzoge1xuICAgICAgcGF0dGVybjogL2AoPzpcXFxcW1xcc1xcU118W15cXFxcYF0pKmAvLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICAgICAgcGF0dGVybjogL15gfGAkLyxcbiAgICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICAnc2NyaXB0Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9bXFxzXFxTXSsvLFxuICAgICAgICAgIGFsaWFzOiAnbGFuZ3VhZ2UtamF2YXNjcmlwdCcsXG4gICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBCbG9jayBzdHJpbmdzXG4gICAgJ211bHRpbGluZS1zdHJpbmcnOiBbe1xuICAgICAgcGF0dGVybjogLycnJ1tcXHNcXFNdKj8nJycvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogL1wiXCJcIltcXHNcXFNdKj9cIlwiXCIvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgYWxpYXM6ICdzdHJpbmcnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIGludGVycG9sYXRpb246IGludGVycG9sYXRpb25cbiAgICAgIH1cbiAgICB9XVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY29mZmVlc2NyaXB0JywgJ2tleXdvcmQnLCB7XG4gICAgLy8gT2JqZWN0IHByb3BlcnR5XG4gICAgJ3Byb3BlcnR5JzogLyg/IVxcZClcXHcrKD89XFxzKjooPyE6KSkvXG4gIH0pO1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLmNvZmZlZXNjcmlwdFsndGVtcGxhdGUtc3RyaW5nJ107XG4gIFByaXNtLmxhbmd1YWdlcy5jb2ZmZWUgPSBQcmlzbS5sYW5ndWFnZXMuY29mZmVlc2NyaXB0O1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20teWFtbFwiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNjLW5zLWFuY2hvci1wcm9wZXJ0eVxuICAvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNjLW5zLWFsaWFzLW5vZGVcbiAgdmFyIGFuY2hvck9yQWxpYXMgPSAvWyomXVteXFxzW1xcXXt9LF0rLzsgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjYy1ucy10YWctcHJvcGVydHlcblxuICB2YXIgdGFnID0gLyEoPzo8W1xcd1xcLSUjOy8/OkAmPSskLC4hfionKClbXFxdXSs+fCg/OlthLXpBLVpcXGQtXSohKT9bXFx3XFwtJSM7Lz86QCY9KyQufionKCldKyk/LzsgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjYy1ucy1wcm9wZXJ0aWVzKG4sYylcblxuICB2YXIgcHJvcGVydGllcyA9ICcoPzonICsgdGFnLnNvdXJjZSArICcoPzpbIFxcdF0rJyArIGFuY2hvck9yQWxpYXMuc291cmNlICsgJyk/fCcgKyBhbmNob3JPckFsaWFzLnNvdXJjZSArICcoPzpbIFxcdF0rJyArIHRhZy5zb3VyY2UgKyAnKT8pJzsgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjbnMtcGxhaW4obixjKVxuICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCB2ZXJzaW9uIHRoYXQgZG9lc24ndCBzdXBwb3J0IFwiI1wiIGFuZCBtdWx0aWxpbmUga2V5c1xuICAvLyBBbGwgdGhlc2UgbG9uZyBzY2FycnkgY2hhcmFjdGVyIGNsYXNzZXMgYXJlIHNpbXBsaWZpZWQgdmVyc2lvbnMgb2YgWUFNTCdzIGNoYXJhY3RlcnNcblxuICB2YXIgcGxhaW5LZXkgPSAvKD86W15cXHNcXHgwMC1cXHgwOFxceDBlLVxceDFmIVwiIyUmJyosXFwtOj4/QFtcXF1ge3x9XFx4N2YtXFx4ODRcXHg4Ni1cXHg5ZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXXxbPzotXTxQTEFJTj4pKD86WyBcXHRdKig/Oig/IVsjOl0pPFBMQUlOPnw6PFBMQUlOPikpKi8uc291cmNlLnJlcGxhY2UoLzxQTEFJTj4vZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAvW15cXHNcXHgwMC1cXHgwOFxceDBlLVxceDFmLFtcXF17fVxceDdmLVxceDg0XFx4ODYtXFx4OWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZl0vLnNvdXJjZTtcbiAgfSk7XG4gIHZhciBzdHJpbmcgPSAvXCIoPzpbXlwiXFxcXFxcclxcbl18XFxcXC4pKlwifCcoPzpbXidcXFxcXFxyXFxuXXxcXFxcLikqJy8uc291cmNlO1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG4gICAqIEByZXR1cm5zIHtSZWdFeHB9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVZhbHVlUGF0dGVybih2YWx1ZSwgZmxhZ3MpIHtcbiAgICBmbGFncyA9IChmbGFncyB8fCAnJykucmVwbGFjZSgvbS9nLCAnJykgKyAnbSc7IC8vIGFkZCBtIGZsYWdcblxuICAgIHZhciBwYXR0ZXJuID0gLyhbOlxcLSxbe11cXHMqKD86XFxzPDxwcm9wPj5bIFxcdF0rKT8pKD86PDx2YWx1ZT4+KSg/PVsgXFx0XSooPzokfCx8XFxdfFxcfXwoPzpbXFxyXFxuXVxccyopPyMpKS8uc291cmNlLnJlcGxhY2UoLzw8cHJvcD4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0pLnJlcGxhY2UoLzw8dmFsdWU+Pi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH1cblxuICBQcmlzbS5sYW5ndWFnZXMueWFtbCA9IHtcbiAgICAnc2NhbGFyJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oW1xcLTpdXFxzKig/Olxcczw8cHJvcD4+WyBcXHRdKyk/W3w+XSlbIFxcdF0qKD86KCg/Olxccj9cXG58XFxyKVsgXFx0XSspXFxTW15cXHJcXG5dKig/OlxcMlteXFxyXFxuXSspKikvLnNvdXJjZS5yZXBsYWNlKC88PHByb3A+Pi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgICAgfSkpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnc3RyaW5nJ1xuICAgIH0sXG4gICAgJ2NvbW1lbnQnOiAvIy4qLyxcbiAgICAna2V5Jzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oKD86XnxbOlxcLSxbe1xcclxcbj9dKVsgXFx0XSooPzo8PHByb3A+PlsgXFx0XSspPyk8PGtleT4+KD89XFxzKjpcXHMpLy5zb3VyY2UucmVwbGFjZSgvPDxwcm9wPj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICAgIH0pLnJlcGxhY2UoLzw8a2V5Pj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJyg/OicgKyBwbGFpbktleSArICd8JyArIHN0cmluZyArICcpJztcbiAgICAgIH0pKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBhbGlhczogJ2F0cnVsZSdcbiAgICB9LFxuICAgICdkaXJlY3RpdmUnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF5bIFxcdF0qKSUuKy9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgIH0sXG4gICAgJ2RhdGV0aW1lJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9cXGR7NH0tXFxkXFxkPy1cXGRcXGQ/KD86W3RUXXxbIFxcdF0rKVxcZFxcZD86XFxkezJ9OlxcZHsyfSg/OlxcLlxcZCopPyg/OlsgXFx0XSooPzpafFstK11cXGRcXGQ/KD86OlxcZHsyfSk/KSk/fFxcZHs0fS1cXGR7Mn0tXFxkezJ9fFxcZFxcZD86XFxkezJ9KD86OlxcZHsyfSg/OlxcLlxcZCopPyk/Ly5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnbnVtYmVyJ1xuICAgIH0sXG4gICAgJ2Jvb2xlYW4nOiB7XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oL2ZhbHNlfHRydWUvLnNvdXJjZSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICB9LFxuICAgICdudWxsJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9udWxsfH4vLnNvdXJjZSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICB9LFxuICAgICdzdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oc3RyaW5nKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdudW1iZXInOiB7XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oL1srLV0/KD86MHhbXFxkYS1mXSt8MG9bMC03XSt8KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspP3xcXC5pbmZ8XFwubmFuKS8uc291cmNlLCAnaScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ3RhZyc6IHRhZyxcbiAgICAnaW1wb3J0YW50JzogYW5jaG9yT3JBbGlhcyxcbiAgICAncHVuY3R1YXRpb24nOiAvLS0tfFs6W1xcXXt9XFwtLHw+P118XFwuXFwuXFwuL1xuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMueW1sID0gUHJpc20ubGFuZ3VhZ2VzLnlhbWw7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1tYXJrZG93blwiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvLyBBbGxvdyBvbmx5IG9uZSBsaW5lIGJyZWFrXG4gIHZhciBpbm5lciA9IC8oPzpcXFxcLnxbXlxcXFxcXG5cXHJdfCg/OlxcbnxcXHJcXG4/KSg/IVtcXHJcXG5dKSkvLnNvdXJjZTtcbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiB0aGUgYm9sZCBvciBpdGFsaWMgcGF0dGVybi5cbiAgICpcbiAgICogVGhpcyBhbHNvIGFkZHMgYSBsb29rYmVoaW5kIGdyb3VwIHRvIHRoZSBnaXZlbiBwYXR0ZXJuIHRvIGVuc3VyZSB0aGF0IHRoZSBwYXR0ZXJuIGlzIG5vdCBiYWNrc2xhc2gtZXNjYXBlZC5cbiAgICpcbiAgICogX05vdGU6XyBLZWVwIGluIG1pbmQgdGhhdCB0aGlzIGFkZHMgYSBjYXB0dXJpbmcgZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gICAqIEByZXR1cm5zIHtSZWdFeHB9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUlubGluZShwYXR0ZXJuKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvPGlubmVyPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW5uZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlZ0V4cCgvKCg/Ol58W15cXFxcXSkoPzpcXFxcezJ9KSopLy5zb3VyY2UgKyAnKD86JyArIHBhdHRlcm4gKyAnKScpO1xuICB9XG5cbiAgdmFyIHRhYmxlQ2VsbCA9IC8oPzpcXFxcLnxgYCg/OlteYFxcclxcbl18YCg/IWApKStgYHxgW15gXFxyXFxuXStgfFteXFxcXHxcXHJcXG5gXSkrLy5zb3VyY2U7XG4gIHZhciB0YWJsZVJvdyA9IC9cXHw/X18oPzpcXHxfXykrXFx8Pyg/Oig/OlxcbnxcXHJcXG4/KXwoPyFbXFxzXFxTXSkpLy5zb3VyY2UucmVwbGFjZSgvX18vZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0YWJsZUNlbGw7XG4gIH0pO1xuICB2YXIgdGFibGVMaW5lID0gL1xcfD9bIFxcdF0qOj8tezMsfTo/WyBcXHRdKig/OlxcfFsgXFx0XSo6Py17Myx9Oj9bIFxcdF0qKStcXHw/KD86XFxufFxcclxcbj8pLy5zb3VyY2U7XG4gIFByaXNtLmxhbmd1YWdlcy5tYXJrZG93biA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ21hcmt1cCcsIHt9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya2Rvd24nLCAncHJvbG9nJywge1xuICAgICdmcm9udC1tYXR0ZXItYmxvY2snOiB7XG4gICAgICBwYXR0ZXJuOiAvKF4oPzpcXHMqW1xcclxcbl0pPyktLS0oPyEuKVtcXHNcXFNdKj9bXFxyXFxuXS0tLSg/IS4pLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL14tLS18LS0tJC8sXG4gICAgICAgICdmcm9udC1tYXR0ZXInOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcUysoPzpcXHMrXFxTKykqLyxcbiAgICAgICAgICBhbGlhczogWyd5YW1sJywgJ2xhbmd1YWdlLXlhbWwnXSxcbiAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy55YW1sXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdibG9ja3F1b3RlJzoge1xuICAgICAgLy8gPiAuLi5cbiAgICAgIHBhdHRlcm46IC9ePig/OltcXHQgXSo+KSovbSxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfSxcbiAgICAndGFibGUnOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14nICsgdGFibGVSb3cgKyB0YWJsZUxpbmUgKyAnKD86JyArIHRhYmxlUm93ICsgJykqJywgJ20nKSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndGFibGUtZGF0YS1yb3dzJzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXignICsgdGFibGVSb3cgKyB0YWJsZUxpbmUgKyAnKSg/OicgKyB0YWJsZVJvdyArICcpKiQnKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3RhYmxlLWRhdGEnOiB7XG4gICAgICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCh0YWJsZUNlbGwpLFxuICAgICAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5tYXJrZG93blxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXHwvXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAndGFibGUtbGluZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14oJyArIHRhYmxlUm93ICsgJyknICsgdGFibGVMaW5lICsgJyQnKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcfHw6Py17Myx9Oj8vXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAndGFibGUtaGVhZGVyLXJvdyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14nICsgdGFibGVSb3cgKyAnJCcpLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3RhYmxlLWhlYWRlcic6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogUmVnRXhwKHRhYmxlQ2VsbCksXG4gICAgICAgICAgICAgIGFsaWFzOiAnaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXFx8L1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2NvZGUnOiBbe1xuICAgICAgLy8gUHJlZml4ZWQgYnkgNCBzcGFjZXMgb3IgMSB0YWIgYW5kIHByZWNlZGVkIGJ5IGFuIGVtcHR5IGxpbmVcbiAgICAgIHBhdHRlcm46IC8oKD86XnxcXG4pWyBcXHRdKlxcbnwoPzpefFxcclxcbj8pWyBcXHRdKlxcclxcbj8pKD86IHs0fXxcXHQpLisoPzooPzpcXG58XFxyXFxuPykoPzogezR9fFxcdCkuKykqLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgfSwge1xuICAgICAgLy8gYGBgb3B0aW9uYWwgbGFuZ3VhZ2VcbiAgICAgIC8vIGNvZGUgYmxvY2tcbiAgICAgIC8vIGBgYFxuICAgICAgcGF0dGVybjogL15gYGBbXFxzXFxTXSo/XmBgYCQvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29kZS1ibG9jayc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXihgYGAuKig/OlxcbnxcXHJcXG4/KSlbXFxzXFxTXSs/KD89KD86XFxufFxcclxcbj8pXmBgYCQpL20sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAnY29kZS1sYW5ndWFnZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXihgYGApLisvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL2BgYC9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAndGl0bGUnOiBbe1xuICAgICAgLy8gdGl0bGUgMVxuICAgICAgLy8gPT09PT09PVxuICAgICAgLy8gdGl0bGUgMlxuICAgICAgLy8gLS0tLS0tLVxuICAgICAgcGF0dGVybjogL1xcUy4qKD86XFxufFxcclxcbj8pKD86PT0rfC0tKykoPz1bIFxcdF0qJCkvbSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50JyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBwdW5jdHVhdGlvbjogLz09KyR8LS0rJC9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyAjIHRpdGxlIDFcbiAgICAgIC8vICMjIyMjIyB0aXRsZSA2XG4gICAgICBwYXR0ZXJuOiAvKF5cXHMqKSMuKy9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50JyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBwdW5jdHVhdGlvbjogL14jK3wjKyQvXG4gICAgICB9XG4gICAgfV0sXG4gICAgJ2hyJzoge1xuICAgICAgLy8gKioqXG4gICAgICAvLyAtLS1cbiAgICAgIC8vICogKiAqXG4gICAgICAvLyAtLS0tLS0tLS0tLVxuICAgICAgcGF0dGVybjogLyheXFxzKikoWyotXSkoPzpbXFx0IF0qXFwyKXsyLH0oPz1cXHMqJCkvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ2xpc3QnOiB7XG4gICAgICAvLyAqIGl0ZW1cbiAgICAgIC8vICsgaXRlbVxuICAgICAgLy8gLSBpdGVtXG4gICAgICAvLyAxLiBpdGVtXG4gICAgICBwYXR0ZXJuOiAvKF5cXHMqKSg/OlsqKy1dfFxcZCtcXC4pKD89W1xcdCBdLikvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ3VybC1yZWZlcmVuY2UnOiB7XG4gICAgICAvLyBbaWRdOiBodHRwOi8vZXhhbXBsZS5jb20gXCJPcHRpb25hbCB0aXRsZVwiXG4gICAgICAvLyBbaWRdOiBodHRwOi8vZXhhbXBsZS5jb20gJ09wdGlvbmFsIHRpdGxlJ1xuICAgICAgLy8gW2lkXTogaHR0cDovL2V4YW1wbGUuY29tIChPcHRpb25hbCB0aXRsZSlcbiAgICAgIC8vIFtpZF06IDxodHRwOi8vZXhhbXBsZS5jb20+IFwiT3B0aW9uYWwgdGl0bGVcIlxuICAgICAgcGF0dGVybjogLyE/XFxbW15cXF1dK1xcXTpbXFx0IF0rKD86XFxTK3w8KD86XFxcXC58W14+XFxcXF0pKz4pKD86W1xcdCBdKyg/OlwiKD86XFxcXC58W15cIlxcXFxdKSpcInwnKD86XFxcXC58W14nXFxcXF0pKid8XFwoKD86XFxcXC58W14pXFxcXF0pKlxcKSkpPy8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3ZhcmlhYmxlJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eKCE/XFxbKVteXFxdXSsvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3N0cmluZyc6IC8oPzpcIig/OlxcXFwufFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwufFteJ1xcXFxdKSonfFxcKCg/OlxcXFwufFteKVxcXFxdKSpcXCkpJC8sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9eW1xcW1xcXSE6XXxbPD5dL1xuICAgICAgfSxcbiAgICAgIGFsaWFzOiAndXJsJ1xuICAgIH0sXG4gICAgJ2JvbGQnOiB7XG4gICAgICAvLyAqKnN0cm9uZyoqXG4gICAgICAvLyBfX3N0cm9uZ19fXG4gICAgICAvLyBhbGxvdyBvbmUgbmVzdGVkIGluc3RhbmNlIG9mIGl0YWxpYyB0ZXh0IHVzaW5nIHRoZSBzYW1lIGRlbGltaXRlclxuICAgICAgcGF0dGVybjogY3JlYXRlSW5saW5lKC9cXGJfXyg/Oig/IV8pPGlubmVyPnxfKD86KD8hXyk8aW5uZXI+KStfKStfX1xcYnxcXCpcXCooPzooPyFcXCopPGlubmVyPnxcXCooPzooPyFcXCopPGlubmVyPikrXFwqKStcXCpcXCovLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdjb250ZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXi4uKVtcXHNcXFNdKyg/PS4uJCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB7fSAvLyBzZWUgYmVsb3dcblxuICAgICAgICB9LFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFwqXFwqfF9fL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2l0YWxpYyc6IHtcbiAgICAgIC8vICplbSpcbiAgICAgIC8vIF9lbV9cbiAgICAgIC8vIGFsbG93IG9uZSBuZXN0ZWQgaW5zdGFuY2Ugb2YgYm9sZCB0ZXh0IHVzaW5nIHRoZSBzYW1lIGRlbGltaXRlclxuICAgICAgcGF0dGVybjogY3JlYXRlSW5saW5lKC9cXGJfKD86KD8hXyk8aW5uZXI+fF9fKD86KD8hXyk8aW5uZXI+KStfXykrX1xcYnxcXCooPzooPyFcXCopPGlubmVyPnxcXCpcXCooPzooPyFcXCopPGlubmVyPikrXFwqXFwqKStcXCovLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdjb250ZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXi4pW1xcc1xcU10rKD89LiQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge30gLy8gc2VlIGJlbG93XG5cbiAgICAgICAgfSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1sqX10vXG4gICAgICB9XG4gICAgfSxcbiAgICAnc3RyaWtlJzoge1xuICAgICAgLy8gfn5zdHJpa2UgdGhyb3VnaH5+XG4gICAgICAvLyB+c3RyaWtlflxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9zdHJpY3RcbiAgICAgIHBhdHRlcm46IGNyZWF0ZUlubGluZSgvKH5+PykoPzooPyF+KTxpbm5lcj4pK1xcMi8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2NvbnRlbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyhefn4/KVtcXHNcXFNdKyg/PVxcMSQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge30gLy8gc2VlIGJlbG93XG5cbiAgICAgICAgfSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL35+Py9cbiAgICAgIH1cbiAgICB9LFxuICAgICdjb2RlLXNuaXBwZXQnOiB7XG4gICAgICAvLyBgY29kZWBcbiAgICAgIC8vIGBgY29kZWBgXG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcYF0pKD86YGBbXmBcXHJcXG5dKyg/OmBbXmBcXHJcXG5dKykqYGAoPyFgKXxgW15gXFxyXFxuXStgKD8hYCkpLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBhbGlhczogWydjb2RlJywgJ2tleXdvcmQnXVxuICAgIH0sXG4gICAgJ3VybCc6IHtcbiAgICAgIC8vIFtleGFtcGxlXShodHRwOi8vZXhhbXBsZS5jb20gXCJPcHRpb25hbCB0aXRsZVwiKVxuICAgICAgLy8gW2V4YW1wbGVdW2lkXVxuICAgICAgLy8gW2V4YW1wbGVdIFtpZF1cbiAgICAgIHBhdHRlcm46IGNyZWF0ZUlubGluZSgvIT9cXFsoPzooPyFcXF0pPGlubmVyPikrXFxdKD86XFwoW15cXHMpXSsoPzpbXFx0IF0rXCIoPzpcXFxcLnxbXlwiXFxcXF0pKlwiKT9cXCl8WyBcXHRdP1xcWyg/Oig/IVxcXSk8aW5uZXI+KStcXF0pLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnb3BlcmF0b3InOiAvXiEvLFxuICAgICAgICAnY29udGVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5cXFspW15cXF1dKyg/PVxcXSkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB7fSAvLyBzZWUgYmVsb3dcblxuICAgICAgICB9LFxuICAgICAgICAndmFyaWFibGUnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheXFxdWyBcXHRdP1xcWylbXlxcXV0rKD89XFxdJCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3VybCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5cXF1cXCgpW15cXHMpXSsvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3N0cmluZyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5bIFxcdF0rKVwiKD86XFxcXC58W15cIlxcXFxdKSpcIig/PVxcKSQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBbJ3VybCcsICdib2xkJywgJ2l0YWxpYycsICdzdHJpa2UnXS5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgIFsndXJsJywgJ2JvbGQnLCAnaXRhbGljJywgJ3N0cmlrZScsICdjb2RlLXNuaXBwZXQnXS5mb3JFYWNoKGZ1bmN0aW9uIChpbnNpZGUpIHtcbiAgICAgIGlmICh0b2tlbiAhPT0gaW5zaWRlKSB7XG4gICAgICAgIFByaXNtLmxhbmd1YWdlcy5tYXJrZG93blt0b2tlbl0uaW5zaWRlLmNvbnRlbnQuaW5zaWRlW2luc2lkZV0gPSBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25baW5zaWRlXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIFByaXNtLmhvb2tzLmFkZCgnYWZ0ZXItdG9rZW5pemUnLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgaWYgKGVudi5sYW5ndWFnZSAhPT0gJ21hcmtkb3duJyAmJiBlbnYubGFuZ3VhZ2UgIT09ICdtZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YWxrVG9rZW5zKHRva2Vucykge1xuICAgICAgaWYgKCF0b2tlbnMgfHwgdHlwZW9mIHRva2VucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnY29kZScpIHtcbiAgICAgICAgICB3YWxrVG9rZW5zKHRva2VuLmNvbnRlbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIEFkZCB0aGUgY29ycmVjdCBgbGFuZ3VhZ2UteHh4eGAgY2xhc3MgdG8gdGhpcyBjb2RlIGJsb2NrLiBLZWVwIGluIG1pbmQgdGhhdCB0aGUgYGNvZGUtbGFuZ3VhZ2VgIHRva2VuXG4gICAgICAgICAqIGlzIG9wdGlvbmFsLiBCdXQgdGhlIGdyYW1tYXIgaXMgZGVmaW5lZCBzbyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIGNhc2Ugd2UgaGF2ZSB0byBoYW5kbGU6XG4gICAgICAgICAqXG4gICAgICAgICAqIHRva2VuLmNvbnRlbnQgPSBbXG4gICAgICAgICAqICAgICA8c3BhbiBjbGFzcz1cInB1bmN0dWF0aW9uXCI+YGBgPC9zcGFuPixcbiAgICAgICAgICogICAgIDxzcGFuIGNsYXNzPVwiY29kZS1sYW5ndWFnZVwiPnh4eHg8L3NwYW4+LFxuICAgICAgICAgKiAgICAgJ1xcbicsIC8vIGV4YWN0bHkgb25lIG5ldyBsaW5lcyAoXFxyIG9yIFxcbiBvciBcXHJcXG4pXG4gICAgICAgICAqICAgICA8c3BhbiBjbGFzcz1cImNvZGUtYmxvY2tcIj4uLi48L3NwYW4+LFxuICAgICAgICAgKiAgICAgJ1xcbicsIC8vIGV4YWN0bHkgb25lIG5ldyBsaW5lcyBhZ2FpblxuICAgICAgICAgKiAgICAgPHNwYW4gY2xhc3M9XCJwdW5jdHVhdGlvblwiPmBgYDwvc3Bhbj5cbiAgICAgICAgICogXTtcbiAgICAgICAgICovXG5cblxuICAgICAgICB2YXIgY29kZUxhbmcgPSB0b2tlbi5jb250ZW50WzFdO1xuICAgICAgICB2YXIgY29kZUJsb2NrID0gdG9rZW4uY29udGVudFszXTtcblxuICAgICAgICBpZiAoY29kZUxhbmcgJiYgY29kZUJsb2NrICYmIGNvZGVMYW5nLnR5cGUgPT09ICdjb2RlLWxhbmd1YWdlJyAmJiBjb2RlQmxvY2sudHlwZSA9PT0gJ2NvZGUtYmxvY2snICYmIHR5cGVvZiBjb2RlTGFuZy5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHRoaXMgbWlnaHQgYmUgYSBsYW5ndWFnZSB0aGF0IFByaXNtIGRvZXMgbm90IHN1cHBvcnRcbiAgICAgICAgICAvLyBkbyBzb21lIHJlcGxhY2VtZW50cyB0byBzdXBwb3J0IEMrKywgQyMsIGFuZCBGI1xuICAgICAgICAgIHZhciBsYW5nID0gY29kZUxhbmcuY29udGVudC5yZXBsYWNlKC9cXGIjL2csICdzaGFycCcpLnJlcGxhY2UoL1xcYlxcK1xcKy9nLCAncHAnKTsgLy8gb25seSB1c2UgdGhlIGZpcnN0IHdvcmRcblxuICAgICAgICAgIGxhbmcgPSAoL1thLXpdW1xcdy1dKi9pLmV4ZWMobGFuZykgfHwgWycnXSlbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB2YXIgYWxpYXMgPSAnbGFuZ3VhZ2UtJyArIGxhbmc7IC8vIGFkZCBhbGlhc1xuXG4gICAgICAgICAgaWYgKCFjb2RlQmxvY2suYWxpYXMpIHtcbiAgICAgICAgICAgIGNvZGVCbG9jay5hbGlhcyA9IFthbGlhc107XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZUJsb2NrLmFsaWFzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29kZUJsb2NrLmFsaWFzID0gW2NvZGVCbG9jay5hbGlhcywgYWxpYXNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlQmxvY2suYWxpYXMucHVzaChhbGlhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2Fsa1Rva2VucyhlbnYudG9rZW5zKTtcbiAgfSk7XG4gIFByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICBpZiAoZW52LnR5cGUgIT09ICdjb2RlLWJsb2NrJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb2RlTGFuZyA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbnYuY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjbHMgPSBlbnYuY2xhc3Nlc1tpXTtcbiAgICAgIHZhciBtYXRjaCA9IC9sYW5ndWFnZS0oLispLy5leGVjKGNscyk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb2RlTGFuZyA9IG1hdGNoWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ3JhbW1hciA9IFByaXNtLmxhbmd1YWdlc1tjb2RlTGFuZ107XG5cbiAgICBpZiAoIWdyYW1tYXIpIHtcbiAgICAgIGlmIChjb2RlTGFuZyAmJiBjb2RlTGFuZyAhPT0gJ25vbmUnICYmIFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlcikge1xuICAgICAgICB2YXIgaWQgPSAnbWQtJyArIG5ldyBEYXRlKCkudmFsdWVPZigpICsgJy0nICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWUxNik7XG4gICAgICAgIGVudi5hdHRyaWJ1dGVzWydpZCddID0gaWQ7XG4gICAgICAgIFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlci5sb2FkTGFuZ3VhZ2VzKGNvZGVMYW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICAgIGVsZS5pbm5lckhUTUwgPSBQcmlzbS5oaWdobGlnaHQoZWxlLnRleHRDb250ZW50LCBQcmlzbS5sYW5ndWFnZXNbY29kZUxhbmddLCBjb2RlTGFuZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW52LmNvbnRlbnQgPSBQcmlzbS5oaWdobGlnaHQodGV4dENvbnRlbnQoZW52LmNvbnRlbnQpLCBncmFtbWFyLCBjb2RlTGFuZyk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHRhZ1BhdHRlcm4gPSBSZWdFeHAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcucGF0dGVybi5zb3VyY2UsICdnaScpO1xuICAvKipcbiAgICogQSBsaXN0IG9mIGtub3duIGVudGl0eSBuYW1lcy5cbiAgICpcbiAgICogVGhpcyB3aWxsIGFsd2F5cyBiZSBpbmNvbXBsZXRlIHRvIHNhdmUgc3BhY2UuIFRoZSBjdXJyZW50IGxpc3QgaXMgdGhlIG9uZSB1c2VkIGJ5IGxvd2Rhc2gncyB1bmVzY2FwZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi8yZGEwMjRjM2I0Zjk5NDdhNDg1MTc2MzlkZTc1NjA0NTdjZDRlYzZjL3VuZXNjYXBlLmpzI0wyfVxuICAgKi9cblxuICB2YXIgS05PV05fRU5USVRZX05BTUVTID0ge1xuICAgICdhbXAnOiAnJicsXG4gICAgJ2x0JzogJzwnLFxuICAgICdndCc6ICc+JyxcbiAgICAncXVvdCc6ICdcIidcbiAgfTsgLy8gSUUgMTEgZG9lc24ndCBzdXBwb3J0IGBTdHJpbmcuZnJvbUNvZGVQb2ludGBcblxuICB2YXIgZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50IHx8IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSBnaXZlbiBIVE1MIHNvdXJjZSBjb2RlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cbiAgZnVuY3Rpb24gdGV4dENvbnRlbnQoaHRtbCkge1xuICAgIC8vIHJlbW92ZSBhbGwgdGFnc1xuICAgIHZhciB0ZXh0ID0gaHRtbC5yZXBsYWNlKHRhZ1BhdHRlcm4sICcnKTsgLy8gZGVjb2RlIGtub3duIGVudGl0aWVzXG5cbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8mKFxcd3sxLDh9fCN4P1tcXGRhLWZdezEsOH0pOy9naSwgZnVuY3Rpb24gKG0sIGNvZGUpIHtcbiAgICAgIGNvZGUgPSBjb2RlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmIChjb2RlWzBdID09PSAnIycpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChjb2RlWzFdID09PSAneCcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KGNvZGUuc2xpY2UoMiksIDE2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IE51bWJlcihjb2RlLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrbm93biA9IEtOT1dOX0VOVElUWV9OQU1FU1tjb2RlXTtcblxuICAgICAgICBpZiAoa25vd24pIHtcbiAgICAgICAgICByZXR1cm4ga25vd247XG4gICAgICAgIH0gLy8gdW5hYmxlIHRvIGRlY29kZVxuXG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBQcmlzbS5sYW5ndWFnZXMubWQgPSBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd247XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1ncmFwaHFsXCIgKi9cblxuXG5wcmlzbS5sYW5ndWFnZXMuZ3JhcGhxbCA9IHtcbiAgJ2NvbW1lbnQnOiAvIy4qLyxcbiAgJ2Rlc2NyaXB0aW9uJzoge1xuICAgIHBhdHRlcm46IC8oPzpcIlwiXCIoPzpbXlwiXXwoPyFcIlwiXCIpXCIpKlwiXCJcInxcIig/OlxcXFwufFteXFxcXFwiXFxyXFxuXSkqXCIpKD89XFxzKlthLXpfXSkvaSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgYWxpYXM6ICdzdHJpbmcnLFxuICAgIGluc2lkZToge1xuICAgICAgJ2xhbmd1YWdlLW1hcmtkb3duJzoge1xuICAgICAgICBwYXR0ZXJuOiAvKF5cIig/OlwiXCIpPykoPyFcXDEpW1xcc1xcU10rKD89XFwxJCkvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlcy5tYXJrZG93blxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvXCJcIlwiKD86W15cIl18KD8hXCJcIlwiKVwiKSpcIlwiXCJ8XCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ251bWJlcic6IC8oPzpcXEItfFxcYilcXGQrKD86XFwuXFxkKyk/KD86ZVsrLV0/XFxkKyk/XFxiL2ksXG4gICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgJ3ZhcmlhYmxlJzogL1xcJFthLXpfXVxcdyovaSxcbiAgJ2RpcmVjdGl2ZSc6IHtcbiAgICBwYXR0ZXJuOiAvQFthLXpfXVxcdyovaSxcbiAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICB9LFxuICAnYXR0ci1uYW1lJzoge1xuICAgIHBhdHRlcm46IC9cXGJbYS16X11cXHcqKD89XFxzKig/OlxcKCg/OlteKClcIl18XCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiKSpcXCkpPzopL2ksXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdhdG9tLWlucHV0Jzoge1xuICAgIHBhdHRlcm46IC9cXGJbQS1aXVxcdypJbnB1dFxcYi8sXG4gICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICB9LFxuICAnc2NhbGFyJzogL1xcYig/OkJvb2xlYW58RmxvYXR8SUR8SW50fFN0cmluZylcXGIvLFxuICAnY29uc3RhbnQnOiAvXFxiW0EtWl1bQS1aX1xcZF0qXFxiLyxcbiAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgcGF0dGVybjogLyhcXGIoPzplbnVtfGltcGxlbWVudHN8aW50ZXJmYWNlfG9ufHNjYWxhcnx0eXBlfHVuaW9uKVxccyt8Jlxccyp8Olxccyp8XFxbKVtBLVpfXVxcdyovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2ZyYWdtZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXFxiZnJhZ21lbnRcXHMrfFxcLnszfVxccyooPyFvblxcYikpW2EtekEtWl9dXFx3Ki8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICB9LFxuICAnZGVmaW5pdGlvbi1tdXRhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYm11dGF0aW9uXFxzKylbYS16QS1aX11cXHcqLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH0sXG4gICdkZWZpbml0aW9uLXF1ZXJ5Jzoge1xuICAgIHBhdHRlcm46IC8oXFxicXVlcnlcXHMrKVthLXpBLVpfXVxcdyovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86ZGlyZWN0aXZlfGVudW18ZXh0ZW5kfGZyYWdtZW50fGltcGxlbWVudHN8aW5wdXR8aW50ZXJmYWNlfG11dGF0aW9ufG9ufHF1ZXJ5fHJlcGVhdGFibGV8c2NhbGFyfHNjaGVtYXxzdWJzY3JpcHRpb258dHlwZXx1bmlvbilcXGIvLFxuICAnb3BlcmF0b3InOiAvWyE9fCZdfFxcLnszfS8sXG4gICdwcm9wZXJ0eS1xdWVyeSc6IC9cXHcrKD89XFxzKlxcKCkvLFxuICAnb2JqZWN0JzogL1xcdysoPz1cXHMqXFx7KS8sXG4gICdwdW5jdHVhdGlvbic6IC9bISgpe31cXFtcXF06PSxdLyxcbiAgJ3Byb3BlcnR5JzogL1xcdysvXG59O1xucHJpc20uaG9va3MuYWRkKCdhZnRlci10b2tlbml6ZScsIGZ1bmN0aW9uIGFmdGVyVG9rZW5pemVHcmFwaHFsKGVudikge1xuICBpZiAoZW52Lmxhbmd1YWdlICE9PSAnZ3JhcGhxbCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqXG4gICAqIGdldCB0aGUgZ3JhcGhxbCB0b2tlbiBzdHJlYW0gdGhhdCB3ZSB3YW50IHRvIGN1c3RvbWl6ZVxuICAgKlxuICAgKiBAdHlwZWRlZiB7SW5zdGFuY2VUeXBlPGltcG9ydChcIi4vcHJpc20tY29yZVwiKVtcIlRva2VuXCJdPn0gVG9rZW5cbiAgICogQHR5cGUge1Rva2VuW119XG4gICAqL1xuXG5cbiAgdmFyIHZhbGlkVG9rZW5zID0gZW52LnRva2Vucy5maWx0ZXIoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycgJiYgdG9rZW4udHlwZSAhPT0gJ2NvbW1lbnQnICYmIHRva2VuLnR5cGUgIT09ICdzY2FsYXInO1xuICB9KTtcbiAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHRva2VuIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGluZGV4IGhhcyB0aGUgZ2l2ZW4gdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJucyB7VG9rZW4gfCB1bmRlZmluZWR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFRva2VuKG9mZnNldCkge1xuICAgIHJldHVybiB2YWxpZFRva2Vuc1tjdXJyZW50SW5kZXggKyBvZmZzZXRdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHRva2VuIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGluZGV4IGhhcyB0aGUgZ2l2ZW4gdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtyZWFkb25seSBzdHJpbmdbXX0gdHlwZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF1cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNUb2tlblR5cGUodHlwZXMsIG9mZnNldCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gZ2V0VG9rZW4oaSArIG9mZnNldCk7XG5cbiAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4udHlwZSAhPT0gdHlwZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2luZyBicmFja2V0IHRvIGFuIG9wZW5pbmcgYnJhY2tldC5cbiAgICpcbiAgICogSXQgaXMgYXNzdW1lZCB0aGF0IGB0b2tlbltjdXJyZW50SW5kZXggLSAxXWAgaXMgYW4gb3BlbmluZyBicmFja2V0LlxuICAgKlxuICAgKiBJZiBubyBjbG9zaW5nIGJyYWNrZXQgY291bGQgYmUgZm91bmQsIGAtMWAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHB9IG9wZW5cbiAgICogQHBhcmFtIHtSZWdFeHB9IGNsb3NlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZmluZENsb3NpbmdCcmFja2V0KG9wZW4sIGNsb3NlKSB7XG4gICAgdmFyIHN0YWNrSGVpZ2h0ID0gMTtcblxuICAgIGZvciAodmFyIGkgPSBjdXJyZW50SW5kZXg7IGkgPCB2YWxpZFRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdmFsaWRUb2tlbnNbaV07XG4gICAgICB2YXIgY29udGVudCA9IHRva2VuLmNvbnRlbnQ7XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSAncHVuY3R1YXRpb24nICYmIHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAob3Blbi50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgc3RhY2tIZWlnaHQrKztcbiAgICAgICAgfSBlbHNlIGlmIChjbG9zZS50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgc3RhY2tIZWlnaHQtLTtcblxuICAgICAgICAgIGlmIChzdGFja0hlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFsaWFzIHRvIHRoZSBnaXZlbiB0b2tlbi5cbiAgICpcbiAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWFzXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFkZEFsaWFzKHRva2VuLCBhbGlhcykge1xuICAgIHZhciBhbGlhc2VzID0gdG9rZW4uYWxpYXM7XG5cbiAgICBpZiAoIWFsaWFzZXMpIHtcbiAgICAgIHRva2VuLmFsaWFzID0gYWxpYXNlcyA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYWxpYXNlcykpIHtcbiAgICAgIHRva2VuLmFsaWFzID0gYWxpYXNlcyA9IFthbGlhc2VzXTtcbiAgICB9XG5cbiAgICBhbGlhc2VzLnB1c2goYWxpYXMpO1xuICB9XG5cbiAgZm9yICg7IGN1cnJlbnRJbmRleCA8IHZhbGlkVG9rZW5zLmxlbmd0aDspIHtcbiAgICB2YXIgc3RhcnRUb2tlbiA9IHZhbGlkVG9rZW5zW2N1cnJlbnRJbmRleCsrXTsgLy8gYWRkIHNwZWNpYWwgYWxpYXNlcyBmb3IgbXV0YXRpb24gdG9rZW5zXG5cbiAgICBpZiAoc3RhcnRUb2tlbi50eXBlID09PSAna2V5d29yZCcgJiYgc3RhcnRUb2tlbi5jb250ZW50ID09PSAnbXV0YXRpb24nKSB7XG4gICAgICAvLyBhbnkgYXJyYXkgb2YgdGhlIG5hbWVzIG9mIGFsbCBpbnB1dCB2YXJpYWJsZXMgKGlmIGFueSlcbiAgICAgIHZhciBpbnB1dFZhcmlhYmxlcyA9IFtdO1xuXG4gICAgICBpZiAoaXNUb2tlblR5cGUoWydkZWZpbml0aW9uLW11dGF0aW9uJywgJ3B1bmN0dWF0aW9uJ10pICYmIGdldFRva2VuKDEpLmNvbnRlbnQgPT09ICcoJykge1xuICAgICAgICAvLyBkZWZpbml0aW9uXG4gICAgICAgIGN1cnJlbnRJbmRleCArPSAyOyAvLyBza2lwICdkZWZpbml0aW9uLW11dGF0aW9uJyBhbmQgJ3B1bmN0dWF0aW9uJ1xuXG4gICAgICAgIHZhciBkZWZpbml0aW9uRW5kID0gZmluZENsb3NpbmdCcmFja2V0KC9eXFwoJC8sIC9eXFwpJC8pO1xuXG4gICAgICAgIGlmIChkZWZpbml0aW9uRW5kID09PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGZpbmQgYWxsIGlucHV0IHZhcmlhYmxlc1xuXG5cbiAgICAgICAgZm9yICg7IGN1cnJlbnRJbmRleCA8IGRlZmluaXRpb25FbmQ7IGN1cnJlbnRJbmRleCsrKSB7XG4gICAgICAgICAgdmFyIHQgPSBnZXRUb2tlbigwKTtcblxuICAgICAgICAgIGlmICh0LnR5cGUgPT09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIGFkZEFsaWFzKHQsICd2YXJpYWJsZS1pbnB1dCcpO1xuICAgICAgICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaCh0LmNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGRlZmluaXRpb25FbmQgKyAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNUb2tlblR5cGUoWydwdW5jdHVhdGlvbicsICdwcm9wZXJ0eS1xdWVyeSddKSAmJiBnZXRUb2tlbigwKS5jb250ZW50ID09PSAneycpIHtcbiAgICAgICAgY3VycmVudEluZGV4Kys7IC8vIHNraXAgb3BlbmluZyBicmFja2V0XG5cbiAgICAgICAgYWRkQWxpYXMoZ2V0VG9rZW4oMCksICdwcm9wZXJ0eS1tdXRhdGlvbicpO1xuXG4gICAgICAgIGlmIChpbnB1dFZhcmlhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIG11dGF0aW9uRW5kID0gZmluZENsb3NpbmdCcmFja2V0KC9eXFx7JC8sIC9eXFx9JC8pO1xuXG4gICAgICAgICAgaWYgKG11dGF0aW9uRW5kID09PSAtMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBnaXZlIHJlZmVyZW5jZXMgdG8gaW5wdXQgdmFyaWFibGVzIGEgc3BlY2lhbCBhbGlhc1xuXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gY3VycmVudEluZGV4OyBpIDwgbXV0YXRpb25FbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhclRva2VuID0gdmFsaWRUb2tlbnNbaV07XG5cbiAgICAgICAgICAgIGlmICh2YXJUb2tlbi50eXBlID09PSAndmFyaWFibGUnICYmIGlucHV0VmFyaWFibGVzLmluZGV4T2YodmFyVG9rZW4uY29udGVudCkgPj0gMCkge1xuICAgICAgICAgICAgICBhZGRBbGlhcyh2YXJUb2tlbiwgJ3ZhcmlhYmxlLWlucHV0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXNxbFwiICovXG5cbnByaXNtLmxhbmd1YWdlcy5zcWwgPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSg/OlxcL1xcKltcXHNcXFNdKj9cXCpcXC98KD86LS18XFwvXFwvfCMpLiopLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICd2YXJpYWJsZSc6IFt7XG4gICAgcGF0dGVybjogL0AoW1wiJ2BdKSg/OlxcXFxbXFxzXFxTXXwoPyFcXDEpW15cXFxcXSkrXFwxLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSwgL0BbXFx3LiRdKy9dLFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oXnxbXkBcXFxcXSkoXCJ8JykoPzpcXFxcW1xcc1xcU118KD8hXFwyKVteXFxcXF18XFwyXFwyKSpcXDIvLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdpZGVudGlmaWVyJzoge1xuICAgIHBhdHRlcm46IC8oXnxbXkBcXFxcXSlgKD86XFxcXFtcXHNcXFNdfFteYFxcXFxdfGBgKSpgLyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdwdW5jdHVhdGlvbic6IC9eYHxgJC9cbiAgICB9XG4gIH0sXG4gICdmdW5jdGlvbic6IC9cXGIoPzpBVkd8Q09VTlR8RklSU1R8Rk9STUFUfExBU1R8TENBU0V8TEVOfE1BWHxNSUR8TUlOfE1PRHxOT1d8Uk9VTkR8U1VNfFVDQVNFKSg/PVxccypcXCgpL2ksXG4gIC8vIFNob3VsZCB3ZSBoaWdobGlnaHQgdXNlciBkZWZpbmVkIGZ1bmN0aW9ucyB0b28/XG4gICdrZXl3b3JkJzogL1xcYig/OkFDVElPTnxBRER8QUZURVJ8QUxHT1JJVEhNfEFMTHxBTFRFUnxBTkFMWVpFfEFOWXxBUFBMWXxBU3xBU0N8QVVUSE9SSVpBVElPTnxBVVRPX0lOQ1JFTUVOVHxCQUNLVVB8QkRCfEJFR0lOfEJFUktFTEVZREJ8QklHSU5UfEJJTkFSWXxCSVR8QkxPQnxCT09MfEJPT0xFQU58QlJFQUt8QlJPV1NFfEJUUkVFfEJVTEt8Qll8Q0FMTHxDQVNDQURFRD98Q0FTRXxDSEFJTnxDSEFSKD86QUNURVJ8U0VUKT98Q0hFQ0soPzpQT0lOVCk/fENMT1NFfENMVVNURVJFRHxDT0FMRVNDRXxDT0xMQVRFfENPTFVNTlM/fENPTU1FTlR8Q09NTUlUKD86VEVEKT98Q09NUFVURXxDT05ORUNUfENPTlNJU1RFTlR8Q09OU1RSQUlOVHxDT05UQUlOUyg/OlRBQkxFKT98Q09OVElOVUV8Q09OVkVSVHxDUkVBVEV8Q1JPU1N8Q1VSUkVOVCg/Ol9EQVRFfF9USU1FfF9USU1FU1RBTVB8X1VTRVIpP3xDVVJTT1J8Q1lDTEV8REFUQSg/OkJBU0VTPyk/fERBVEUoPzpUSU1FKT98REFZfERCQ0N8REVBTExPQ0FURXxERUN8REVDSU1BTHxERUNMQVJFfERFRkFVTFR8REVGSU5FUnxERUxBWUVEfERFTEVURXxERUxJTUlURVJTP3xERU5ZfERFU0N8REVTQ1JJQkV8REVURVJNSU5JU1RJQ3xESVNBQkxFfERJU0NBUkR8RElTS3xESVNUSU5DVHxESVNUSU5DVFJPV3xESVNUUklCVVRFRHxET3xET1VCTEV8RFJPUHxEVU1NWXxEVU1QKD86RklMRSk/fERVUExJQ0FURXxFTFNFKD86SUYpP3xFTkFCTEV8RU5DTE9TRUR8RU5EfEVOR0lORXxFTlVNfEVSUkxWTHxFUlJPUlN8RVNDQVBFRD98RVhDRVBUfEVYRUMoPzpVVEUpP3xFWElTVFN8RVhJVHxFWFBMQUlOfEVYVEVOREVEfEZFVENIfEZJRUxEU3xGSUxFfEZJTExGQUNUT1J8RklSU1R8RklYRUR8RkxPQVR8Rk9MTE9XSU5HfEZPUig/OiBFQUNIIFJPVyk/fEZPUkNFfEZPUkVJR058RlJFRVRFWFQoPzpUQUJMRSk/fEZST018RlVMTHxGVU5DVElPTnxHRU9NRVRSWSg/OkNPTExFQ1RJT04pP3xHTE9CQUx8R09UT3xHUkFOVHxHUk9VUHxIQU5ETEVSfEhBU0h8SEFWSU5HfEhPTERMT0NLfEhPVVJ8SURFTlRJVFkoPzpDT0x8X0lOU0VSVCk/fElGfElHTk9SRXxJTVBPUlR8SU5ERVh8SU5GSUxFfElOTkVSfElOTk9EQnxJTk9VVHxJTlNFUlR8SU5UfElOVEVHRVJ8SU5URVJTRUNUfElOVEVSVkFMfElOVE98SU5WT0tFUnxJU09MQVRJT058SVRFUkFURXxKT0lOfEtFWVM/fEtJTEx8TEFOR1VBR0V8TEFTVHxMRUFWRXxMRUZUfExFVkVMfExJTUlUfExJTkVOT3xMSU5FU3xMSU5FU1RSSU5HfExPQUR8TE9DQUx8TE9DS3xMT05HKD86QkxPQnxURVhUKXxMT09QfE1BVENIKD86RUQpP3xNRURJVU0oPzpCTE9CfElOVHxURVhUKXxNRVJHRXxNSURETEVJTlR8TUlOVVRFfE1PREV8TU9ESUZJRVN8TU9ESUZZfE1PTlRIfE1VTFRJKD86TElORVNUUklOR3xQT0lOVHxQT0xZR09OKXxOQVRJT05BTHxOQVRVUkFMfE5DSEFSfE5FWFR8Tk98Tk9OQ0xVU1RFUkVEfE5VTExJRnxOVU1FUklDfE9GRj98T0ZGU0VUUz98T058T1BFTig/OkRBVEFTT1VSQ0V8UVVFUll8Uk9XU0VUKT98T1BUSU1JWkV8T1BUSU9OKD86QUxMWSk/fE9SREVSfE9VVCg/OkVSfEZJTEUpP3xPVkVSfFBBUlRJQUx8UEFSVElUSU9OfFBFUkNFTlR8UElWT1R8UExBTnxQT0lOVHxQT0xZR09OfFBSRUNFRElOR3xQUkVDSVNJT058UFJFUEFSRXxQUkVWfFBSSU1BUll8UFJJTlR8UFJJVklMRUdFU3xQUk9DKD86RURVUkUpP3xQVUJMSUN8UFVSR0V8UVVJQ0t8UkFJU0VSUk9SfFJFQURTP3xSRUFMfFJFQ09ORklHVVJFfFJFRkVSRU5DRVN8UkVMRUFTRXxSRU5BTUV8UkVQRUFUKD86QUJMRSk/fFJFUExBQ0V8UkVQTElDQVRJT058UkVRVUlSRXxSRVNJR05BTHxSRVNUT1JFfFJFU1RSSUNUfFJFVFVSTig/OklOR3xTKT98UkVWT0tFfFJJR0hUfFJPTExCQUNLfFJPVVRJTkV8Uk9XKD86Q09VTlR8R1VJRENPTHxTKT98UlRSRUV8UlVMRXxTQVZFKD86UE9JTlQpP3xTQ0hFTUF8U0VDT05EfFNFTEVDVHxTRVJJQUwoPzpJWkFCTEUpP3xTRVNTSU9OKD86X1VTRVIpP3xTRVQoPzpVU0VSKT98U0hBUkV8U0hPV3xTSFVURE9XTnxTSU1QTEV8U01BTExJTlR8U05BUFNIT1R8U09NRXxTT05BTUV8U1FMfFNUQVJUKD86SU5HKT98U1RBVElTVElDU3xTVEFUVVN8U1RSSVBFRHxTWVNURU1fVVNFUnxUQUJMRVM/fFRBQkxFU1BBQ0V8VEVNUCg/Ok9SQVJZfFRBQkxFKT98VEVSTUlOQVRFRHxURVhUKD86U0laRSk/fFRIRU58VElNRSg/OlNUQU1QKT98VElOWSg/OkJMT0J8SU5UfFRFWFQpfFRPUD98VFJBTig/OlNBQ1RJT05TPyk/fFRSSUdHRVJ8VFJVTkNBVEV8VFNFUVVBTHxUWVBFUz98VU5CT1VOREVEfFVOQ09NTUlUVEVEfFVOREVGSU5FRHxVTklPTnxVTklRVUV8VU5MT0NLfFVOUElWT1R8VU5TSUdORUR8VVBEQVRFKD86VEVYVCk/fFVTQUdFfFVTRXxVU0VSfFVTSU5HfFZBTFVFUz98VkFSKD86QklOQVJZfENIQVJ8Q0hBUkFDVEVSfFlJTkcpfFZJRVd8V0FJVEZPUnxXQVJOSU5HU3xXSEVOfFdIRVJFfFdISUxFfFdJVEgoPzogUk9MTFVQfElOKT98V09SS3xXUklURSg/OlRFWFQpP3xZRUFSKVxcYi9pLFxuICAnYm9vbGVhbic6IC9cXGIoPzpGQUxTRXxOVUxMfFRSVUUpXFxiL2ksXG4gICdudW1iZXInOiAvXFxiMHhbXFxkYS1mXStcXGJ8XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrXFxiL2ksXG4gICdvcGVyYXRvcic6IC9bLSsqXFwvPSVefl18JiY/fFxcfFxcfD98IT0/fDwoPzo9Pj98PHw+KT98Pls+PV0/fFxcYig/OkFORHxCRVRXRUVOfERJVnxJTElLRXxJTnxJU3xMSUtFfE5PVHxPUnxSRUdFWFB8UkxJS0V8U09VTkRTIExJS0V8WE9SKVxcYi9pLFxuICAncHVuY3R1YXRpb24nOiAvWztbXFxdKClgLC5dL1xufTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWpzLXRlbXBsYXRlc1wiICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIHRlbXBsYXRlU3RyaW5nID0gUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ3RlbXBsYXRlLXN0cmluZyddOyAvLyBzZWUgdGhlIHBhdHRlcm4gaW4gcHJpc20tamF2YXNjcmlwdC5qc1xuXG4gIHZhciB0ZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuID0gdGVtcGxhdGVTdHJpbmcucGF0dGVybi5zb3VyY2U7XG4gIHZhciBpbnRlcnBvbGF0aW9uT2JqZWN0ID0gdGVtcGxhdGVTdHJpbmcuaW5zaWRlWydpbnRlcnBvbGF0aW9uJ107XG4gIHZhciBpbnRlcnBvbGF0aW9uUHVuY3R1YXRpb25PYmplY3QgPSBpbnRlcnBvbGF0aW9uT2JqZWN0Lmluc2lkZVsnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbiddO1xuICB2YXIgaW50ZXJwb2xhdGlvblBhdHRlcm4gPSBpbnRlcnBvbGF0aW9uT2JqZWN0LnBhdHRlcm4uc291cmNlO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwYXR0ZXJuIHRvIG1hdGNoIGEgdGVtcGxhdGUgc3RyaW5nIHdpdGggYSBzcGVjaWFsIHRhZy5cbiAgICpcbiAgICogVGhpcyB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZiB0aGVyZSBpcyBubyBncmFtbWFyIHdpdGggdGhlIGdpdmVuIGxhbmd1YWdlIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIGxhbmd1YWdlIGlkIG9mIHRoZSBlbWJlZGRlZCBsYW5ndWFnZS4gRS5nLiBgbWFya2Rvd25gLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSByZWdleCBwYXR0ZXJuIHRvIG1hdGNoIHRoZSB0YWcuXG4gICAqIEByZXR1cm5zIHtvYmplY3QgfCB1bmRlZmluZWR9XG4gICAqIEBleGFtcGxlXG4gICAqIGNyZWF0ZVRlbXBsYXRlKCdjc3MnLCAvXFxiY3NzLy5zb3VyY2UpO1xuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZShsYW5ndWFnZSwgdGFnKSB7XG4gICAgaWYgKCFQcmlzbS5sYW5ndWFnZXNbbGFuZ3VhZ2VdKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJygoPzonICsgdGFnICsgJylcXFxccyopJyArIHRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndGVtcGxhdGUtcHVuY3R1YXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL15gfGAkLyxcbiAgICAgICAgICBhbGlhczogJ3N0cmluZydcbiAgICAgICAgfSxcbiAgICAgICAgJ2VtYmVkZGVkLWNvZGUnOiB7XG4gICAgICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICAgICAgYWxpYXM6IGxhbmd1YWdlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ3RlbXBsYXRlLXN0cmluZyddID0gWy8vIHN0eWxlZC1qc3g6XG4gIC8vICAgY3NzYGEgeyBjb2xvcjogIzI1RjsgfWBcbiAgLy8gc3R5bGVkLWNvbXBvbmVudHM6XG4gIC8vICAgc3R5bGVkLmgxYGNvbG9yOiByZWQ7YFxuICBjcmVhdGVUZW1wbGF0ZSgnY3NzJywgL1xcYig/OnN0eWxlZCg/OlxcKFteKV0qXFwpKT8oPzpcXHMqXFwuXFxzKlxcdysoPzpcXChbXildKlxcKSkqKSp8Y3NzKD86XFxzKlxcLlxccyooPzpnbG9iYWx8cmVzb2x2ZSkpP3xjcmVhdGVHbG9iYWxTdHlsZXxrZXlmcmFtZXMpLy5zb3VyY2UpLCAvLyBodG1sYDxwPjwvcD5gXG4gIC8vIGRpdi5pbm5lckhUTUwgPSBgPHA+PC9wPmBcbiAgY3JlYXRlVGVtcGxhdGUoJ2h0bWwnLCAvXFxiaHRtbHxcXC5cXHMqKD86aW5uZXJ8b3V0ZXIpSFRNTFxccypcXCs/PS8uc291cmNlKSwgLy8gc3ZnYDxwYXRoIGZpbGw9XCIjZmZmXCIgZD1cIk01NS4zNyAuLi5cIi8+YFxuICBjcmVhdGVUZW1wbGF0ZSgnc3ZnJywgL1xcYnN2Zy8uc291cmNlKSwgLy8gbWRgIyBoMWAsIG1hcmtkb3duYCMjIGgyYFxuICBjcmVhdGVUZW1wbGF0ZSgnbWFya2Rvd24nLCAvXFxiKD86bWFya2Rvd258bWQpLy5zb3VyY2UpLCAvLyBncWxgLi4uYCwgZ3JhcGhxbGAuLi5gLCBncmFwaHFsLmV4cGVyaW1lbnRhbGAuLi5gXG4gIGNyZWF0ZVRlbXBsYXRlKCdncmFwaHFsJywgL1xcYig/OmdxbHxncmFwaHFsKD86XFxzKlxcLlxccypleHBlcmltZW50YWwpPykvLnNvdXJjZSksIC8vIHNxbGAuLi5gXG4gIGNyZWF0ZVRlbXBsYXRlKCdzcWwnLCAvXFxic3FsLy5zb3VyY2UpLCAvLyB2YW5pbGxhIHRlbXBsYXRlIHN0cmluZ1xuICB0ZW1wbGF0ZVN0cmluZ10uZmlsdGVyKEJvb2xlYW4pO1xuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmljIHBsYWNlaG9sZGVyIGxpdGVyYWwgZm9yIHRoZSBnaXZlbiBsYW5ndWFnZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFBsYWNlaG9sZGVyKGNvdW50ZXIsIGxhbmd1YWdlKSB7XG4gICAgcmV0dXJuICdfX18nICsgbGFuZ3VhZ2UudG9VcHBlckNhc2UoKSArICdfJyArIGNvdW50ZXIgKyAnX19fJztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9rZW5zIG9mIGBQcmlzbS50b2tlbml6ZWAgYnV0IGFsc28gcnVucyB0aGUgYGJlZm9yZS10b2tlbml6ZWAgYW5kIGBhZnRlci10b2tlbml6ZWAgaG9va3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAqIEBwYXJhbSB7YW55fSBncmFtbWFyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuICAgKiBAcmV0dXJucyB7KHN0cmluZ3xUb2tlbilbXX1cbiAgICovXG5cblxuICBmdW5jdGlvbiB0b2tlbml6ZVdpdGhIb29rcyhjb2RlLCBncmFtbWFyLCBsYW5ndWFnZSkge1xuICAgIHZhciBlbnYgPSB7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgZ3JhbW1hcjogZ3JhbW1hcixcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZVxuICAgIH07XG4gICAgUHJpc20uaG9va3MucnVuKCdiZWZvcmUtdG9rZW5pemUnLCBlbnYpO1xuICAgIGVudi50b2tlbnMgPSBQcmlzbS50b2tlbml6ZShlbnYuY29kZSwgZW52LmdyYW1tYXIpO1xuICAgIFByaXNtLmhvb2tzLnJ1bignYWZ0ZXItdG9rZW5pemUnLCBlbnYpO1xuICAgIHJldHVybiBlbnYudG9rZW5zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b2tlbiBvZiB0aGUgZ2l2ZW4gSmF2YVNjcmlwdCBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFRoZSBjb2RlIG9mIHRoZSBleHByZXNzaW9uLiBFLmcuIGBcIiR7NDJ9XCJgXG4gICAqIEByZXR1cm5zIHtUb2tlbn1cbiAgICovXG5cblxuICBmdW5jdGlvbiB0b2tlbml6ZUludGVycG9sYXRpb25FeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICB2YXIgdGVtcEdyYW1tYXIgPSB7fTtcbiAgICB0ZW1wR3JhbW1hclsnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbiddID0gaW50ZXJwb2xhdGlvblB1bmN0dWF0aW9uT2JqZWN0O1xuICAgIC8qKiBAdHlwZSB7QXJyYXl9ICovXG5cbiAgICB2YXIgdG9rZW5zID0gUHJpc20udG9rZW5pemUoZXhwcmVzc2lvbiwgdGVtcEdyYW1tYXIpO1xuXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDMpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRva2VuIGFycmF5IHdpbGwgbG9vayBsaWtlIHRoaXNcbiAgICAgICAqIFtcbiAgICAgICAqICAgICBbXCJpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uXCIsIFwiJHtcIl1cbiAgICAgICAqICAgICBcIi4uLlwiIC8vIEphdmFTY3JpcHQgZXhwcmVzc2lvbiBvZiB0aGUgaW50ZXJwb2xhdGlvblxuICAgICAgICogICAgIFtcImludGVycG9sYXRpb24tcHVuY3R1YXRpb25cIiwgXCJ9XCJdXG4gICAgICAgKiBdXG4gICAgICAgKi9cbiAgICAgIHZhciBhcmdzID0gWzEsIDFdO1xuICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIHRva2VuaXplV2l0aEhvb2tzKHRva2Vuc1sxXSwgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsICdqYXZhc2NyaXB0JykpO1xuICAgICAgdG9rZW5zLnNwbGljZS5hcHBseSh0b2tlbnMsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJpc20uVG9rZW4oJ2ludGVycG9sYXRpb24nLCB0b2tlbnMsIGludGVycG9sYXRpb25PYmplY3QuYWxpYXMsIGV4cHJlc3Npb24pO1xuICB9XG4gIC8qKlxuICAgKiBUb2tlbml6ZXMgdGhlIGdpdmVuIGNvZGUgd2l0aCBzdXBwb3J0IGZvciBKYXZhU2NyaXB0IGludGVycG9sYXRpb24gZXhwcmVzc2lvbnMgbWl4ZWQgaW4uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaGFzIDMgcGhhc2VzOlxuICAgKlxuICAgKiAxLiBSZXBsYWNlIGFsbCBKYXZhU2NyaXB0IGludGVycG9sYXRpb24gZXhwcmVzc2lvbiB3aXRoIGEgcGxhY2Vob2xkZXIuXG4gICAqICAgIFRoZSBwbGFjZWhvbGRlciB3aWxsIGhhdmUgdGhlIHN5bnRheCBvZiBhIGlkZW50aWZ5IG9mIHRoZSB0YXJnZXQgbGFuZ3VhZ2UuXG4gICAqIDIuIFRva2VuaXplIHRoZSBjb2RlIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgKiAzLiBUb2tlbml6ZSB0aGUgaW50ZXJwb2xhdGlvbiBleHByZXNzaW9ucyBhbmQgcmUtaW5zZXJ0IHRoZW0gaW50byB0aGUgdG9rZW5pemUgY29kZS5cbiAgICogICAgVGhlIGluc2VydGlvbiBvbmx5IHdvcmtzIGlmIGEgcGxhY2Vob2xkZXIgaGFzbid0IGJlZW4gXCJyaXBwZWQgYXBhcnRcIiBtZWFuaW5nIHRoYXQgdGhlIHBsYWNlaG9sZGVyIGhhcyBiZWVuXG4gICAqICAgIHRva2VuaXplZCBhcyB0d28gdG9rZW5zIGJ5IHRoZSBncmFtbWFyIG9mIHRoZSBlbWJlZGRlZCBsYW5ndWFnZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGdyYW1tYXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIHtUb2tlbn1cbiAgICovXG5cblxuICBmdW5jdGlvbiB0b2tlbml6ZUVtYmVkZGVkKGNvZGUsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG4gICAgLy8gMS4gRmlyc3QgZmlsdGVyIG91dCBhbGwgaW50ZXJwb2xhdGlvbnNcbiAgICAvLyBiZWNhdXNlIHRoZXkgbWlnaHQgYmUgZXNjYXBlZCwgd2UgbmVlZCBhIGxvb2tiZWhpbmQsIHNvIHdlIHVzZSBQcmlzbVxuXG4gICAgLyoqIEB0eXBlIHsoVG9rZW58c3RyaW5nKVtdfSAqL1xuICAgIHZhciBfdG9rZW5zID0gUHJpc20udG9rZW5pemUoY29kZSwge1xuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IFJlZ0V4cChpbnRlcnBvbGF0aW9uUGF0dGVybiksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgIH1cbiAgICB9KTsgLy8gcmVwbGFjZSBhbGwgaW50ZXJwb2xhdGlvbnMgd2l0aCBhIHBsYWNlaG9sZGVyIHdoaWNoIGlzIG5vdCBpbiB0aGUgY29kZSBhbHJlYWR5XG5cblxuICAgIHZhciBwbGFjZWhvbGRlckNvdW50ZXIgPSAwO1xuICAgIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gKi9cblxuICAgIHZhciBwbGFjZWhvbGRlck1hcCA9IHt9O1xuXG4gICAgdmFyIGVtYmVkZGVkQ29kZSA9IF90b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGludGVycG9sYXRpb25FeHByZXNzaW9uID0gdG9rZW4uY29udGVudDtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyO1xuXG4gICAgICAgIHdoaWxlIChjb2RlLmluZGV4T2YocGxhY2Vob2xkZXIgPSBnZXRQbGFjZWhvbGRlcihwbGFjZWhvbGRlckNvdW50ZXIrKywgbGFuZ3VhZ2UpKSAhPT0gLTEpIHtcbiAgICAgICAgICAvKiBub29wICovXG4gICAgICAgIH1cblxuICAgICAgICBwbGFjZWhvbGRlck1hcFtwbGFjZWhvbGRlcl0gPSBpbnRlcnBvbGF0aW9uRXhwcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgIH0pLmpvaW4oJycpOyAvLyAyLiBUb2tlbml6ZSB0aGUgZW1iZWRkZWQgY29kZVxuXG5cbiAgICB2YXIgZW1iZWRkZWRUb2tlbnMgPSB0b2tlbml6ZVdpdGhIb29rcyhlbWJlZGRlZENvZGUsIGdyYW1tYXIsIGxhbmd1YWdlKTsgLy8gMy4gUmUtaW5zZXJ0IHRoZSBpbnRlcnBvbGF0aW9uXG5cbiAgICB2YXIgcGxhY2Vob2xkZXJzID0gT2JqZWN0LmtleXMocGxhY2Vob2xkZXJNYXApO1xuICAgIHBsYWNlaG9sZGVyQ291bnRlciA9IDA7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhUb2tlbnxzdHJpbmcpW119IHRva2Vuc1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gd2Fsa1Rva2Vucyh0b2tlbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwbGFjZWhvbGRlckNvdW50ZXIgPj0gcGxhY2Vob2xkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdG9rZW4uY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcnNbcGxhY2Vob2xkZXJDb3VudGVyXTtcbiAgICAgICAgICB2YXIgcyA9IHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgPyB0b2tlbiA6XG4gICAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgICAgdG9rZW4uY29udGVudDtcbiAgICAgICAgICB2YXIgaW5kZXggPSBzLmluZGV4T2YocGxhY2Vob2xkZXIpO1xuXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgKytwbGFjZWhvbGRlckNvdW50ZXI7XG4gICAgICAgICAgICB2YXIgYmVmb3JlID0gcy5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIG1pZGRsZSA9IHRva2VuaXplSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24ocGxhY2Vob2xkZXJNYXBbcGxhY2Vob2xkZXJdKTtcbiAgICAgICAgICAgIHZhciBhZnRlciA9IHMuc3Vic3RyaW5nKGluZGV4ICsgcGxhY2Vob2xkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVwbGFjZW1lbnQucHVzaChtaWRkbGUpO1xuXG4gICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGFmdGVyVG9rZW5zID0gW2FmdGVyXTtcbiAgICAgICAgICAgICAgd2Fsa1Rva2VucyhhZnRlclRva2Vucyk7XG4gICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2guYXBwbHkocmVwbGFjZW1lbnQsIGFmdGVyVG9rZW5zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZS5hcHBseSh0b2tlbnMsIFtpLCAxXS5jb25jYXQocmVwbGFjZW1lbnQpKTtcbiAgICAgICAgICAgICAgaSArPSByZXBsYWNlbWVudC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IHRva2VuLmNvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xuICAgICAgICAgICAgd2Fsa1Rva2Vucyhjb250ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Fsa1Rva2VucyhbY29udGVudF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdhbGtUb2tlbnMoZW1iZWRkZWRUb2tlbnMpO1xuICAgIHJldHVybiBuZXcgUHJpc20uVG9rZW4obGFuZ3VhZ2UsIGVtYmVkZGVkVG9rZW5zLCAnbGFuZ3VhZ2UtJyArIGxhbmd1YWdlLCBjb2RlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGxhbmd1YWdlcyBmb3Igd2hpY2ggSlMgdGVtcGxhdGluZyB3aWxsIGhhbmRsZSB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEpTIHRlbXBsYXRpbmcgaXNuJ3QgYWN0aXZlIGZvciBvbmx5IEphdmFTY3JpcHQgYnV0IGFsc28gcmVsYXRlZCBsYW5ndWFnZXMgbGlrZSBUeXBlU2NyaXB0LCBKU1gsIGFuZCBUU1guXG4gICAqL1xuXG5cbiAgdmFyIHN1cHBvcnRlZExhbmd1YWdlcyA9IHtcbiAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgJ2pzJzogdHJ1ZSxcbiAgICAndHlwZXNjcmlwdCc6IHRydWUsXG4gICAgJ3RzJzogdHJ1ZSxcbiAgICAnanN4JzogdHJ1ZSxcbiAgICAndHN4JzogdHJ1ZVxuICB9O1xuICBQcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuICAgIGlmICghKGVudi5sYW5ndWFnZSBpbiBzdXBwb3J0ZWRMYW5ndWFnZXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIGFuZCB0b2tlbml6ZXMgYWxsIHRlbXBsYXRlIHN0cmluZ3Mgd2l0aCBhbiBlbWJlZGRlZCBsYW5ndWFnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhUb2tlbiB8IHN0cmluZylbXX0gdG9rZW5zXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGZpbmRUZW1wbGF0ZVN0cmluZ3ModG9rZW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGVudCA9IHRva2VuLmNvbnRlbnQ7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmluZFRlbXBsYXRlU3RyaW5ncyhbY29udGVudF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZW1wbGF0ZS1zdHJpbmcnKSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSBKYXZhU2NyaXB0IHRlbXBsYXRlLXN0cmluZyB0b2tlbiB3aWxsIGxvb2sgbGlrZSB0aGlzOlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogW1widGVtcGxhdGUtc3RyaW5nXCIsIFtcbiAgICAgICAgICAgKiAgICAgW1widGVtcGxhdGUtcHVuY3R1YXRpb25cIiwgXCJgXCJdLFxuICAgICAgICAgICAqICAgICAoXG4gICAgICAgICAgICogICAgICAgICBBbiBhcnJheSBvZiBcInN0cmluZ1wiIGFuZCBcImludGVycG9sYXRpb25cIiB0b2tlbnMuIFRoaXMgaXMgdGhlIHNpbXBsZSBzdHJpbmcgY2FzZS5cbiAgICAgICAgICAgKiAgICAgICAgIG9yXG4gICAgICAgICAgICogICAgICAgICBbXCJlbWJlZGRlZC1jb2RlXCIsIFwiLi4uXCJdIFRoaXMgaXMgdGhlIHRva2VuIGNvbnRhaW5pbmcgdGhlIGVtYmVkZGVkIGNvZGUuXG4gICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQgYWxzbyBoYXMgYW4gYWxpYXMgd2hpY2ggaXMgdGhlIGxhbmd1YWdlIG9mIHRoZSBlbWJlZGRlZCBjb2RlLlxuICAgICAgICAgICAqICAgICApLFxuICAgICAgICAgICAqICAgICBbXCJ0ZW1wbGF0ZS1wdW5jdHVhdGlvblwiLCBcImBcIl1cbiAgICAgICAgICAgKiBdXVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciBlbWJlZGRlZCA9IGNvbnRlbnRbMV07XG5cbiAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGVtYmVkZGVkICE9PSAnc3RyaW5nJyAmJiBlbWJlZGRlZC50eXBlID09PSAnZW1iZWRkZWQtY29kZScpIHtcbiAgICAgICAgICAgIC8vIGdldCBzdHJpbmcgY29udGVudFxuICAgICAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmdDb250ZW50KGVtYmVkZGVkKTtcbiAgICAgICAgICAgIHZhciBhbGlhcyA9IGVtYmVkZGVkLmFsaWFzO1xuICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gQXJyYXkuaXNBcnJheShhbGlhcykgPyBhbGlhc1swXSA6IGFsaWFzO1xuICAgICAgICAgICAgdmFyIGdyYW1tYXIgPSBQcmlzbS5sYW5ndWFnZXNbbGFuZ3VhZ2VdO1xuXG4gICAgICAgICAgICBpZiAoIWdyYW1tYXIpIHtcbiAgICAgICAgICAgICAgLy8gdGhlIGVtYmVkZGVkIGxhbmd1YWdlIGlzbid0IHJlZ2lzdGVyZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZW50WzFdID0gdG9rZW5pemVFbWJlZGRlZChjb2RlLCBncmFtbWFyLCBsYW5ndWFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbmRUZW1wbGF0ZVN0cmluZ3MoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaW5kVGVtcGxhdGVTdHJpbmdzKGVudi50b2tlbnMpO1xuICB9KTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyBjb250ZW50IG9mIGEgdG9rZW4gb3IgdG9rZW4gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFRva2VuIHwgKHN0cmluZyB8IFRva2VuKVtdfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuICBmdW5jdGlvbiBzdHJpbmdDb250ZW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWFwKHN0cmluZ0NvbnRlbnQpLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyaW5nQ29udGVudCh2YWx1ZS5jb250ZW50KTtcbiAgICB9XG4gIH1cbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXR5cGVzY3JpcHRcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdqYXZhc2NyaXB0Jywge1xuICAgICdjbGFzcy1uYW1lJzoge1xuICAgICAgcGF0dGVybjogLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3fHR5cGUpXFxzKykoPyFrZXlvZlxcYikoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD86XFxzKjwoPzpbXjw+XXw8KD86W148Pl18PFtePD5dKj4pKj4pKj4pPy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiBudWxsIC8vIHNlZSBiZWxvd1xuXG4gICAgfSxcbiAgICAnYnVpbHRpbic6IC9cXGIoPzpBcnJheXxGdW5jdGlvbnxQcm9taXNlfGFueXxib29sZWFufGNvbnNvbGV8bmV2ZXJ8bnVtYmVyfHN0cmluZ3xzeW1ib2x8dW5rbm93bilcXGIvXG4gIH0pOyAvLyBUaGUga2V5d29yZHMgVHlwZVNjcmlwdCBhZGRzIHRvIEphdmFTY3JpcHRcblxuICBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdC5rZXl3b3JkLnB1c2goL1xcYig/OmFic3RyYWN0fGRlY2xhcmV8aXN8a2V5b2Z8cmVhZG9ubHl8cmVxdWlyZSlcXGIvLCAvLyBrZXl3b3JkcyB0aGF0IGhhdmUgdG8gYmUgZm9sbG93ZWQgYnkgYW4gaWRlbnRpZmllclxuICAvXFxiKD86YXNzZXJ0c3xpbmZlcnxpbnRlcmZhY2V8bW9kdWxlfG5hbWVzcGFjZXx0eXBlKVxcYig/PVxccyooPzpbe18kYS16QS1aXFx4QTAtXFx1RkZGRl18JCkpLywgLy8gVGhpcyBpcyBmb3IgYGltcG9ydCB0eXBlICosIHt9YFxuICAvXFxidHlwZVxcYig/PVxccyooPzpbXFx7Kl18JCkpLyk7IC8vIGRvZXNuJ3Qgd29yayB3aXRoIFRTIGJlY2F1c2UgVFMgaXMgdG9vIGNvbXBsZXhcblxuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ3BhcmFtZXRlciddO1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ2xpdGVyYWwtcHJvcGVydHknXTsgLy8gYSB2ZXJzaW9uIG9mIHR5cGVzY3JpcHQgc3BlY2lmaWNhbGx5IGZvciBoaWdobGlnaHRpbmcgdHlwZXNcblxuICB2YXIgdHlwZUluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ3R5cGVzY3JpcHQnLCB7fSk7XG4gIGRlbGV0ZSB0eXBlSW5zaWRlWydjbGFzcy1uYW1lJ107XG4gIFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0WydjbGFzcy1uYW1lJ10uaW5zaWRlID0gdHlwZUluc2lkZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgndHlwZXNjcmlwdCcsICdmdW5jdGlvbicsIHtcbiAgICAnZGVjb3JhdG9yJzoge1xuICAgICAgcGF0dGVybjogL0BbJFxcd1xceEEwLVxcdUZGRkZdKy8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2F0Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eQC8sXG4gICAgICAgICAgYWxpYXM6ICdvcGVyYXRvcidcbiAgICAgICAgfSxcbiAgICAgICAgJ2Z1bmN0aW9uJzogL15bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfSxcbiAgICAnZ2VuZXJpYy1mdW5jdGlvbic6IHtcbiAgICAgIC8vIGUuZy4gZm9vPFQgZXh0ZW5kcyBcImJhclwiIHwgXCJiYXpcIj4oIC4uLlxuICAgICAgcGF0dGVybjogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKlxccyo8KD86W148Pl18PCg/OltePD5dfDxbXjw+XSo+KSo+KSo+KD89XFxzKlxcKCkvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdmdW5jdGlvbic6IC9eIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqLyxcbiAgICAgICAgJ2dlbmVyaWMnOiB7XG4gICAgICAgICAgcGF0dGVybjogLzxbXFxzXFxTXSsvLFxuICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IDxcbiAgICAgICAgICBhbGlhczogJ2NsYXNzLW5hbWUnLFxuICAgICAgICAgIGluc2lkZTogdHlwZUluc2lkZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnRzID0gUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQ7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qcy1leHRyYXNcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdmdW5jdGlvbi12YXJpYWJsZScsIHtcbiAgICAnbWV0aG9kLXZhcmlhYmxlJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCcoXFxcXC5cXFxccyopJyArIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0WydmdW5jdGlvbi12YXJpYWJsZSddLnBhdHRlcm4uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogWydmdW5jdGlvbi12YXJpYWJsZScsICdtZXRob2QnLCAnZnVuY3Rpb24nLCAncHJvcGVydHktYWNjZXNzJ11cbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2Z1bmN0aW9uJywge1xuICAgICdtZXRob2QnOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJyhcXFxcLlxcXFxzKiknICsgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ2Z1bmN0aW9uJ10uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogWydmdW5jdGlvbicsICdwcm9wZXJ0eS1hY2Nlc3MnXVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnY29uc3RhbnQnLCB7XG4gICAgJ2tub3duLWNsYXNzLW5hbWUnOiBbe1xuICAgICAgLy8gc3RhbmRhcmQgYnVpbHQtaW5zXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0c1xuICAgICAgcGF0dGVybjogL1xcYig/Oig/OkZsb2F0KD86MzJ8NjQpfCg/OkludHxVaW50KSg/Ojh8MTZ8MzIpfFVpbnQ4Q2xhbXBlZCk/QXJyYXl8QXJyYXlCdWZmZXJ8QmlnSW50fEJvb2xlYW58RGF0YVZpZXd8RGF0ZXxFcnJvcnxGdW5jdGlvbnxJbnRsfEpTT058KD86V2Vhayk/KD86TWFwfFNldCl8TWF0aHxOdW1iZXJ8T2JqZWN0fFByb21pc2V8UHJveHl8UmVmbGVjdHxSZWdFeHB8U3RyaW5nfFN5bWJvbHxXZWJBc3NlbWJseSlcXGIvLFxuICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICAgIH0sIHtcbiAgICAgIC8vIGVycm9yc1xuICAgICAgcGF0dGVybjogL1xcYig/OltBLVpdXFx3KilFcnJvclxcYi8sXG4gICAgICBhbGlhczogJ2NsYXNzLW5hbWUnXG4gICAgfV1cbiAgfSk7XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgYDxJRD5gIHBsYWNlaG9sZGVyIGluIHRoZSBnaXZlbiBwYXR0ZXJuIHdpdGggYSBwYXR0ZXJuIGZvciBnZW5lcmFsIEpTIGlkZW50aWZpZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG4gICAqIEByZXR1cm5zIHtSZWdFeHB9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHdpdGhJZChzb3VyY2UsIGZsYWdzKSB7XG4gICAgcmV0dXJuIFJlZ0V4cChzb3VyY2UucmVwbGFjZSgvPElEPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gLyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSovLnNvdXJjZTtcbiAgICB9KSwgZmxhZ3MpO1xuICB9XG5cbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdrZXl3b3JkJywge1xuICAgICdpbXBvcnRzJzoge1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pbXBvcnRzXG4gICAgICBwYXR0ZXJuOiB3aXRoSWQoLyhcXGJpbXBvcnRcXGJcXHMqKSg/OjxJRD4oPzpcXHMqLFxccyooPzpcXCpcXHMqYXNcXHMrPElEPnxcXHtbXnt9XSpcXH0pKT98XFwqXFxzKmFzXFxzKzxJRD58XFx7W157fV0qXFx9KSg/PVxccypcXGJmcm9tXFxiKS8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgfSxcbiAgICAnZXhwb3J0cyc6IHtcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZXhwb3J0c1xuICAgICAgcGF0dGVybjogd2l0aElkKC8oXFxiZXhwb3J0XFxiXFxzKikoPzpcXCooPzpcXHMqYXNcXHMrPElEPik/KD89XFxzKlxcYmZyb21cXGIpfFxce1tee31dKlxcfSkvLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0WydrZXl3b3JkJ10udW5zaGlmdCh7XG4gICAgcGF0dGVybjogL1xcYig/OmFzfGRlZmF1bHR8ZXhwb3J0fGZyb218aW1wb3J0KVxcYi8sXG4gICAgYWxpYXM6ICdtb2R1bGUnXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvXFxiKD86YXdhaXR8YnJlYWt8Y2F0Y2h8Y29udGludWV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxpZnxyZXR1cm58c3dpdGNofHRocm93fHRyeXx3aGlsZXx5aWVsZClcXGIvLFxuICAgIGFsaWFzOiAnY29udHJvbC1mbG93J1xuICB9LCB7XG4gICAgcGF0dGVybjogL1xcYm51bGxcXGIvLFxuICAgIGFsaWFzOiBbJ251bGwnLCAnbmlsJ11cbiAgfSwge1xuICAgIHBhdHRlcm46IC9cXGJ1bmRlZmluZWRcXGIvLFxuICAgIGFsaWFzOiAnbmlsJ1xuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdvcGVyYXRvcicsIHtcbiAgICAnc3ByZWFkJzoge1xuICAgICAgcGF0dGVybjogL1xcLnszfS8sXG4gICAgICBhbGlhczogJ29wZXJhdG9yJ1xuICAgIH0sXG4gICAgJ2Fycm93Jzoge1xuICAgICAgcGF0dGVybjogLz0+LyxcbiAgICAgIGFsaWFzOiAnb3BlcmF0b3InXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdwdW5jdHVhdGlvbicsIHtcbiAgICAncHJvcGVydHktYWNjZXNzJzoge1xuICAgICAgcGF0dGVybjogd2l0aElkKC8oXFwuXFxzKikjPzxJRD4vLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnbWF5YmUtY2xhc3MtbmFtZSc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSlbQS1aXVskXFx3XFx4QTAtXFx1RkZGRl0rLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdkb20nOiB7XG4gICAgICAvLyB0aGlzIGNvbnRhaW5zIG9ubHkgYSBmZXcgY29tbW9ubHkgdXNlZCBET00gdmFyaWFibGVzXG4gICAgICBwYXR0ZXJuOiAvXFxiKD86ZG9jdW1lbnR8KD86bG9jYWx8c2Vzc2lvbilTdG9yYWdlfGxvY2F0aW9ufG5hdmlnYXRvcnxwZXJmb3JtYW5jZXx3aW5kb3cpXFxiLyxcbiAgICAgIGFsaWFzOiAndmFyaWFibGUnXG4gICAgfSxcbiAgICAnY29uc29sZSc6IHtcbiAgICAgIHBhdHRlcm46IC9cXGJjb25zb2xlKD89XFxzKlxcLikvLFxuICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICAgIH1cbiAgfSk7IC8vIGFkZCAnbWF5YmUtY2xhc3MtbmFtZScgdG8gdG9rZW5zIHdoaWNoIG1pZ2h0IGJlIGEgY2xhc3MgbmFtZVxuXG4gIHZhciBtYXliZUNsYXNzTmFtZVRva2VucyA9IFsnZnVuY3Rpb24nLCAnZnVuY3Rpb24tdmFyaWFibGUnLCAnbWV0aG9kJywgJ21ldGhvZC12YXJpYWJsZScsICdwcm9wZXJ0eS1hY2Nlc3MnXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1heWJlQ2xhc3NOYW1lVG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gbWF5YmVDbGFzc05hbWVUb2tlbnNbaV07XG4gICAgdmFyIHZhbHVlID0gUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbdG9rZW5dOyAvLyBjb252ZXJ0IHJlZ2V4IHRvIG9iamVjdFxuXG4gICAgaWYgKFByaXNtLnV0aWwudHlwZSh2YWx1ZSkgPT09ICdSZWdFeHAnKSB7XG4gICAgICB2YWx1ZSA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0W3Rva2VuXSA9IHtcbiAgICAgICAgcGF0dGVybjogdmFsdWVcbiAgICAgIH07XG4gICAgfSAvLyBrZWVwIGluIG1pbmQgdGhhdCB3ZSBkb24ndCBzdXBwb3J0IGFycmF5c1xuXG5cbiAgICB2YXIgaW5zaWRlID0gdmFsdWUuaW5zaWRlIHx8IHt9O1xuICAgIHZhbHVlLmluc2lkZSA9IGluc2lkZTtcbiAgICBpbnNpZGVbJ21heWJlLWNsYXNzLW5hbWUnXSA9IC9eW0EtWl1bXFxzXFxTXSovO1xuICB9XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qc3hcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIGphdmFzY3JpcHQgPSBQcmlzbS51dGlsLmNsb25lKFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcbiAgdmFyIHNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKig/IS4pfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSlcXCpcXC8pLy5zb3VyY2U7XG4gIHZhciBicmFjZXMgPSAvKD86XFx7KD86XFx7KD86XFx7W157fV0qXFx9fFtee31dKSpcXH18W157fV0pKlxcfSkvLnNvdXJjZTtcbiAgdmFyIHNwcmVhZCA9IC8oPzpcXHs8Uz4qXFwuezN9KD86W157fV18PEJSQUNFUz4pKlxcfSkvLnNvdXJjZTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmbGFnc11cbiAgICovXG5cbiAgZnVuY3Rpb24gcmUoc291cmNlLCBmbGFncykge1xuICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC88Uz4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNwYWNlO1xuICAgIH0pLnJlcGxhY2UoLzxCUkFDRVM+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBicmFjZXM7XG4gICAgfSkucmVwbGFjZSgvPFNQUkVBRD4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNwcmVhZDtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVnRXhwKHNvdXJjZSwgZmxhZ3MpO1xuICB9XG5cbiAgc3ByZWFkID0gcmUoc3ByZWFkKS5zb3VyY2U7XG4gIFByaXNtLmxhbmd1YWdlcy5qc3ggPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCBqYXZhc2NyaXB0KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcucGF0dGVybiA9IHJlKC88XFwvPyg/OltcXHcuOi1dKyg/OjxTPisoPzpbXFx3LjokLV0rKD86PSg/OlwiKD86XFxcXFtcXHNcXFNdfFteXFxcXFwiXSkqXCJ8Jyg/OlxcXFxbXFxzXFxTXXxbXlxcXFwnXSkqJ3xbXlxcc3snXCIvPj1dK3w8QlJBQ0VTPikpP3w8U1BSRUFEPikpKjxTPipcXC8/KT8+Ly5zb3VyY2UpO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5pbnNpZGVbJ3RhZyddLnBhdHRlcm4gPSAvXjxcXC8/W15cXHM+XFwvXSovO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5pbnNpZGVbJ2F0dHItdmFsdWUnXS5wYXR0ZXJuID0gLz0oPyFcXHspKD86XCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcInwnKD86XFxcXFtcXHNcXFNdfFteXFxcXCddKSonfFteXFxzJ1wiPl0rKS87XG4gIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsndGFnJ10uaW5zaWRlWydjbGFzcy1uYW1lJ10gPSAvXltBLVpdXFx3Kig/OlxcLltBLVpdXFx3KikqJC87XG4gIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsnY29tbWVudCddID0gamF2YXNjcmlwdFsnY29tbWVudCddO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdpbnNpZGUnLCAnYXR0ci1uYW1lJywge1xuICAgICdzcHJlYWQnOiB7XG4gICAgICBwYXR0ZXJuOiByZSgvPFNQUkVBRD4vLnNvdXJjZSksXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qc3hcbiAgICB9XG4gIH0sIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnKTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ3NwZWNpYWwtYXR0cicsIHtcbiAgICAnc2NyaXB0Jzoge1xuICAgICAgLy8gQWxsb3cgZm9yIHR3byBsZXZlbHMgb2YgbmVzdGluZ1xuICAgICAgcGF0dGVybjogcmUoLz08QlJBQ0VTPi8uc291cmNlKSxcbiAgICAgIGFsaWFzOiAnbGFuZ3VhZ2UtamF2YXNjcmlwdCcsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3NjcmlwdC1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXj0oPz1cXHspLyxcbiAgICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICByZXN0OiBQcmlzbS5sYW5ndWFnZXMuanN4XG4gICAgICB9XG4gICAgfVxuICB9LCBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZyk7IC8vIFRoZSBmb2xsb3dpbmcgd2lsbCBoYW5kbGUgcGxhaW4gdGV4dCBpbnNpZGUgdGFnc1xuXG4gIHZhciBzdHJpbmdpZnlUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4uY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0b2tlbi5jb250ZW50O1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbi5jb250ZW50Lm1hcChzdHJpbmdpZnlUb2tlbikuam9pbignJyk7XG4gIH07XG5cbiAgdmFyIHdhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gICAgdmFyIG9wZW5lZFRhZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICB2YXIgbm90VGFnTm9yQnJhY2UgPSBmYWxzZTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd0YWcnICYmIHRva2VuLmNvbnRlbnRbMF0gJiYgdG9rZW4uY29udGVudFswXS50eXBlID09PSAndGFnJykge1xuICAgICAgICAgIC8vIFdlIGZvdW5kIGEgdGFnLCBub3cgZmluZCBpdHMga2luZFxuICAgICAgICAgIGlmICh0b2tlbi5jb250ZW50WzBdLmNvbnRlbnRbMF0uY29udGVudCA9PT0gJzwvJykge1xuICAgICAgICAgICAgLy8gQ2xvc2luZyB0YWdcbiAgICAgICAgICAgIGlmIChvcGVuZWRUYWdzLmxlbmd0aCA+IDAgJiYgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLnRhZ05hbWUgPT09IHN0cmluZ2lmeVRva2VuKHRva2VuLmNvbnRlbnRbMF0uY29udGVudFsxXSkpIHtcbiAgICAgICAgICAgICAgLy8gUG9wIG1hdGNoaW5nIG9wZW5pbmcgdGFnXG4gICAgICAgICAgICAgIG9wZW5lZFRhZ3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5jb250ZW50W3Rva2VuLmNvbnRlbnQubGVuZ3RoIC0gMV0uY29udGVudCA9PT0gJy8+JykgOyBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gT3BlbmluZyB0YWdcbiAgICAgICAgICAgICAgb3BlbmVkVGFncy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiBzdHJpbmdpZnlUb2tlbih0b2tlbi5jb250ZW50WzBdLmNvbnRlbnRbMV0pLFxuICAgICAgICAgICAgICAgIG9wZW5lZEJyYWNlczogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIHRva2VuLnR5cGUgPT09ICdwdW5jdHVhdGlvbicgJiYgdG9rZW4uY29udGVudCA9PT0gJ3snKSB7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBtaWdodCBoYXZlIGVudGVyZWQgYSBKU1ggY29udGV4dCBpbnNpZGUgYSB0YWdcbiAgICAgICAgICBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzKys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS5vcGVuZWRCcmFjZXMgPiAwICYmIHRva2VuLnR5cGUgPT09ICdwdW5jdHVhdGlvbicgJiYgdG9rZW4uY29udGVudCA9PT0gJ30nKSB7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBtaWdodCBoYXZlIGxlZnQgYSBKU1ggY29udGV4dCBpbnNpZGUgYSB0YWdcbiAgICAgICAgICBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm90VGFnTm9yQnJhY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub3RUYWdOb3JCcmFjZSB8fCB0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChvcGVuZWRUYWdzLmxlbmd0aCA+IDAgJiYgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLm9wZW5lZEJyYWNlcyA9PT0gMCkge1xuICAgICAgICAgIC8vIEhlcmUgd2UgYXJlIGluc2lkZSBhIHRhZywgYW5kIG5vdCBpbnNpZGUgYSBKU1ggY29udGV4dC5cbiAgICAgICAgICAvLyBUaGF0J3MgcGxhaW4gdGV4dDogZHJvcCBhbnkgdG9rZW5zIG1hdGNoZWQuXG4gICAgICAgICAgdmFyIHBsYWluVGV4dCA9IHN0cmluZ2lmeVRva2VuKHRva2VuKTsgLy8gQW5kIG1lcmdlIHRleHQgd2l0aCBhZGphY2VudCB0ZXh0XG5cbiAgICAgICAgICBpZiAoaSA8IHRva2Vucy5sZW5ndGggLSAxICYmICh0eXBlb2YgdG9rZW5zW2kgKyAxXSA9PT0gJ3N0cmluZycgfHwgdG9rZW5zW2kgKyAxXS50eXBlID09PSAncGxhaW4tdGV4dCcpKSB7XG4gICAgICAgICAgICBwbGFpblRleHQgKz0gc3RyaW5naWZ5VG9rZW4odG9rZW5zW2kgKyAxXSk7XG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA+IDAgJiYgKHR5cGVvZiB0b2tlbnNbaSAtIDFdID09PSAnc3RyaW5nJyB8fCB0b2tlbnNbaSAtIDFdLnR5cGUgPT09ICdwbGFpbi10ZXh0JykpIHtcbiAgICAgICAgICAgIHBsYWluVGV4dCA9IHN0cmluZ2lmeVRva2VuKHRva2Vuc1tpIC0gMV0pICsgcGxhaW5UZXh0O1xuICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpIC0gMSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zW2ldID0gbmV3IFByaXNtLlRva2VuKCdwbGFpbi10ZXh0JywgcGxhaW5UZXh0LCBudWxsLCBwbGFpblRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5jb250ZW50ICYmIHR5cGVvZiB0b2tlbi5jb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB3YWxrVG9rZW5zKHRva2VuLmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBQcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuICAgIGlmIChlbnYubGFuZ3VhZ2UgIT09ICdqc3gnICYmIGVudi5sYW5ndWFnZSAhPT0gJ3RzeCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YWxrVG9rZW5zKGVudi50b2tlbnMpO1xuICB9KTtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWRpZmZcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLmRpZmYgPSB7XG4gICAgJ2Nvb3JkJzogWy8vIE1hdGNoIGFsbCBraW5kcyBvZiBjb29yZCBsaW5lcyAocHJlZml4ZWQgYnkgXCIrKytcIiwgXCItLS1cIiBvciBcIioqKlwiKS5cbiAgICAvXig/OlxcKnszfXwtezN9fFxcK3szfSkuKiQvbSwgLy8gTWF0Y2ggXCJAQCAuLi4gQEBcIiBjb29yZCBsaW5lcyBpbiB1bmlmaWVkIGRpZmYuXG4gICAgL15AQC4qQEAkL20sIC8vIE1hdGNoIGNvb3JkIGxpbmVzIGluIG5vcm1hbCBkaWZmIChzdGFydHMgd2l0aCBhIG51bWJlcikuXG4gICAgL15cXGQuKiQvbV0gLy8gZGVsZXRlZCwgaW5zZXJ0ZWQsIHVuY2hhbmdlZCwgZGlmZlxuXG4gIH07XG4gIC8qKlxuICAgKiBBIG1hcCBmcm9tIHRoZSBuYW1lIG9mIGEgYmxvY2sgdG8gaXRzIGxpbmUgcHJlZml4LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAgICovXG5cbiAgdmFyIFBSRUZJWEVTID0ge1xuICAgICdkZWxldGVkLXNpZ24nOiAnLScsXG4gICAgJ2RlbGV0ZWQtYXJyb3cnOiAnPCcsXG4gICAgJ2luc2VydGVkLXNpZ24nOiAnKycsXG4gICAgJ2luc2VydGVkLWFycm93JzogJz4nLFxuICAgICd1bmNoYW5nZWQnOiAnICcsXG4gICAgJ2RpZmYnOiAnISdcbiAgfTsgLy8gYWRkIGEgdG9rZW4gZm9yIGVhY2ggcHJlZml4XG5cbiAgT2JqZWN0LmtleXMoUFJFRklYRVMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgcHJlZml4ID0gUFJFRklYRVNbbmFtZV07XG4gICAgdmFyIGFsaWFzID0gW107XG5cbiAgICBpZiAoIS9eXFx3KyQvLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIFwiZGVsZXRlZC1zaWduXCIgLT4gXCJkZWxldGVkXCJcbiAgICAgIGFsaWFzLnB1c2goL1xcdysvLmV4ZWMobmFtZSlbMF0pO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnZGlmZicpIHtcbiAgICAgIGFsaWFzLnB1c2goJ2JvbGQnKTtcbiAgICB9XG5cbiAgICBQcmlzbS5sYW5ndWFnZXMuZGlmZltuYW1lXSA9IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXig/OlsnICsgcHJlZml4ICsgJ10uKig/Olxcclxcbj98XFxufCg/IVtcXFxcc1xcXFxTXSkpKSsnLCAnbScpLFxuICAgICAgYWxpYXM6IGFsaWFzLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdsaW5lJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oLikoPz1bXFxzXFxTXSkuKig/Olxcclxcbj98XFxuKT8vLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByZWZpeCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvW1xcc1xcU10vLFxuICAgICAgICAgIGFsaWFzOiAvXFx3Ky8uZXhlYyhuYW1lKVswXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSk7IC8vIG1ha2UgcHJlZml4ZXMgYXZhaWxhYmxlIHRvIERpZmYgcGx1Z2luXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXNtLmxhbmd1YWdlcy5kaWZmLCAnUFJFRklYRVMnLCB7XG4gICAgdmFsdWU6IFBSRUZJWEVTXG4gIH0pO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tZ2l0XCIgKi9cblxuXG5wcmlzbS5sYW5ndWFnZXMuZ2l0ID0ge1xuICAvKlxuICAgKiBBIHNpbXBsZSBvbmUgbGluZSBjb21tZW50IGxpa2UgaW4gYSBnaXQgc3RhdHVzIGNvbW1hbmRcbiAgICogRm9yIGluc3RhbmNlOlxuICAgKiAkIGdpdCBzdGF0dXNcbiAgICogIyBPbiBicmFuY2ggaW5maW5pdGUtc2Nyb2xsXG4gICAqICMgWW91ciBicmFuY2ggYW5kICdvcmlnaW4vc2hhcmVkQnJhbmNoZXMvZnJvbnRlbmRUZWFtL2luZmluaXRlLXNjcm9sbCcgaGF2ZSBkaXZlcmdlZCxcbiAgICogIyBhbmQgaGF2ZSAxIGFuZCAyIGRpZmZlcmVudCBjb21taXRzIGVhY2gsIHJlc3BlY3RpdmVseS5cbiAgICogbm90aGluZyB0byBjb21taXQgKHdvcmtpbmcgZGlyZWN0b3J5IGNsZWFuKVxuICAgKi9cbiAgJ2NvbW1lbnQnOiAvXiMuKi9tLFxuXG4gIC8qXG4gICAqIFJlZ2V4cCB0byBtYXRjaCB0aGUgY2hhbmdlZCBsaW5lcyBpbiBhIGdpdCBkaWZmIG91dHB1dC4gQ2hlY2sgdGhlIGV4YW1wbGUgYmVsb3cuXG4gICAqL1xuICAnZGVsZXRlZCc6IC9eWy3igJNdLiovbSxcbiAgJ2luc2VydGVkJzogL15cXCsuKi9tLFxuXG4gIC8qXG4gICAqIGEgc3RyaW5nIChkb3VibGUgYW5kIHNpbXBsZSBxdW90ZSlcbiAgICovXG4gICdzdHJpbmcnOiAvKFwifCcpKD86XFxcXC58KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG5cbiAgLypcbiAgICogYSBnaXQgY29tbWFuZC4gSXQgc3RhcnRzIHdpdGggYSByYW5kb20gcHJvbXB0IGZpbmlzaGluZyBieSBhICQsIHRoZW4gXCJnaXRcIiB0aGVuIHNvbWUgb3RoZXIgcGFyYW1ldGVyc1xuICAgKiBGb3IgaW5zdGFuY2U6XG4gICAqICQgZ2l0IGFkZCBmaWxlLnR4dFxuICAgKi9cbiAgJ2NvbW1hbmQnOiB7XG4gICAgcGF0dGVybjogL14uKlxcJCBnaXQgLiokL20sXG4gICAgaW5zaWRlOiB7XG4gICAgICAvKlxuICAgICAgICogQSBnaXQgY29tbWFuZCBjYW4gY29udGFpbiBhIHBhcmFtZXRlciBzdGFydGluZyBieSBhIHNpbmdsZSBvciBhIGRvdWJsZSBkYXNoIGZvbGxvd2VkIGJ5IGEgc3RyaW5nXG4gICAgICAgKiBGb3IgaW5zdGFuY2U6XG4gICAgICAgKiAkIGdpdCBkaWZmIC0tY2FjaGVkXG4gICAgICAgKiAkIGdpdCBsb2cgLXBcbiAgICAgICAqL1xuICAgICAgJ3BhcmFtZXRlcic6IC9cXHMtLT9cXHcrL1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgKiBDb29yZGluYXRlcyBkaXNwbGF5ZWQgaW4gYSBnaXQgZGlmZiBjb21tYW5kXG4gICAqIEZvciBpbnN0YW5jZTpcbiAgICogJCBnaXQgZGlmZlxuICAgKiBkaWZmIC0tZ2l0IGZpbGUudHh0IGZpbGUudHh0XG4gICAqIGluZGV4IDYyMTQ5NTMuLjFkNTRhNTIgMTAwNjQ0XG4gICAqIC0tLSBmaWxlLnR4dFxuICAgKiArKysgZmlsZS50eHRcbiAgICogQEAgLTEgKzEsMiBAQFxuICAgKiAtSGVyZSdzIG15IHRldHggZmlsZVxuICAgKiArSGVyZSdzIG15IHRleHQgZmlsZVxuICAgKiArQW5kIHRoaXMgaXMgdGhlIHNlY29uZCBsaW5lXG4gICAqL1xuICAnY29vcmQnOiAvXkBALipAQCQvbSxcblxuICAvKlxuICAgKiBNYXRjaCBhIFwiY29tbWl0IFtTSEExXVwiIGxpbmUgaW4gYSBnaXQgbG9nIG91dHB1dC5cbiAgICogRm9yIGluc3RhbmNlOlxuICAgKiAkIGdpdCBsb2dcbiAgICogY29tbWl0IGExMWExNGVmN2UyNmYyY2E2MmQ0YjM1ZWFjNDU1Y2U2MzZkMGRjMDlcbiAgICogQXV0aG9yOiBsZ2lyYXVkZWxcbiAgICogRGF0ZTogICBNb24gRmViIDE3IDExOjE4OjM0IDIwMTQgKzAxMDBcbiAgICpcbiAgICogICAgIEFkZCBvZiBhIG5ldyBsaW5lXG4gICAqL1xuICAnY29tbWl0LXNoYTEnOiAvXmNvbW1pdCBcXHd7NDB9JC9tXG59O1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tZ29cIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMuZ28gPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcIig/OlxcXFwufFteXCJcXFxcXFxyXFxuXSkqXCJ8YFteYF0qYC8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86YnJlYWt8Y2FzZXxjaGFufGNvbnN0fGNvbnRpbnVlfGRlZmF1bHR8ZGVmZXJ8ZWxzZXxmYWxsdGhyb3VnaHxmb3J8ZnVuY3xnbyg/OnRvKT98aWZ8aW1wb3J0fGludGVyZmFjZXxtYXB8cGFja2FnZXxyYW5nZXxyZXR1cm58c2VsZWN0fHN0cnVjdHxzd2l0Y2h8dHlwZXx2YXIpXFxiLyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86X3xmYWxzZXxpb3RhfG5pbHx0cnVlKVxcYi8sXG4gICdudW1iZXInOiBbLy8gYmluYXJ5IGFuZCBvY3RhbCBpbnRlZ2Vyc1xuICAvXFxiMCg/OmJbMDFfXSt8b1swLTdfXSspaT9cXGIvaSwgLy8gaGV4YWRlY2ltYWwgaW50ZWdlcnMgYW5kIGZsb2F0c1xuICAvXFxiMHgoPzpbYS1mXFxkX10rKD86XFwuW2EtZlxcZF9dKik/fFxcLlthLWZcXGRfXSspKD86cFsrLV0/XFxkKyg/Ol9cXGQrKSopP2k/KD8hXFx3KS9pLCAvLyBkZWNpbWFsIGludGVnZXJzIGFuZCBmbG9hdHNcbiAgLyg/OlxcYlxcZFtcXGRfXSooPzpcXC5bXFxkX10qKT98XFxCXFwuXFxkW1xcZF9dKikoPzplWystXT9bXFxkX10rKT9pPyg/IVxcdykvaV0sXG4gICdvcGVyYXRvcic6IC9bKlxcLyVeIT1dPT98XFwrWz0rXT98LVs9LV0/fFxcfFs9fF0/fCYoPzo9fCZ8XFxePT8pP3w+KD86Pj0/fD0pP3w8KD86PD0/fD18LSk/fDo9fFxcLlxcLlxcLi8sXG4gICdidWlsdGluJzogL1xcYig/OmFwcGVuZHxib29sfGJ5dGV8Y2FwfGNsb3NlfGNvbXBsZXh8Y29tcGxleCg/OjY0fDEyOCl8Y29weXxkZWxldGV8ZXJyb3J8ZmxvYXQoPzozMnw2NCl8dT9pbnQoPzo4fDE2fDMyfDY0KT98aW1hZ3xsZW58bWFrZXxuZXd8cGFuaWN8cHJpbnQoPzpsbik/fHJlYWx8cmVjb3ZlcnxydW5lfHN0cmluZ3x1aW50cHRyKVxcYi9cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnZ28nLCAnc3RyaW5nJywge1xuICAnY2hhcic6IHtcbiAgICBwYXR0ZXJuOiAvJyg/OlxcXFwufFteJ1xcXFxcXHJcXG5dKXswLDEwfScvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XG59KTtcbmRlbGV0ZSBwcmlzbS5sYW5ndWFnZXMuZ29bJ2NsYXNzLW5hbWUnXTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW1hcmt1cC10ZW1wbGF0aW5nXCIgKi9cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgZm9yIHRoZSBnaXZlbiBsYW5ndWFnZSBpZCBhbmQgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRQbGFjZWhvbGRlcihsYW5ndWFnZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gJ19fXycgKyBsYW5ndWFnZS50b1VwcGVyQ2FzZSgpICsgaW5kZXggKyAnX19fJztcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFByaXNtLmxhbmd1YWdlc1snbWFya3VwLXRlbXBsYXRpbmcnXSA9IHt9LCB7XG4gICAgYnVpbGRQbGFjZWhvbGRlcnM6IHtcbiAgICAgIC8qKlxuICAgICAgICogVG9rZW5pemUgYWxsIGlubGluZSB0ZW1wbGF0aW5nIGV4cHJlc3Npb25zIG1hdGNoaW5nIGBwbGFjZWhvbGRlclBhdHRlcm5gLlxuICAgICAgICpcbiAgICAgICAqIElmIGByZXBsYWNlRmlsdGVyYCBpcyBwcm92aWRlZCwgb25seSBtYXRjaGVzIG9mIGBwbGFjZWhvbGRlclBhdHRlcm5gIGZvciB3aGljaCBgcmVwbGFjZUZpbHRlcmAgcmV0dXJuc1xuICAgICAgICogYHRydWVgIHdpbGwgYmUgcmVwbGFjZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IGVudiBUaGUgZW52aXJvbm1lbnQgb2YgdGhlIGBiZWZvcmUtdG9rZW5pemVgIGhvb2suXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIGxhbmd1YWdlIGlkLlxuICAgICAgICogQHBhcmFtIHtSZWdFeHB9IHBsYWNlaG9sZGVyUGF0dGVybiBUaGUgbWF0Y2hlcyBvZiB0aGlzIHBhdHRlcm4gd2lsbCBiZSByZXBsYWNlZCBieSBwbGFjZWhvbGRlcnMuXG4gICAgICAgKiBAcGFyYW0geyhtYXRjaDogc3RyaW5nKSA9PiBib29sZWFufSBbcmVwbGFjZUZpbHRlcl1cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlbnYsIGxhbmd1YWdlLCBwbGFjZWhvbGRlclBhdHRlcm4sIHJlcGxhY2VGaWx0ZXIpIHtcbiAgICAgICAgaWYgKGVudi5sYW5ndWFnZSAhPT0gbGFuZ3VhZ2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9rZW5TdGFjayA9IGVudi50b2tlblN0YWNrID0gW107XG4gICAgICAgIGVudi5jb2RlID0gZW52LmNvZGUucmVwbGFjZShwbGFjZWhvbGRlclBhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZUZpbHRlciA9PT0gJ2Z1bmN0aW9uJyAmJiAhcmVwbGFjZUZpbHRlcihtYXRjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaSA9IHRva2VuU3RhY2subGVuZ3RoO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlcjsgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIHN0cmluZ3NcblxuICAgICAgICAgIHdoaWxlIChlbnYuY29kZS5pbmRleE9mKHBsYWNlaG9sZGVyID0gZ2V0UGxhY2Vob2xkZXIobGFuZ3VhZ2UsIGkpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICB9IC8vIENyZWF0ZSBhIHNwYXJzZSBhcnJheVxuXG5cbiAgICAgICAgICB0b2tlblN0YWNrW2ldID0gbWF0Y2g7XG4gICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgICAgICB9KTsgLy8gU3dpdGNoIHRoZSBncmFtbWFyIHRvIG1hcmt1cFxuXG4gICAgICAgIGVudi5ncmFtbWFyID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRva2VuaXplUGxhY2Vob2xkZXJzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2UgcGxhY2Vob2xkZXJzIHdpdGggcHJvcGVyIHRva2VucyBhZnRlciB0b2tlbml6aW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbnYgVGhlIGVudmlyb25tZW50IG9mIHRoZSBgYWZ0ZXItdG9rZW5pemVgIGhvb2suXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIGxhbmd1YWdlIGlkLlxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGVudiwgbGFuZ3VhZ2UpIHtcbiAgICAgICAgaWYgKGVudi5sYW5ndWFnZSAhPT0gbGFuZ3VhZ2UgfHwgIWVudi50b2tlblN0YWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN3aXRjaCB0aGUgZ3JhbW1hciBiYWNrXG5cblxuICAgICAgICBlbnYuZ3JhbW1hciA9IFByaXNtLmxhbmd1YWdlc1tsYW5ndWFnZV07XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbnYudG9rZW5TdGFjayk7XG5cbiAgICAgICAgZnVuY3Rpb24gd2Fsa1Rva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gYWxsIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKGogPj0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgfHwgdG9rZW4uY29udGVudCAmJiB0eXBlb2YgdG9rZW4uY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICB2YXIgdCA9IGVudi50b2tlblN0YWNrW2tdO1xuICAgICAgICAgICAgICB2YXIgcyA9IHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgPyB0b2tlbiA6IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldFBsYWNlaG9sZGVyKGxhbmd1YWdlLCBrKTtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcy5pbmRleE9mKHBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgICAgICB2YXIgYmVmb3JlID0gcy5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBtaWRkbGUgPSBuZXcgUHJpc20uVG9rZW4obGFuZ3VhZ2UsIFByaXNtLnRva2VuaXplKHQsIGVudi5ncmFtbWFyKSwgJ2xhbmd1YWdlLScgKyBsYW5ndWFnZSwgdCk7XG4gICAgICAgICAgICAgICAgdmFyIGFmdGVyID0gcy5zdWJzdHJpbmcoaW5kZXggKyBwbGFjZWhvbGRlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucHVzaC5hcHBseShyZXBsYWNlbWVudCwgd2Fsa1Rva2VucyhbYmVmb3JlXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2gobWlkZGxlKTtcblxuICAgICAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucHVzaC5hcHBseShyZXBsYWNlbWVudCwgd2Fsa1Rva2VucyhbYWZ0ZXJdKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5zcGxpY2UuYXBwbHkodG9rZW5zLCBbaSwgMV0uY29uY2F0KHJlcGxhY2VtZW50KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4uY29udGVudFxuICAgICAgICAgICAgLyogJiYgdHlwZW9mIHRva2VuLmNvbnRlbnQgIT09ICdzdHJpbmcnICovXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB3YWxrVG9rZW5zKHRva2VuLmNvbnRlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgfVxuXG4gICAgICAgIHdhbGtUb2tlbnMoZW52LnRva2Vucyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWhhbmRsZWJhcnNcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLmhhbmRsZWJhcnMgPSB7XG4gICAgJ2NvbW1lbnQnOiAvXFx7XFx7IVtcXHNcXFNdKj9cXH1cXH0vLFxuICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICBwYXR0ZXJuOiAvXlxce1xce1xcez98XFx9XFx9XFx9PyQvLFxuICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICB9LFxuICAgICdzdHJpbmcnOiAvKFtcIiddKSg/OlxcXFwufCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuICAgICdudW1iZXInOiAvXFxiMHhbXFxkQS1GYS1mXStcXGJ8KD86XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrKSg/OltFZV1bKy1dP1xcZCspPy8sXG4gICAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAgICdibG9jayc6IHtcbiAgICAgIHBhdHRlcm46IC9eKFxccyooPzp+XFxzKik/KVsjXFwvXVxcUys/KD89XFxzKig/On5cXHMqKT8kfFxccykvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAna2V5d29yZCdcbiAgICB9LFxuICAgICdicmFja2V0cyc6IHtcbiAgICAgIHBhdHRlcm46IC9cXFtbXlxcXV0rXFxdLyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBwdW5jdHVhdGlvbjogL1xcW3xcXF0vLFxuICAgICAgICB2YXJpYWJsZTogL1tcXHNcXFNdKy9cbiAgICAgIH1cbiAgICB9LFxuICAgICdwdW5jdHVhdGlvbic6IC9bIVwiIyUmJzooKSorLC5cXC87PD0+QFxcW1xcXFxcXF1eYHt8fX5dLyxcbiAgICAndmFyaWFibGUnOiAvW14hXCIjJSYnKCkqKyxcXC87PD0+QFxcW1xcXFxcXF1eYHt8fX5cXHNdKy9cbiAgfTtcbiAgUHJpc20uaG9va3MuYWRkKCdiZWZvcmUtdG9rZW5pemUnLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgdmFyIGhhbmRsZWJhcnNQYXR0ZXJuID0gL1xce1xce1xce1tcXHNcXFNdKz9cXH1cXH1cXH18XFx7XFx7W1xcc1xcU10rP1xcfVxcfS9nO1xuICAgIFByaXNtLmxhbmd1YWdlc1snbWFya3VwLXRlbXBsYXRpbmcnXS5idWlsZFBsYWNlaG9sZGVycyhlbnYsICdoYW5kbGViYXJzJywgaGFuZGxlYmFyc1BhdHRlcm4pO1xuICB9KTtcbiAgUHJpc20uaG9va3MuYWRkKCdhZnRlci10b2tlbml6ZScsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICBQcmlzbS5sYW5ndWFnZXNbJ21hcmt1cC10ZW1wbGF0aW5nJ10udG9rZW5pemVQbGFjZWhvbGRlcnMoZW52LCAnaGFuZGxlYmFycycpO1xuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmhicyA9IFByaXNtLmxhbmd1YWdlcy5oYW5kbGViYXJzO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tanNvblwiICovXG4vLyBodHRwczovL3d3dy5qc29uLm9yZy9qc29uLWVuLmh0bWxcblxuXG5wcmlzbS5sYW5ndWFnZXMuanNvbiA9IHtcbiAgJ3Byb3BlcnR5Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVwiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIig/PVxccyo6KS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcIig/OlxcXFwufFteXFxcXFwiXFxyXFxuXSkqXCIoPyFcXHMqOikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC9cXC9cXC8uKnxcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ251bWJlcic6IC8tP1xcYlxcZCsoPzpcXC5cXGQrKT8oPzplWystXT9cXGQrKT9cXGIvaSxcbiAgJ3B1bmN0dWF0aW9uJzogL1t7fVtcXF0sXS8sXG4gICdvcGVyYXRvcic6IC86LyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAnbnVsbCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxibnVsbFxcYi8sXG4gICAgYWxpYXM6ICdrZXl3b3JkJ1xuICB9XG59O1xucHJpc20ubGFuZ3VhZ2VzLndlYm1hbmlmZXN0ID0gcHJpc20ubGFuZ3VhZ2VzLmpzb247XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1sZXNzXCIgKi9cblxuLyogRklYTUUgOlxuIDpleHRlbmQoKSBpcyBub3QgaGFuZGxlZCBzcGVjaWZpY2FsbHkgOiBpdHMgaGlnaGxpZ2h0aW5nIGlzIGJ1Z2d5LlxuIE1peGluIHVzYWdlIG11c3QgYmUgaW5zaWRlIGEgcnVsZXNldCB0byBiZSBoaWdobGlnaHRlZC5cbiBBdC1ydWxlcyAoZS5nLiBpbXBvcnQpIGNvbnRhaW5pbmcgaW50ZXJwb2xhdGlvbnMgYXJlIGJ1Z2d5LlxuIERldGFjaGVkIHJ1bGVzZXRzIGFyZSBoaWdobGlnaHRlZCBhcyBhdC1ydWxlcy5cbiBBIGNvbW1lbnQgYmVmb3JlIGEgbWl4aW4gdXNhZ2UgcHJldmVudHMgdGhlIGxhdHRlciB0byBiZSBwcm9wZXJseSBoaWdobGlnaHRlZC5cbiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMubGVzcyA9IHByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NzcycsIHtcbiAgJ2NvbW1lbnQnOiBbL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vLCB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pXFwvXFwvLiovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfV0sXG4gICdhdHJ1bGUnOiB7XG4gICAgcGF0dGVybjogL0BbXFx3LV0oPzpcXCgoPzpbXigpe31dfFxcKFteKCl7fV0qXFwpKSpcXCl8W14oKXt9O1xcc118XFxzKyg/IVxccykpKj8oPz1cXHMqXFx7KS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncHVuY3R1YXRpb24nOiAvWzooKV0vXG4gICAgfVxuICB9LFxuICAvLyBzZWxlY3RvcnMgYW5kIG1peGlucyBhcmUgY29uc2lkZXJlZCB0aGUgc2FtZVxuICAnc2VsZWN0b3InOiB7XG4gICAgcGF0dGVybjogLyg/OkBcXHtbXFx3LV0rXFx9fFtee307XFxzQF0pKD86QFxce1tcXHctXStcXH18XFwoKD86W14oKXt9XXxcXChbXigpe31dKlxcKSkqXFwpfFteKCl7fTtAXFxzXXxcXHMrKD8hXFxzKSkqPyg/PVxccypcXHspLyxcbiAgICBpbnNpZGU6IHtcbiAgICAgIC8vIG1peGluIHBhcmFtZXRlcnNcbiAgICAgICd2YXJpYWJsZSc6IC9AK1tcXHctXSsvXG4gICAgfVxuICB9LFxuICAncHJvcGVydHknOiAvKD86QFxce1tcXHctXStcXH18W1xcdy1dKSsoPzpcXCtfPyk/KD89XFxzKjopLyxcbiAgJ29wZXJhdG9yJzogL1srXFwtKlxcL10vXG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2xlc3MnLCAncHJvcGVydHknLCB7XG4gICd2YXJpYWJsZSc6IFsvLyBWYXJpYWJsZSBkZWNsYXJhdGlvbiAodGhlIGNvbG9uIG11c3QgYmUgY29uc3VtZWQhKVxuICB7XG4gICAgcGF0dGVybjogL0BbXFx3LV0rXFxzKjovLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogLzovXG4gICAgfVxuICB9LCAvLyBWYXJpYWJsZSB1c2FnZVxuICAvQEA/W1xcdy1dKy9dLFxuICAnbWl4aW4tdXNhZ2UnOiB7XG4gICAgcGF0dGVybjogLyhbeztdXFxzKilbLiNdKD8hXFxkKVtcXHctXS4qPyg/PVsoO10pLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH1cbn0pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFrZWZpbGVcIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMubWFrZWZpbGUgPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSMoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlxcXFxcXHJcXG5dKSovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnYnVpbHRpbi10YXJnZXQnOiB7XG4gICAgcGF0dGVybjogL1xcLltBLVpdW146Iz1cXHNdKyg/PVxccyo6KD8hPSkpLyxcbiAgICBhbGlhczogJ2J1aWx0aW4nXG4gIH0sXG4gICd0YXJnZXQnOiB7XG4gICAgcGF0dGVybjogL14oPzpbXjo9XFxzXXxbIFxcdF0rKD8hW1xcczpdKSkrKD89XFxzKjooPyE9KSkvbSxcbiAgICBhbGlhczogJ3N5bWJvbCcsXG4gICAgaW5zaWRlOiB7XG4gICAgICAndmFyaWFibGUnOiAvXFwkKyg/Oig/IVxcJClbXigpe306Iz1cXHNdK3woPz1bKHtdKSkvXG4gICAgfVxuICB9LFxuICAndmFyaWFibGUnOiAvXFwkKyg/Oig/IVxcJClbXigpe306Iz1cXHNdK3xcXChbQColPF4rP11bREZdXFwpfCg/PVsoe10pKS8sXG4gIC8vIERpcmVjdGl2ZXNcbiAgJ2tleXdvcmQnOiAvLWluY2x1ZGVcXGJ8XFxiKD86ZGVmaW5lfGVsc2V8ZW5kZWZ8ZW5kaWZ8ZXhwb3J0fGlmbj9kZWZ8aWZuP2VxfGluY2x1ZGV8b3ZlcnJpZGV8cHJpdmF0ZXxzaW5jbHVkZXx1bmRlZmluZXx1bmV4cG9ydHx2cGF0aClcXGIvLFxuICAnZnVuY3Rpb24nOiB7XG4gICAgcGF0dGVybjogLyhcXCgpKD86YWJzcGF0aHxhZGRzdWZmaXh8YW5kfGJhc2VuYW1lfGNhbGx8ZGlyfGVycm9yfGV2YWx8ZmlsZXxmaWx0ZXIoPzotb3V0KT98ZmluZHN0cmluZ3xmaXJzdHdvcmR8Zmxhdm9yfGZvcmVhY2h8Z3VpbGV8aWZ8aW5mb3xqb2lufGxhc3R3b3JkfGxvYWR8bm90ZGlyfG9yfG9yaWdpbnxwYXRzdWJzdHxyZWFscGF0aHxzaGVsbHxzb3J0fHN0cmlwfHN1YnN0fHN1ZmZpeHx2YWx1ZXx3YXJuaW5nfHdpbGRjYXJkfHdvcmQoPzpsaXN0fHMpPykoPz1bIFxcdF0pLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdvcGVyYXRvcic6IC8oPzo6OnxbPzorIV0pPz18W3xAXS8sXG4gICdwdW5jdHVhdGlvbic6IC9bOjsoKXt9XS9cbn07XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1vYmplY3RpdmVjXCIgKi9cblxucHJpc20ubGFuZ3VhZ2VzLm9iamVjdGl2ZWMgPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjJywge1xuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC9AP1wiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cIlxcXFxcXHJcXG5dKSpcIi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/OmFzbXxhdXRvfGJyZWFrfGNhc2V8Y2hhcnxjb25zdHxjb250aW51ZXxkZWZhdWx0fGRvfGRvdWJsZXxlbHNlfGVudW18ZXh0ZXJufGZsb2F0fGZvcnxnb3RvfGlmfGlufGlubGluZXxpbnR8bG9uZ3xyZWdpc3RlcnxyZXR1cm58c2VsZnxzaG9ydHxzaWduZWR8c2l6ZW9mfHN0YXRpY3xzdHJ1Y3R8c3VwZXJ8c3dpdGNofHR5cGVkZWZ8dHlwZW9mfHVuaW9ufHVuc2lnbmVkfHZvaWR8dm9sYXRpbGV8d2hpbGUpXFxifCg/OkBpbnRlcmZhY2V8QGVuZHxAaW1wbGVtZW50YXRpb258QHByb3RvY29sfEBjbGFzc3xAcHVibGljfEBwcm90ZWN0ZWR8QHByaXZhdGV8QHByb3BlcnR5fEB0cnl8QGNhdGNofEBmaW5hbGx5fEB0aHJvd3xAc3ludGhlc2l6ZXxAZHluYW1pY3xAc2VsZWN0b3IpXFxiLyxcbiAgJ29wZXJhdG9yJzogLy1bLT5dP3xcXCtcXCs/fCE9P3w8PD89P3w+Pj89P3w9PT98JiY/fFxcfFxcfD98W35eJT8qXFwvQF0vXG59KTtcbmRlbGV0ZSBwcmlzbS5sYW5ndWFnZXMub2JqZWN0aXZlY1snY2xhc3MtbmFtZSddO1xucHJpc20ubGFuZ3VhZ2VzLm9iamMgPSBwcmlzbS5sYW5ndWFnZXMub2JqZWN0aXZlYztcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW9jYW1sXCIgKi9cbi8vIGh0dHBzOi8vb2NhbWwub3JnL21hbnVhbC9sZXguaHRtbFxuXG5wcmlzbS5sYW5ndWFnZXMub2NhbWwgPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC9cXChcXCpbXFxzXFxTXSo/XFwqXFwpLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2NoYXInOiB7XG4gICAgcGF0dGVybjogLycoPzpbXlxcXFxcXHJcXG4nXXxcXFxcKD86Lnxbb3hdP1swLTlhLWZdezEsM30pKScvaSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3N0cmluZyc6IFt7XG4gICAgcGF0dGVybjogL1wiKD86XFxcXCg/OltcXHNcXFNdfFxcclxcbil8W15cXFxcXFxyXFxuXCJdKSpcIi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvXFx7KFthLXpfXSopXFx8W1xcc1xcU10qP1xcfFxcMVxcfS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH1dLFxuICAnbnVtYmVyJzogWy8vIGJpbmFyeSBhbmQgb2N0YWxcbiAgL1xcYig/OjBiWzAxXVswMV9dKnwwb1swLTddWzAtN19dKilcXGIvaSwgLy8gaGV4YWRlY2ltYWxcbiAgL1xcYjB4W2EtZjAtOV1bYS1mMC05X10qKD86XFwuW2EtZjAtOV9dKik/KD86cFsrLV0/XFxkW1xcZF9dKik/KD8hXFx3KS9pLCAvLyBkZWNpbWFsXG4gIC9cXGJcXGRbXFxkX10qKD86XFwuW1xcZF9dKik/KD86ZVsrLV0/XFxkW1xcZF9dKik/KD8hXFx3KS9pXSxcbiAgJ2RpcmVjdGl2ZSc6IHtcbiAgICBwYXR0ZXJuOiAvXFxCI1xcdysvLFxuICAgIGFsaWFzOiAncHJvcGVydHknXG4gIH0sXG4gICdsYWJlbCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxCflxcdysvLFxuICAgIGFsaWFzOiAncHJvcGVydHknXG4gIH0sXG4gICd0eXBlLXZhcmlhYmxlJzoge1xuICAgIHBhdHRlcm46IC9cXEInXFx3Ky8sXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfSxcbiAgJ3ZhcmlhbnQnOiB7XG4gICAgcGF0dGVybjogL2BcXHcrLyxcbiAgICBhbGlhczogJ3N5bWJvbCdcbiAgfSxcbiAgLy8gRm9yIHRoZSBsaXN0IG9mIGtleXdvcmRzIGFuZCBvcGVyYXRvcnMsXG4gIC8vIHNlZTogaHR0cDovL2NhbWwuaW5yaWEuZnIvcHViL2RvY3MvbWFudWFsLW9jYW1sL2xleC5odG1sI3NlYzg0XG4gICdrZXl3b3JkJzogL1xcYig/OmFzfGFzc2VydHxiZWdpbnxjbGFzc3xjb25zdHJhaW50fGRvfGRvbmV8ZG93bnRvfGVsc2V8ZW5kfGV4Y2VwdGlvbnxleHRlcm5hbHxmb3J8ZnVufGZ1bmN0aW9ufGZ1bmN0b3J8aWZ8aW58aW5jbHVkZXxpbmhlcml0fGluaXRpYWxpemVyfGxhenl8bGV0fG1hdGNofG1ldGhvZHxtb2R1bGV8bXV0YWJsZXxuZXd8bm9ucmVjfG9iamVjdHxvZnxvcGVufHByaXZhdGV8cmVjfHNpZ3xzdHJ1Y3R8dGhlbnx0b3x0cnl8dHlwZXx2YWx8dmFsdWV8dmlydHVhbHx3aGVufHdoZXJlfHdoaWxlfHdpdGgpXFxiLyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAnb3BlcmF0b3ItbGlrZS1wdW5jdHVhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvXFxbWzw+fF18Wz58XVxcXXxcXHs8fD5cXH0vLFxuICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gIH0sXG4gIC8vIEN1c3RvbSBvcGVyYXRvcnMgYXJlIGFsbG93ZWRcbiAgJ29wZXJhdG9yJzogL1xcLlsufl18Ols9Pl18Wz08PkBefCYrXFwtKlxcLyQlIT9+XVshJCUmKitcXC0uXFwvOjw9Pj9AXnx+XSp8XFxiKD86YW5kfGFzcnxsYW5kfGxvcnxsc2x8bHNyfGx4b3J8bW9kfG9yKVxcYi8sXG4gICdwdW5jdHVhdGlvbic6IC87O3w6OnxbKCl7fVxcW1xcXS4sOjsjXXxcXGJfXFxiL1xufTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXB5dGhvblwiICovXG5cbnByaXNtLmxhbmd1YWdlcy5weXRob24gPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSMuKi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3N0cmluZy1pbnRlcnBvbGF0aW9uJzoge1xuICAgIHBhdHRlcm46IC8oPzpmfGZyfHJmKSg/OihcIlwiXCJ8JycnKVtcXHNcXFNdKj9cXDF8KFwifCcpKD86XFxcXC58KD8hXFwyKVteXFxcXFxcclxcbl0pKlxcMikvaSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnaW50ZXJwb2xhdGlvbic6IHtcbiAgICAgICAgLy8gXCJ7XCIgPGV4cHJlc3Npb24+IDxvcHRpb25hbCBcIiFzXCIsIFwiIXJcIiwgb3IgXCIhYVwiPiA8b3B0aW9uYWwgXCI6XCIgZm9ybWF0IHNwZWNpZmllcj4gXCJ9XCJcbiAgICAgICAgcGF0dGVybjogLygoPzpefFtee10pKD86XFx7XFx7KSopXFx7KD8hXFx7KSg/Oltee31dfFxceyg/IVxceykoPzpbXnt9XXxcXHsoPyFcXHspKD86W157fV0pK1xcfSkrXFx9KStcXH0vLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAnZm9ybWF0LXNwZWMnOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvKDopW146KCl7fV0rKD89XFx9JCkvLFxuICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2NvbnZlcnNpb24tb3B0aW9uJzoge1xuICAgICAgICAgICAgcGF0dGVybjogLyFbc3JhXSg/PVs6fV0kKS8sXG4gICAgICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzdDogbnVsbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3N0cmluZyc6IC9bXFxzXFxTXSsvXG4gICAgfVxuICB9LFxuICAndHJpcGxlLXF1b3RlZC1zdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyg/OltydWJdfGJyfHJiKT8oXCJcIlwifCcnJylbXFxzXFxTXSo/XFwxL2ksXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGFsaWFzOiAnc3RyaW5nJ1xuICB9LFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oPzpbcnViXXxicnxyYik/KFwifCcpKD86XFxcXC58KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS9pLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnZnVuY3Rpb24nOiB7XG4gICAgcGF0dGVybjogLygoPzpefFxccylkZWZbIFxcdF0rKVthLXpBLVpfXVxcdyooPz1cXHMqXFwoKS9nLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgcGF0dGVybjogLyhcXGJjbGFzc1xccyspXFx3Ky9pLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2RlY29yYXRvcic6IHtcbiAgICBwYXR0ZXJuOiAvKF5bXFx0IF0qKUBcXHcrKD86XFwuXFx3KykqL20sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogWydhbm5vdGF0aW9uJywgJ3B1bmN0dWF0aW9uJ10sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncHVuY3R1YXRpb24nOiAvXFwuL1xuICAgIH1cbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86Xyg/PVxccyo6KXxhbmR8YXN8YXNzZXJ0fGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2xhc3N8Y29udGludWV8ZGVmfGRlbHxlbGlmfGVsc2V8ZXhjZXB0fGV4ZWN8ZmluYWxseXxmb3J8ZnJvbXxnbG9iYWx8aWZ8aW1wb3J0fGlufGlzfGxhbWJkYXxtYXRjaHxub25sb2NhbHxub3R8b3J8cGFzc3xwcmludHxyYWlzZXxyZXR1cm58dHJ5fHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcbiAgJ2J1aWx0aW4nOiAvXFxiKD86X19pbXBvcnRfX3xhYnN8YWxsfGFueXxhcHBseXxhc2NpaXxiYXNlc3RyaW5nfGJpbnxib29sfGJ1ZmZlcnxieXRlYXJyYXl8Ynl0ZXN8Y2FsbGFibGV8Y2hyfGNsYXNzbWV0aG9kfGNtcHxjb2VyY2V8Y29tcGlsZXxjb21wbGV4fGRlbGF0dHJ8ZGljdHxkaXJ8ZGl2bW9kfGVudW1lcmF0ZXxldmFsfGV4ZWNmaWxlfGZpbGV8ZmlsdGVyfGZsb2F0fGZvcm1hdHxmcm96ZW5zZXR8Z2V0YXR0cnxnbG9iYWxzfGhhc2F0dHJ8aGFzaHxoZWxwfGhleHxpZHxpbnB1dHxpbnR8aW50ZXJufGlzaW5zdGFuY2V8aXNzdWJjbGFzc3xpdGVyfGxlbnxsaXN0fGxvY2Fsc3xsb25nfG1hcHxtYXh8bWVtb3J5dmlld3xtaW58bmV4dHxvYmplY3R8b2N0fG9wZW58b3JkfHBvd3xwcm9wZXJ0eXxyYW5nZXxyYXdfaW5wdXR8cmVkdWNlfHJlbG9hZHxyZXByfHJldmVyc2VkfHJvdW5kfHNldHxzZXRhdHRyfHNsaWNlfHNvcnRlZHxzdGF0aWNtZXRob2R8c3RyfHN1bXxzdXBlcnx0dXBsZXx0eXBlfHVuaWNocnx1bmljb2RlfHZhcnN8eHJhbmdlfHppcClcXGIvLFxuICAnYm9vbGVhbic6IC9cXGIoPzpGYWxzZXxOb25lfFRydWUpXFxiLyxcbiAgJ251bWJlcic6IC9cXGIwKD86Yig/Ol8/WzAxXSkrfG8oPzpfP1swLTddKSt8eCg/Ol8/W2EtZjAtOV0pKylcXGJ8KD86XFxiXFxkKyg/Ol9cXGQrKSooPzpcXC4oPzpcXGQrKD86X1xcZCspKik/KT98XFxCXFwuXFxkKyg/Ol9cXGQrKSopKD86ZVsrLV0/XFxkKyg/Ol9cXGQrKSopP2o/KD8hXFx3KS9pLFxuICAnb3BlcmF0b3InOiAvWy0rJT1dPT98IT18Oj18XFwqXFwqPz0/fFxcL1xcLz89P3w8Wzw9Pl0/fD5bPT5dP3xbJnxefl0vLFxuICAncHVuY3R1YXRpb24nOiAvW3t9W1xcXTsoKSwuOl0vXG59O1xucHJpc20ubGFuZ3VhZ2VzLnB5dGhvblsnc3RyaW5nLWludGVycG9sYXRpb24nXS5pbnNpZGVbJ2ludGVycG9sYXRpb24nXS5pbnNpZGUucmVzdCA9IHByaXNtLmxhbmd1YWdlcy5weXRob247XG5wcmlzbS5sYW5ndWFnZXMucHkgPSBwcmlzbS5sYW5ndWFnZXMucHl0aG9uO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tcmVhc29uXCIgKi9cblxucHJpc20ubGFuZ3VhZ2VzLnJlYXNvbiA9IHByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC9cIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXFxcXFxcclxcblwiXSkqXCIvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAvLyAnY2xhc3MtbmFtZScgbXVzdCBiZSBtYXRjaGVkICphZnRlciogJ2NvbnN0cnVjdG9yJyBkZWZpbmVkIGJlbG93XG4gICdjbGFzcy1uYW1lJzogL1xcYltBLVpdXFx3Ki8sXG4gICdrZXl3b3JkJzogL1xcYig/OmFuZHxhc3xhc3NlcnR8YmVnaW58Y2xhc3N8Y29uc3RyYWludHxkb3xkb25lfGRvd250b3xlbHNlfGVuZHxleGNlcHRpb258ZXh0ZXJuYWx8Zm9yfGZ1bnxmdW5jdGlvbnxmdW5jdG9yfGlmfGlufGluY2x1ZGV8aW5oZXJpdHxpbml0aWFsaXplcnxsYXp5fGxldHxtZXRob2R8bW9kdWxlfG11dGFibGV8bmV3fG5vbnJlY3xvYmplY3R8b2Z8b3Blbnxvcnxwcml2YXRlfHJlY3xzaWd8c3RydWN0fHN3aXRjaHx0aGVufHRvfHRyeXx0eXBlfHZhbHx2aXJ0dWFsfHdoZW58d2hpbGV8d2l0aClcXGIvLFxuICAnb3BlcmF0b3InOiAvXFwuezN9fDpbOj1dfFxcfD58LT58PSg/Oj09P3w+KT98PD0/fD49P3xbfF4/JyMhfmBdfFsrXFwtKlxcL11cXC4/fFxcYig/OmFzcnxsYW5kfGxvcnxsc2x8bHNyfGx4b3J8bW9kKVxcYi9cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgncmVhc29uJywgJ2NsYXNzLW5hbWUnLCB7XG4gICdjaGFyJzoge1xuICAgIHBhdHRlcm46IC8nKD86XFxcXHhbXFxkYS1mXXsyfXxcXFxcb1swLTNdWzAtN11bMC03XXxcXFxcXFxkezN9fFxcXFwufFteJ1xcXFxcXHJcXG5dKScvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAvLyBOZWdhdGl2ZSBsb29rLWFoZWFkIHByZXZlbnRzIGZyb20gbWF0Y2hpbmcgdGhpbmdzIGxpa2UgU3RyaW5nLmNhcGl0YWxpemVcbiAgJ2NvbnN0cnVjdG9yJzogL1xcYltBLVpdXFx3KlxcYig/IVxccypcXC4pLyxcbiAgJ2xhYmVsJzoge1xuICAgIHBhdHRlcm46IC9cXGJbYS16XVxcdyooPz06OikvLFxuICAgIGFsaWFzOiAnc3ltYm9sJ1xuICB9XG59KTsgLy8gV2UgY2FuJ3QgbWF0Y2ggZnVuY3Rpb25zIHByb3BlcnR5LCBzbyBsZXQncyBub3QgZXZlbiB0cnkuXG5cbmRlbGV0ZSBwcmlzbS5sYW5ndWFnZXMucmVhc29uLmZ1bmN0aW9uO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tc2Fzc1wiICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLnNhc3MgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gICAgLy8gU2FzcyBjb21tZW50cyBkb24ndCBuZWVkIHRvIGJlIGNsb3NlZCwgb25seSBpbmRlbnRlZFxuICAgICdjb21tZW50Jzoge1xuICAgICAgcGF0dGVybjogL14oWyBcXHRdKilcXC9bXFwvKl0uKig/Oig/Olxccj9cXG58XFxyKVxcMVsgXFx0XS4rKSovbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzYXNzJywgJ2F0cnVsZScsIHtcbiAgICAvLyBXZSB3YW50IHRvIGNvbnN1bWUgdGhlIHdob2xlIGxpbmVcbiAgICAnYXRydWxlLWxpbmUnOiB7XG4gICAgICAvLyBJbmNsdWRlcyBzdXBwb3J0IGZvciA9IGFuZCArIHNob3J0Y3V0c1xuICAgICAgcGF0dGVybjogL14oPzpbIFxcdF0qKVtAKz1dLisvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnYXRydWxlJzogLyg/OkBbXFx3LV0rfFsrPV0pL1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMuc2Fzcy5hdHJ1bGU7XG4gIHZhciB2YXJpYWJsZSA9IC9cXCRbLVxcd10rfCNcXHtcXCRbLVxcd10rXFx9LztcbiAgdmFyIG9wZXJhdG9yID0gWy9bKypcXC8lXXxbPSFdPXw8PT98Pj0/fFxcYig/OmFuZHxub3R8b3IpXFxiLywge1xuICAgIHBhdHRlcm46IC8oXFxzKS0oPz1cXHMpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzYXNzJywgJ3Byb3BlcnR5Jywge1xuICAgIC8vIFdlIHdhbnQgdG8gY29uc3VtZSB0aGUgd2hvbGUgbGluZVxuICAgICd2YXJpYWJsZS1saW5lJzoge1xuICAgICAgcGF0dGVybjogL15bIFxcdF0qXFwkLisvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvOi8sXG4gICAgICAgICd2YXJpYWJsZSc6IHZhcmlhYmxlLFxuICAgICAgICAnb3BlcmF0b3InOiBvcGVyYXRvclxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gV2Ugd2FudCB0byBjb25zdW1lIHRoZSB3aG9sZSBsaW5lXG4gICAgJ3Byb3BlcnR5LWxpbmUnOiB7XG4gICAgICBwYXR0ZXJuOiAvXlsgXFx0XSooPzpbXjpcXHNdKyAqOi4qfDpbXjpcXHNdLiopL20sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3Byb3BlcnR5JzogWy9bXjpcXHNdKyg/PVxccyo6KS8sIHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKDopW146XFxzXSsvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfV0sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC86LyxcbiAgICAgICAgJ3ZhcmlhYmxlJzogdmFyaWFibGUsXG4gICAgICAgICdvcGVyYXRvcic6IG9wZXJhdG9yLFxuICAgICAgICAnaW1wb3J0YW50JzogUHJpc20ubGFuZ3VhZ2VzLnNhc3MuaW1wb3J0YW50XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5zYXNzLnByb3BlcnR5O1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnNhc3MuaW1wb3J0YW50OyAvLyBOb3cgdGhhdCB3aG9sZSBsaW5lcyBmb3Igb3RoZXIgcGF0dGVybnMgYXJlIGNvbnN1bWVkLFxuICAvLyB3aGF0J3MgbGVmdCBzaG91bGQgYmUgc2VsZWN0b3JzXG5cbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2FzcycsICdwdW5jdHVhdGlvbicsIHtcbiAgICAnc2VsZWN0b3InOiB7XG4gICAgICBwYXR0ZXJuOiAvXihbIFxcdF0qKVxcUyg/OixbXixcXHJcXG5dK3xbXixcXHJcXG5dKikoPzosW14sXFxyXFxuXSspKig/OiwoPzpcXHI/XFxufFxccilcXDFbIFxcdF0rXFxTKD86LFteLFxcclxcbl0rfFteLFxcclxcbl0qKSg/OixbXixcXHJcXG5dKykqKSovbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XG4gIH0pO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tc2Nzc1wiICovXG5cblxucHJpc20ubGFuZ3VhZ2VzLnNjc3MgPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSg/OlxcL1xcKltcXHNcXFNdKj9cXCpcXC98XFwvXFwvLiopLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdhdHJ1bGUnOiB7XG4gICAgcGF0dGVybjogL0BbXFx3LV0oPzpcXChbXigpXStcXCl8W14oKVxcc118XFxzKyg/IVxccykpKj8oPz1cXHMrW3s7XSkvLFxuICAgIGluc2lkZToge1xuICAgICAgJ3J1bGUnOiAvQFtcXHctXSsvIC8vIFNlZSByZXN0IGJlbG93XG5cbiAgICB9XG4gIH0sXG4gIC8vIHVybCwgY29tcGFzc2lmaWVkXG4gICd1cmwnOiAvKD86Wy1hLXpdKy0pP3VybCg/PVxcKCkvaSxcbiAgLy8gQ1NTIHNlbGVjdG9yIHJlZ2V4IGlzIG5vdCBhcHByb3ByaWF0ZSBmb3IgU2Fzc1xuICAvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbG90IG1vcmUgdGhpbmdzICh2YXIsIEAgZGlyZWN0aXZlLCBuZXN0aW5nLi4pXG4gIC8vIGEgc2VsZWN0b3IgbXVzdCBzdGFydCBhdCB0aGUgZW5kIG9mIGEgcHJvcGVydHkgb3IgYWZ0ZXIgYSBicmFjZSAoZW5kIG9mIG90aGVyIHJ1bGVzIG9yIG5lc3RpbmcpXG4gIC8vIGl0IGNhbiBjb250YWluIHNvbWUgY2hhcmFjdGVycyB0aGF0IGFyZW4ndCB1c2VkIGZvciBkZWZpbmluZyBydWxlcyBvciBlbmQgb2Ygc2VsZWN0b3IsICYgKHBhcmVudCBzZWxlY3RvciksIG9yIGludGVycG9sYXRlZCB2YXJpYWJsZVxuICAvLyB0aGUgZW5kIG9mIGEgc2VsZWN0b3IgaXMgZm91bmQgd2hlbiB0aGVyZSBpcyBubyBydWxlcyBpbiBpdCAoIHt9IG9yIHtcXHN9KSBvciBpZiB0aGVyZSBpcyBhIHByb3BlcnR5IChiZWNhdXNlIGFuIGludGVycG9sYXRlZCB2YXJcbiAgLy8gY2FuIFwicGFzc1wiIGFzIGEgc2VsZWN0b3ItIGUuZzogcHJvcGVyI3skZXJ0eX0pXG4gIC8vIHRoaXMgb25lIHdhcyBoYXJkIHRvIGRvLCBzbyBwbGVhc2UgYmUgY2FyZWZ1bCBpZiB5b3UgZWRpdCB0aGlzIG9uZSA6KVxuICAnc2VsZWN0b3InOiB7XG4gICAgLy8gSW5pdGlhbCBsb29rLWFoZWFkIGlzIHVzZWQgdG8gcHJldmVudCBtYXRjaGluZyBvZiBibGFuayBzZWxlY3RvcnNcbiAgICBwYXR0ZXJuOiAvKD89XFxTKVteQDt7fSgpXT8oPzpbXkA7e30oKVxcc118XFxzKyg/IVxccyl8I1xce1xcJFstXFx3XStcXH0pKyg/PVxccypcXHsoPzpcXH18XFxzfFtefV1bXjp7fV0qWzp7XVtefV0pKS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncGFyZW50Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvJi8sXG4gICAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgICAgfSxcbiAgICAgICdwbGFjZWhvbGRlcic6IC8lWy1cXHddKy8sXG4gICAgICAndmFyaWFibGUnOiAvXFwkWy1cXHddK3wjXFx7XFwkWy1cXHddK1xcfS9cbiAgICB9XG4gIH0sXG4gICdwcm9wZXJ0eSc6IHtcbiAgICBwYXR0ZXJuOiAvKD86Wy1cXHddfFxcJFstXFx3XXwjXFx7XFwkWy1cXHddK1xcfSkrKD89XFxzKjopLyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICd2YXJpYWJsZSc6IC9cXCRbLVxcd10rfCNcXHtcXCRbLVxcd10rXFx9L1xuICAgIH1cbiAgfVxufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzY3NzJywgJ2F0cnVsZScsIHtcbiAgJ2tleXdvcmQnOiBbL0AoPzpjb250ZW50fGRlYnVnfGVhY2h8ZWxzZSg/OiBpZik/fGV4dGVuZHxmb3J8Zm9yd2FyZHxmdW5jdGlvbnxpZnxpbXBvcnR8aW5jbHVkZXxtaXhpbnxyZXR1cm58dXNlfHdhcm58d2hpbGUpXFxiL2ksIHtcbiAgICBwYXR0ZXJuOiAvKCApKD86ZnJvbXx0aHJvdWdoKSg/PSApLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dXG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3Njc3MnLCAnaW1wb3J0YW50Jywge1xuICAvLyB2YXIgYW5kIGludGVycG9sYXRlZCB2YXJzXG4gICd2YXJpYWJsZSc6IC9cXCRbLVxcd10rfCNcXHtcXCRbLVxcd10rXFx9L1xufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzY3NzJywgJ2Z1bmN0aW9uJywge1xuICAnbW9kdWxlLW1vZGlmaWVyJzoge1xuICAgIHBhdHRlcm46IC9cXGIoPzphc3xoaWRlfHNob3d8d2l0aClcXGIvaSxcbiAgICBhbGlhczogJ2tleXdvcmQnXG4gIH0sXG4gICdwbGFjZWhvbGRlcic6IHtcbiAgICBwYXR0ZXJuOiAvJVstXFx3XSsvLFxuICAgIGFsaWFzOiAnc2VsZWN0b3InXG4gIH0sXG4gICdzdGF0ZW1lbnQnOiB7XG4gICAgcGF0dGVybjogL1xcQiEoPzpkZWZhdWx0fG9wdGlvbmFsKVxcYi9pLFxuICAgIGFsaWFzOiAna2V5d29yZCdcbiAgfSxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAnbnVsbCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxibnVsbFxcYi8sXG4gICAgYWxpYXM6ICdrZXl3b3JkJ1xuICB9LFxuICAnb3BlcmF0b3InOiB7XG4gICAgcGF0dGVybjogLyhcXHMpKD86Wy0rKlxcLyVdfFs9IV09fDw9P3w+PT98YW5kfG5vdHxvcikoPz1cXHMpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLnNjc3NbJ2F0cnVsZSddLmluc2lkZS5yZXN0ID0gcHJpc20ubGFuZ3VhZ2VzLnNjc3M7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1zdHlsdXNcIiAqL1xuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciB1bml0ID0ge1xuICAgIHBhdHRlcm46IC8oXFxiXFxkKykoPzolfFthLXpdKykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfTsgLy8gMTIzIC0xMjMgLjEyMyAtLjEyMyAxMi4zIC0xMi4zXG5cbiAgdmFyIG51bWJlciA9IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXHcuLV0pLT8oPzpcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH07XG4gIHZhciBpbnNpZGUgPSB7XG4gICAgJ2NvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSkoPzpcXC9cXCpbXFxzXFxTXSo/XFwqXFwvfFxcL1xcLy4qKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAndXJsJzoge1xuICAgICAgcGF0dGVybjogL1xcYnVybFxcKChbXCInXT8pLio/XFwxXFwpL2ksXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdzdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFwifCcpKD86KD8hXFwxKVteXFxcXFxcclxcbl18XFxcXCg/OlxcclxcbnxbXFxzXFxTXSkpKlxcMS8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdpbnRlcnBvbGF0aW9uJzogbnVsbCxcbiAgICAvLyBTZWUgYmVsb3dcbiAgICAnZnVuYyc6IG51bGwsXG4gICAgLy8gU2VlIGJlbG93XG4gICAgJ2ltcG9ydGFudCc6IC9cXEIhKD86aW1wb3J0YW50fG9wdGlvbmFsKVxcYi9pLFxuICAgICdrZXl3b3JkJzoge1xuICAgICAgcGF0dGVybjogLyhefFxccyspKD86KD86ZWxzZXxmb3J8aWZ8cmV0dXJufHVubGVzcykoPz1cXHN8JCl8QFtcXHctXSspLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdoZXhjb2RlJzogLyNbXFxkYS1mXXszLDZ9L2ksXG4gICAgJ2NvbG9yJzogWy9cXGIoPzpBbGljZUJsdWV8QW50aXF1ZVdoaXRlfEFxdWF8QXF1YW1hcmluZXxBenVyZXxCZWlnZXxCaXNxdWV8QmxhY2t8QmxhbmNoZWRBbG1vbmR8Qmx1ZXxCbHVlVmlvbGV0fEJyb3dufEJ1cmx5V29vZHxDYWRldEJsdWV8Q2hhcnRyZXVzZXxDaG9jb2xhdGV8Q29yYWx8Q29ybmZsb3dlckJsdWV8Q29ybnNpbGt8Q3JpbXNvbnxDeWFufERhcmtCbHVlfERhcmtDeWFufERhcmtHb2xkZW5Sb2R8RGFya0dyW2FlXXl8RGFya0dyZWVufERhcmtLaGFraXxEYXJrTWFnZW50YXxEYXJrT2xpdmVHcmVlbnxEYXJrT3JhbmdlfERhcmtPcmNoaWR8RGFya1JlZHxEYXJrU2FsbW9ufERhcmtTZWFHcmVlbnxEYXJrU2xhdGVCbHVlfERhcmtTbGF0ZUdyW2FlXXl8RGFya1R1cnF1b2lzZXxEYXJrVmlvbGV0fERlZXBQaW5rfERlZXBTa3lCbHVlfERpbUdyW2FlXXl8RG9kZ2VyQmx1ZXxGaXJlQnJpY2t8RmxvcmFsV2hpdGV8Rm9yZXN0R3JlZW58RnVjaHNpYXxHYWluc2Jvcm98R2hvc3RXaGl0ZXxHb2xkfEdvbGRlblJvZHxHclthZV15fEdyZWVufEdyZWVuWWVsbG93fEhvbmV5RGV3fEhvdFBpbmt8SW5kaWFuUmVkfEluZGlnb3xJdm9yeXxLaGFraXxMYXZlbmRlcnxMYXZlbmRlckJsdXNofExhd25HcmVlbnxMZW1vbkNoaWZmb258TGlnaHRCbHVlfExpZ2h0Q29yYWx8TGlnaHRDeWFufExpZ2h0R29sZGVuUm9kWWVsbG93fExpZ2h0R3JbYWVdeXxMaWdodEdyZWVufExpZ2h0UGlua3xMaWdodFNhbG1vbnxMaWdodFNlYUdyZWVufExpZ2h0U2t5Qmx1ZXxMaWdodFNsYXRlR3JbYWVdeXxMaWdodFN0ZWVsQmx1ZXxMaWdodFllbGxvd3xMaW1lfExpbWVHcmVlbnxMaW5lbnxNYWdlbnRhfE1hcm9vbnxNZWRpdW1BcXVhTWFyaW5lfE1lZGl1bUJsdWV8TWVkaXVtT3JjaGlkfE1lZGl1bVB1cnBsZXxNZWRpdW1TZWFHcmVlbnxNZWRpdW1TbGF0ZUJsdWV8TWVkaXVtU3ByaW5nR3JlZW58TWVkaXVtVHVycXVvaXNlfE1lZGl1bVZpb2xldFJlZHxNaWRuaWdodEJsdWV8TWludENyZWFtfE1pc3R5Um9zZXxNb2NjYXNpbnxOYXZham9XaGl0ZXxOYXZ5fE9sZExhY2V8T2xpdmV8T2xpdmVEcmFifE9yYW5nZXxPcmFuZ2VSZWR8T3JjaGlkfFBhbGVHb2xkZW5Sb2R8UGFsZUdyZWVufFBhbGVUdXJxdW9pc2V8UGFsZVZpb2xldFJlZHxQYXBheWFXaGlwfFBlYWNoUHVmZnxQZXJ1fFBpbmt8UGx1bXxQb3dkZXJCbHVlfFB1cnBsZXxSZWR8Um9zeUJyb3dufFJveWFsQmx1ZXxTYWRkbGVCcm93bnxTYWxtb258U2FuZHlCcm93bnxTZWFHcmVlbnxTZWFTaGVsbHxTaWVubmF8U2lsdmVyfFNreUJsdWV8U2xhdGVCbHVlfFNsYXRlR3JbYWVdeXxTbm93fFNwcmluZ0dyZWVufFN0ZWVsQmx1ZXxUYW58VGVhbHxUaGlzdGxlfFRvbWF0b3xUcmFuc3BhcmVudHxUdXJxdW9pc2V8VmlvbGV0fFdoZWF0fFdoaXRlfFdoaXRlU21va2V8WWVsbG93fFllbGxvd0dyZWVuKVxcYi9pLCB7XG4gICAgICBwYXR0ZXJuOiAvXFxiKD86aHNsfHJnYilcXChcXHMqXFxkezEsM31cXHMqLFxccypcXGR7MSwzfSU/XFxzKixcXHMqXFxkezEsM30lP1xccypcXClcXEJ8XFxiKD86aHNsfHJnYilhXFwoXFxzKlxcZHsxLDN9XFxzKixcXHMqXFxkezEsM30lP1xccyosXFxzKlxcZHsxLDN9JT9cXHMqLFxccyooPzowfDA/XFwuXFxkK3wxKVxccypcXClcXEIvaSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndW5pdCc6IHVuaXQsXG4gICAgICAgICdudW1iZXInOiBudW1iZXIsXG4gICAgICAgICdmdW5jdGlvbic6IC9bXFx3LV0rKD89XFwoKS8sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9bKCksXS9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAnZW50aXR5JzogL1xcXFxbXFxkYS1mXXsxLDh9L2ksXG4gICAgJ3VuaXQnOiB1bml0LFxuICAgICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgICAnb3BlcmF0b3InOiBbLy8gV2Ugd2FudCBub24td29yZCBjaGFycyBhcm91bmQgXCItXCIgYmVjYXVzZSBpdCBpc1xuICAgIC8vIGFjY2VwdGVkIGluIHByb3BlcnR5IG5hbWVzLlxuICAgIC9+fFsrIVxcLyU8Pj89XT0/fFstOl09fFxcKlsqPV0/fFxcLnsyLDN9fCYmfFxcfFxcfHxcXEItXFxCfFxcYig/OmFuZHxpbnxpcyg/OiBhfCBkZWZpbmVkfCBub3R8bnQpP3xub3R8b3IpXFxiL10sXG4gICAgJ251bWJlcic6IG51bWJlcixcbiAgICAncHVuY3R1YXRpb24nOiAvW3t9KClcXFtcXF07OixdL1xuICB9O1xuICBpbnNpZGVbJ2ludGVycG9sYXRpb24nXSA9IHtcbiAgICBwYXR0ZXJuOiAvXFx7W15cXHJcXG59Ol0rXFx9LyxcbiAgICBhbGlhczogJ3ZhcmlhYmxlJyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICAgIHBhdHRlcm46IC9eXFx7fFxcfSQvLFxuICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgfSxcbiAgICAgIHJlc3Q6IGluc2lkZVxuICAgIH1cbiAgfTtcbiAgaW5zaWRlWydmdW5jJ10gPSB7XG4gICAgcGF0dGVybjogL1tcXHctXStcXChbXildKlxcKS4qLyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdmdW5jdGlvbic6IC9eW14oXSsvLFxuICAgICAgcmVzdDogaW5zaWRlXG4gICAgfVxuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMuc3R5bHVzID0ge1xuICAgICdhdHJ1bGUtZGVjbGFyYXRpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF5bIFxcdF0qKUAuKy9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnYXRydWxlJzogL15AW1xcdy1dKy8sXG4gICAgICAgIHJlc3Q6IGluc2lkZVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3ZhcmlhYmxlLWRlY2xhcmF0aW9uJzoge1xuICAgICAgcGF0dGVybjogLyheWyBcXHRdKilbXFx3JC1dK1xccyouPz1bIFxcdF0qKD86XFx7W157fV0qXFx9fFxcUy4qfCQpL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICd2YXJpYWJsZSc6IC9eXFxTKy8sXG4gICAgICAgIHJlc3Q6IGluc2lkZVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3N0YXRlbWVudCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXlsgXFx0XSopKD86ZWxzZXxmb3J8aWZ8cmV0dXJufHVubGVzcylbIFxcdF0uKy9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAna2V5d29yZCc6IC9eXFxTKy8sXG4gICAgICAgIHJlc3Q6IGluc2lkZVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQSBwcm9wZXJ0eS92YWx1ZSBwYWlyIGNhbm5vdCBlbmQgd2l0aCBhIGNvbW1hIG9yIGEgYnJhY2VcbiAgICAvLyBJdCBjYW5ub3QgaGF2ZSBpbmRlbnRlZCBjb250ZW50IHVubGVzcyBpdCBlbmRlZCB3aXRoIGEgc2VtaWNvbG9uXG4gICAgJ3Byb3BlcnR5LWRlY2xhcmF0aW9uJzoge1xuICAgICAgcGF0dGVybjogLygoPzpefFxceykoWyBcXHRdKikpKD86W1xcdy1dfFxce1tefVxcclxcbl0rXFx9KSsoPzpcXHMqOlxccyp8WyBcXHRdKykoPyFcXHMpW157XFxyXFxuXSooPzo7fFtee1xcclxcbixdJCg/ISg/Olxccj9cXG58XFxyKSg/Olxce3xcXDJbIFxcdF0pKSkvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3Byb3BlcnR5Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eW15cXHM6XSsvLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ2ludGVycG9sYXRpb24nOiBpbnNpZGUuaW50ZXJwb2xhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzdDogaW5zaWRlXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBIHNlbGVjdG9yIGNhbiBjb250YWluIHBhcmVudGhlc2VzIG9ubHkgYXMgcGFydCBvZiBhIHBzZXVkby1lbGVtZW50XG4gICAgLy8gSXQgY2FuIHNwYW4gbXVsdGlwbGUgbGluZXMuXG4gICAgLy8gSXQgbXVzdCBlbmQgd2l0aCBhIGNvbW1hIG9yIGFuIGFjY29sYWRlIG9yIGhhdmUgaW5kZW50ZWQgY29udGVudC5cbiAgICAnc2VsZWN0b3InOiB7XG4gICAgICBwYXR0ZXJuOiAvKF5bIFxcdF0qKSg/Oig/PVxcUykoPzpbXnt9XFxyXFxuOigpXXw6Oj9bXFx3LV0rKD86XFwoW14pXFxyXFxuXSpcXCl8KD8hW1xcdy1dKSl8XFx7W159XFxyXFxuXStcXH0pKykoPzooPzpcXHI/XFxufFxccikoPzpcXDEoPzooPz1cXFMpKD86W157fVxcclxcbjooKV18Ojo/W1xcdy1dKyg/OlxcKFteKVxcclxcbl0qXFwpfCg/IVtcXHctXSkpfFxce1tefVxcclxcbl0rXFx9KSspKSkqKD86LCR8XFx7fCg/PSg/Olxccj9cXG58XFxyKSg/Olxce3xcXDFbIFxcdF0pKSkvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2ludGVycG9sYXRpb24nOiBpbnNpZGUuaW50ZXJwb2xhdGlvbixcbiAgICAgICAgJ2NvbW1lbnQnOiBpbnNpZGUuY29tbWVudCxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1t7fSxdL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2Z1bmMnOiBpbnNpZGUuZnVuYyxcbiAgICAnc3RyaW5nJzogaW5zaWRlLnN0cmluZyxcbiAgICAnY29tbWVudCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSg/OlxcL1xcKltcXHNcXFNdKj9cXCpcXC98XFwvXFwvLiopLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdpbnRlcnBvbGF0aW9uJzogaW5zaWRlLmludGVycG9sYXRpb24sXG4gICAgJ3B1bmN0dWF0aW9uJzogL1t7fSgpXFxbXFxdOzouXS9cbiAgfTtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXRzeFwiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgdHlwZXNjcmlwdCA9IFByaXNtLnV0aWwuY2xvbmUoUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQpO1xuICBQcmlzbS5sYW5ndWFnZXMudHN4ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnanN4JywgdHlwZXNjcmlwdCk7IC8vIGRvZXNuJ3Qgd29yayB3aXRoIFRTIGJlY2F1c2UgVFMgaXMgdG9vIGNvbXBsZXhcblxuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnRzeFsncGFyYW1ldGVyJ107XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMudHN4WydsaXRlcmFsLXByb3BlcnR5J107IC8vIFRoaXMgd2lsbCBwcmV2ZW50IGNvbGxpc2lvbnMgYmV0d2VlbiBUU1ggdGFncyBhbmQgVFMgZ2VuZXJpYyB0eXBlcy5cbiAgLy8gSWRlYSBieSBodHRwczovL2dpdGh1Yi5jb20va2FybGhvcmt5XG4gIC8vIERpc2N1c3Npb246IGh0dHBzOi8vZ2l0aHViLmNvbS9QcmlzbUpTL3ByaXNtL2lzc3Vlcy8yNTk0I2lzc3VlY29tbWVudC03MTA2NjY5MjhcblxuICB2YXIgdGFnID0gUHJpc20ubGFuZ3VhZ2VzLnRzeC50YWc7XG4gIHRhZy5wYXR0ZXJuID0gUmVnRXhwKC8oXnxbXlxcdyRdfCg/PTxcXC8pKS8uc291cmNlICsgJyg/OicgKyB0YWcucGF0dGVybi5zb3VyY2UgKyAnKScsIHRhZy5wYXR0ZXJuLmZsYWdzKTtcbiAgdGFnLmxvb2tiZWhpbmQgPSB0cnVlO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20td2FzbVwiICovXG5cblxucHJpc20ubGFuZ3VhZ2VzLndhc20gPSB7XG4gICdjb21tZW50JzogWy9cXCg7W1xcc1xcU10qPztcXCkvLCB7XG4gICAgcGF0dGVybjogLzs7LiovLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcW1xcc1xcU118W15cIlxcXFxdKSpcIi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdrZXl3b3JkJzogW3tcbiAgICBwYXR0ZXJuOiAvXFxiKD86YWxpZ258b2Zmc2V0KT0vLFxuICAgIGluc2lkZToge1xuICAgICAgJ29wZXJhdG9yJzogLz0vXG4gICAgfVxuICB9LCB7XG4gICAgcGF0dGVybjogL1xcYig/Oig/OmYzMnxmNjR8aTMyfGk2NCkoPzpcXC4oPzphYnN8YWRkfGFuZHxjZWlsfGNsenxjb25zdHxjb252ZXJ0X1tzdV1cXC9pKD86MzJ8NjQpfGNvcHlzaWdufGN0enxkZW1vdGVcXC9mNjR8ZGl2KD86X1tzdV0pP3xlcXo/fGV4dGVuZF9bc3VdXFwvaTMyfGZsb29yfGdlKD86X1tzdV0pP3xndCg/Ol9bc3VdKT98bGUoPzpfW3N1XSk/fGxvYWQoPzooPzo4fDE2fDMyKV9bc3VdKT98bHQoPzpfW3N1XSk/fG1heHxtaW58bXVsfG5lZz98bmVhcmVzdHxvcnxwb3BjbnR8cHJvbW90ZVxcL2YzMnxyZWludGVycHJldFxcL1tmaV0oPzozMnw2NCl8cmVtX1tzdV18cm90W2xyXXxzaGx8c2hyX1tzdV18c3FydHxzdG9yZSg/Ojh8MTZ8MzIpP3xzdWJ8dHJ1bmMoPzpfW3N1XVxcL2YoPzozMnw2NCkpP3x3cmFwXFwvaTY0fHhvcikpP3xtZW1vcnlcXC4oPzpncm93fHNpemUpKVxcYi8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncHVuY3R1YXRpb24nOiAvXFwuL1xuICAgIH1cbiAgfSwgL1xcYig/OmFueWZ1bmN8YmxvY2t8YnIoPzpfaWZ8X3RhYmxlKT98Y2FsbCg/Ol9pbmRpcmVjdCk/fGRhdGF8ZHJvcHxlbGVtfGVsc2V8ZW5kfGV4cG9ydHxmdW5jfGdldF8oPzpnbG9iYWx8bG9jYWwpfGdsb2JhbHxpZnxpbXBvcnR8bG9jYWx8bG9vcHxtZW1vcnl8bW9kdWxlfG11dHxub3B8b2Zmc2V0fHBhcmFtfHJlc3VsdHxyZXR1cm58c2VsZWN0fHNldF8oPzpnbG9iYWx8bG9jYWwpfHN0YXJ0fHRhYmxlfHRlZV9sb2NhbHx0aGVufHR5cGV8dW5yZWFjaGFibGUpXFxiL10sXG4gICd2YXJpYWJsZSc6IC9cXCRbXFx3ISMkJSYnKitcXC0uLzo8PT4/QFxcXFxeYHx+XSsvLFxuICAnbnVtYmVyJzogL1srLV0/XFxiKD86XFxkKD86Xz9cXGQpKig/OlxcLlxcZCg/Ol8/XFxkKSopPyg/OltlRV1bKy1dP1xcZCg/Ol8/XFxkKSopP3wweFtcXGRhLWZBLUZdKD86Xz9bXFxkYS1mQS1GXSkqKD86XFwuW1xcZGEtZkEtRl0oPzpfP1tcXGRhLWZBLURdKSopPyg/OltwUF1bKy1dP1xcZCg/Ol8/XFxkKSopPylcXGJ8XFxiaW5mXFxifFxcYm5hbig/OjoweFtcXGRhLWZBLUZdKD86Xz9bXFxkYS1mQS1EXSkqKT9cXGIvLFxuICAncHVuY3R1YXRpb24nOiAvWygpXS9cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByaXNtO1xuIl0sIm5hbWVzIjpbIlByaXNtIiwibGFuZyIsInVuaXF1ZUlkIiwicGxhaW5UZXh0R3JhbW1hciIsIl8iLCJ1dGlsIiwiZW5jb2RlIiwidG9rZW5zIiwiVG9rZW4iLCJ0eXBlIiwiY29udGVudCIsImFsaWFzIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwicmVwbGFjZSIsIm8iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsIm9iaklkIiwib2JqIiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImNsb25lIiwiZGVlcENsb25lIiwidmlzaXRlZCIsImlkIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJmb3JFYWNoIiwidiIsImkiLCJnZXRMYW5ndWFnZSIsImVsZW1lbnQiLCJtIiwiZXhlYyIsImNsYXNzTmFtZSIsInRvTG93ZXJDYXNlIiwicGFyZW50RWxlbWVudCIsInNldExhbmd1YWdlIiwibGFuZ3VhZ2UiLCJSZWdFeHAiLCJjbGFzc0xpc3QiLCJhZGQiLCJpc0FjdGl2ZSIsImRlZmF1bHRBY3RpdmF0aW9uIiwibm8iLCJjb250YWlucyIsImxhbmd1YWdlcyIsInBsYWluIiwicGxhaW50ZXh0IiwidGV4dCIsInR4dCIsImV4dGVuZCIsInJlZGVmIiwiaW5zZXJ0QmVmb3JlIiwiaW5zaWRlIiwiYmVmb3JlIiwiaW5zZXJ0Iiwicm9vdCIsImdyYW1tYXIiLCJyZXQiLCJ0b2tlbiIsIm5ld1Rva2VuIiwib2xkIiwiREZTIiwiY2FsbGJhY2siLCJwcm9wZXJ0eSIsInByb3BlcnR5VHlwZSIsInBsdWdpbnMiLCJoaWdobGlnaHQiLCJlbnYiLCJjb2RlIiwiaG9va3MiLCJydW4iLCJ0b2tlbml6ZSIsInN0cmluZ2lmeSIsInJlc3QiLCJ0b2tlbkxpc3QiLCJMaW5rZWRMaXN0IiwiYWRkQWZ0ZXIiLCJoZWFkIiwibWF0Y2hHcmFtbWFyIiwidG9BcnJheSIsImFsbCIsIm5hbWUiLCJwdXNoIiwiY2FsbGJhY2tzIiwibGVuZ3RoIiwibWF0Y2hlZFN0ciIsInMiLCJlIiwidGFnIiwiY2xhc3NlcyIsImF0dHJpYnV0ZXMiLCJhbGlhc2VzIiwiYXBwbHkiLCJqb2luIiwibWF0Y2hQYXR0ZXJuIiwicGF0dGVybiIsInBvcyIsImxvb2tiZWhpbmQiLCJsYXN0SW5kZXgiLCJtYXRjaCIsImxvb2tiZWhpbmRMZW5ndGgiLCJpbmRleCIsInN0YXJ0Tm9kZSIsInN0YXJ0UG9zIiwicmVtYXRjaCIsInBhdHRlcm5zIiwiaiIsImNhdXNlIiwicGF0dGVybk9iaiIsImdyZWVkeSIsImdsb2JhbCIsImZsYWdzIiwic291cmNlIiwiY3VycmVudE5vZGUiLCJuZXh0IiwidGFpbCIsInJlYWNoIiwic3RyIiwicmVtb3ZlQ291bnQiLCJmcm9tIiwidG8iLCJwIiwiayIsIm1hdGNoU3RyIiwiYWZ0ZXIiLCJyZW1vdmVGcm9tIiwicHJldiIsInJlbW92ZVJhbmdlIiwid3JhcHBlZCIsIm5lc3RlZFJlbWF0Y2giLCJsaXN0Iiwibm9kZSIsIm5ld05vZGUiLCJjb3VudCIsImFycmF5IiwicHJpc20iLCJkZWZhdWx0IiwibWFya3VwIiwiYWRkSW5saW5lZCIsInRhZ05hbWUiLCJpbmNsdWRlZENkYXRhSW5zaWRlIiwiZGVmIiwiYXR0ck5hbWUiLCJodG1sIiwibWF0aG1sIiwic3ZnIiwieG1sIiwic3NtbCIsImF0b20iLCJyc3MiLCJlbnZWYXJzIiwiY29tbWFuZEFmdGVySGVyZWRvYyIsImluc2lkZVN0cmluZyIsImJhc2giLCJlbnRpdHkiLCJ2YXJpYWJsZSIsInRvQmVDb3BpZWQiLCJzaGVsbCIsImNsaWtlIiwiYyIsImtleXdvcmQiLCJtb2ROYW1lIiwiY3BwIiwic3RyaW5nIiwiY3NzIiwiYWRkQXR0cmlidXRlIiwic2VsZWN0b3JJbnNpZGUiLCJzZWxlY3RvciIsInVuaXQiLCJudW1iZXIiLCJqYXZhc2NyaXB0IiwicmVnZXgiLCJqcyIsImNvbW1lbnQiLCJpbnRlcnBvbGF0aW9uIiwiY29mZmVlc2NyaXB0IiwiY29mZmVlIiwiYW5jaG9yT3JBbGlhcyIsInByb3BlcnRpZXMiLCJwbGFpbktleSIsImNyZWF0ZVZhbHVlUGF0dGVybiIsInlhbWwiLCJ5bWwiLCJpbm5lciIsImNyZWF0ZUlubGluZSIsInRhYmxlQ2VsbCIsInRhYmxlUm93IiwidGFibGVMaW5lIiwibWFya2Rvd24iLCJwdW5jdHVhdGlvbiIsIndhbGtUb2tlbnMiLCJsIiwiY29kZUxhbmciLCJjb2RlQmxvY2siLCJjbHMiLCJhdXRvbG9hZGVyIiwiRGF0ZSIsInZhbHVlT2YiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsb2FkTGFuZ3VhZ2VzIiwiZWxlIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwidGFnUGF0dGVybiIsIktOT1dOX0VOVElUWV9OQU1FUyIsImZyb21Db2RlUG9pbnQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJwYXJzZUludCIsIk51bWJlciIsImtub3duIiwibWQiLCJncmFwaHFsIiwiYWZ0ZXJUb2tlbml6ZUdyYXBocWwiLCJ2YWxpZFRva2VucyIsImZpbHRlciIsImN1cnJlbnRJbmRleCIsImdldFRva2VuIiwib2Zmc2V0IiwiaXNUb2tlblR5cGUiLCJ0eXBlcyIsImZpbmRDbG9zaW5nQnJhY2tldCIsIm9wZW4iLCJjbG9zZSIsInN0YWNrSGVpZ2h0IiwidGVzdCIsImFkZEFsaWFzIiwic3RhcnRUb2tlbiIsImlucHV0VmFyaWFibGVzIiwiZGVmaW5pdGlvbkVuZCIsInQiLCJtdXRhdGlvbkVuZCIsInZhclRva2VuIiwiaW5kZXhPZiIsInNxbCIsInRlbXBsYXRlU3RyaW5nIiwidGVtcGxhdGVMaXRlcmFsUGF0dGVybiIsImludGVycG9sYXRpb25PYmplY3QiLCJpbnRlcnBvbGF0aW9uUHVuY3R1YXRpb25PYmplY3QiLCJpbnRlcnBvbGF0aW9uUGF0dGVybiIsImNyZWF0ZVRlbXBsYXRlIiwidW5kZWZpbmVkIiwiQm9vbGVhbiIsImdldFBsYWNlaG9sZGVyIiwiY291bnRlciIsInRvVXBwZXJDYXNlIiwidG9rZW5pemVXaXRoSG9va3MiLCJ0b2tlbml6ZUludGVycG9sYXRpb25FeHByZXNzaW9uIiwiZXhwcmVzc2lvbiIsInRlbXBHcmFtbWFyIiwiYXJncyIsInNwbGljZSIsInRva2VuaXplRW1iZWRkZWQiLCJfdG9rZW5zIiwicGxhY2Vob2xkZXJDb3VudGVyIiwicGxhY2Vob2xkZXJNYXAiLCJlbWJlZGRlZENvZGUiLCJpbnRlcnBvbGF0aW9uRXhwcmVzc2lvbiIsInBsYWNlaG9sZGVyIiwiZW1iZWRkZWRUb2tlbnMiLCJwbGFjZWhvbGRlcnMiLCJrZXlzIiwic3Vic3RyaW5nIiwibWlkZGxlIiwicmVwbGFjZW1lbnQiLCJhZnRlclRva2VucyIsImNvbmNhdCIsInN1cHBvcnRlZExhbmd1YWdlcyIsImZpbmRUZW1wbGF0ZVN0cmluZ3MiLCJlbWJlZGRlZCIsInN0cmluZ0NvbnRlbnQiLCJ0eXBlc2NyaXB0IiwidHlwZUluc2lkZSIsInRzIiwid2l0aElkIiwidW5zaGlmdCIsIm1heWJlQ2xhc3NOYW1lVG9rZW5zIiwic3BhY2UiLCJicmFjZXMiLCJzcHJlYWQiLCJyZSIsImpzeCIsInN0cmluZ2lmeVRva2VuIiwib3BlbmVkVGFncyIsIm5vdFRhZ05vckJyYWNlIiwicG9wIiwib3BlbmVkQnJhY2VzIiwicGxhaW5UZXh0IiwiZGlmZiIsIlBSRUZJWEVTIiwicHJlZml4IiwiZ2l0IiwiZ28iLCJkZWZpbmVQcm9wZXJ0aWVzIiwiYnVpbGRQbGFjZWhvbGRlcnMiLCJwbGFjZWhvbGRlclBhdHRlcm4iLCJyZXBsYWNlRmlsdGVyIiwidG9rZW5TdGFjayIsInRva2VuaXplUGxhY2Vob2xkZXJzIiwiaGFuZGxlYmFycyIsImhhbmRsZWJhcnNQYXR0ZXJuIiwiaGJzIiwianNvbiIsIndlYm1hbmlmZXN0IiwibGVzcyIsIm1ha2VmaWxlIiwib2JqZWN0aXZlYyIsIm9iamMiLCJvY2FtbCIsInB5dGhvbiIsInB5IiwicmVhc29uIiwiZnVuY3Rpb24iLCJzYXNzIiwiYXRydWxlIiwib3BlcmF0b3IiLCJpbXBvcnRhbnQiLCJzY3NzIiwic3R5bHVzIiwiZnVuYyIsInRzeCIsIndhc20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prism-react-renderer/prism/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/prism-react-renderer/themes/duotoneDark/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/prism-react-renderer/themes/duotoneDark/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Duotone Dark\n// Author: Simurai, adapted from DuoTone themes for Atom (http://simurai.com/projects/2016/01/01/duotone-themes)\n// Conversion: Bram de Haan (http://atelierbram.github.io/Base2Tone-prism/output/prism/prism-base2tone-evening-dark.css)\n// Generated with Base16 Builder (https://github.com/base16-builder/base16-builder)\nvar theme = {\n    plain: {\n        backgroundColor: \"#2a2734\",\n        color: \"#9a86fd\"\n    },\n    styles: [\n        {\n            types: [\n                \"comment\",\n                \"prolog\",\n                \"doctype\",\n                \"cdata\",\n                \"punctuation\"\n            ],\n            style: {\n                color: \"#6c6783\"\n            }\n        },\n        {\n            types: [\n                \"namespace\"\n            ],\n            style: {\n                opacity: 0.7\n            }\n        },\n        {\n            types: [\n                \"tag\",\n                \"operator\",\n                \"number\"\n            ],\n            style: {\n                color: \"#e09142\"\n            }\n        },\n        {\n            types: [\n                \"property\",\n                \"function\"\n            ],\n            style: {\n                color: \"#9a86fd\"\n            }\n        },\n        {\n            types: [\n                \"tag-id\",\n                \"selector\",\n                \"atrule-id\"\n            ],\n            style: {\n                color: \"#eeebff\"\n            }\n        },\n        {\n            types: [\n                \"attr-name\"\n            ],\n            style: {\n                color: \"#c4b9fe\"\n            }\n        },\n        {\n            types: [\n                \"boolean\",\n                \"string\",\n                \"entity\",\n                \"url\",\n                \"attr-value\",\n                \"keyword\",\n                \"control\",\n                \"directive\",\n                \"unit\",\n                \"statement\",\n                \"regex\",\n                \"atrule\",\n                \"placeholder\",\n                \"variable\"\n            ],\n            style: {\n                color: \"#ffcc99\"\n            }\n        },\n        {\n            types: [\n                \"deleted\"\n            ],\n            style: {\n                textDecorationLine: \"line-through\"\n            }\n        },\n        {\n            types: [\n                \"inserted\"\n            ],\n            style: {\n                textDecorationLine: \"underline\"\n            }\n        },\n        {\n            types: [\n                \"italic\"\n            ],\n            style: {\n                fontStyle: \"italic\"\n            }\n        },\n        {\n            types: [\n                \"important\",\n                \"bold\"\n            ],\n            style: {\n                fontWeight: \"bold\"\n            }\n        },\n        {\n            types: [\n                \"important\"\n            ],\n            style: {\n                color: \"#c4b9fe\"\n            }\n        }\n    ]\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (theme);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJpc20tcmVhY3QtcmVuZGVyZXIvdGhlbWVzL2R1b3RvbmVEYXJrL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxlQUFlO0FBQ2YsZ0hBQWdIO0FBQ2hILHdIQUF3SDtBQUN4SCxtRkFBbUY7QUFDbkYsSUFBSUEsUUFBUTtJQUNWQyxPQUFPO1FBQ0xDLGlCQUFpQjtRQUNqQkMsT0FBTztJQUNUO0lBQ0FDLFFBQVE7UUFBQztZQUNQQyxPQUFPO2dCQUFDO2dCQUFXO2dCQUFVO2dCQUFXO2dCQUFTO2FBQWM7WUFDL0RDLE9BQU87Z0JBQ0xILE9BQU87WUFDVDtRQUNGO1FBQUc7WUFDREUsT0FBTztnQkFBQzthQUFZO1lBQ3BCQyxPQUFPO2dCQUNMQyxTQUFTO1lBQ1g7UUFDRjtRQUFHO1lBQ0RGLE9BQU87Z0JBQUM7Z0JBQU87Z0JBQVk7YUFBUztZQUNwQ0MsT0FBTztnQkFDTEgsT0FBTztZQUNUO1FBQ0Y7UUFBRztZQUNERSxPQUFPO2dCQUFDO2dCQUFZO2FBQVc7WUFDL0JDLE9BQU87Z0JBQ0xILE9BQU87WUFDVDtRQUNGO1FBQUc7WUFDREUsT0FBTztnQkFBQztnQkFBVTtnQkFBWTthQUFZO1lBQzFDQyxPQUFPO2dCQUNMSCxPQUFPO1lBQ1Q7UUFDRjtRQUFHO1lBQ0RFLE9BQU87Z0JBQUM7YUFBWTtZQUNwQkMsT0FBTztnQkFDTEgsT0FBTztZQUNUO1FBQ0Y7UUFBRztZQUNERSxPQUFPO2dCQUFDO2dCQUFXO2dCQUFVO2dCQUFVO2dCQUFPO2dCQUFjO2dCQUFXO2dCQUFXO2dCQUFhO2dCQUFRO2dCQUFhO2dCQUFTO2dCQUFVO2dCQUFlO2FBQVc7WUFDaktDLE9BQU87Z0JBQ0xILE9BQU87WUFDVDtRQUNGO1FBQUc7WUFDREUsT0FBTztnQkFBQzthQUFVO1lBQ2xCQyxPQUFPO2dCQUNMRSxvQkFBb0I7WUFDdEI7UUFDRjtRQUFHO1lBQ0RILE9BQU87Z0JBQUM7YUFBVztZQUNuQkMsT0FBTztnQkFDTEUsb0JBQW9CO1lBQ3RCO1FBQ0Y7UUFBRztZQUNESCxPQUFPO2dCQUFDO2FBQVM7WUFDakJDLE9BQU87Z0JBQ0xHLFdBQVc7WUFDYjtRQUNGO1FBQUc7WUFDREosT0FBTztnQkFBQztnQkFBYTthQUFPO1lBQzVCQyxPQUFPO2dCQUNMSSxZQUFZO1lBQ2Q7UUFDRjtRQUFHO1lBQ0RMLE9BQU87Z0JBQUM7YUFBWTtZQUNwQkMsT0FBTztnQkFDTEgsT0FBTztZQUNUO1FBQ0Y7S0FBRTtBQUNKO0FBRUEsaUVBQWVILEtBQUtBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC1jbGllbnQvLi9ub2RlX21vZHVsZXMvcHJpc20tcmVhY3QtcmVuZGVyZXIvdGhlbWVzL2R1b3RvbmVEYXJrL2luZGV4LmpzP2EzNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRHVvdG9uZSBEYXJrXG4vLyBBdXRob3I6IFNpbXVyYWksIGFkYXB0ZWQgZnJvbSBEdW9Ub25lIHRoZW1lcyBmb3IgQXRvbSAoaHR0cDovL3NpbXVyYWkuY29tL3Byb2plY3RzLzIwMTYvMDEvMDEvZHVvdG9uZS10aGVtZXMpXG4vLyBDb252ZXJzaW9uOiBCcmFtIGRlIEhhYW4gKGh0dHA6Ly9hdGVsaWVyYnJhbS5naXRodWIuaW8vQmFzZTJUb25lLXByaXNtL291dHB1dC9wcmlzbS9wcmlzbS1iYXNlMnRvbmUtZXZlbmluZy1kYXJrLmNzcylcbi8vIEdlbmVyYXRlZCB3aXRoIEJhc2UxNiBCdWlsZGVyIChodHRwczovL2dpdGh1Yi5jb20vYmFzZTE2LWJ1aWxkZXIvYmFzZTE2LWJ1aWxkZXIpXG52YXIgdGhlbWUgPSB7XG4gIHBsYWluOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBcIiMyYTI3MzRcIixcbiAgICBjb2xvcjogXCIjOWE4NmZkXCJcbiAgfSxcbiAgc3R5bGVzOiBbe1xuICAgIHR5cGVzOiBbXCJjb21tZW50XCIsIFwicHJvbG9nXCIsIFwiZG9jdHlwZVwiLCBcImNkYXRhXCIsIFwicHVuY3R1YXRpb25cIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcIiM2YzY3ODNcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJuYW1lc3BhY2VcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIG9wYWNpdHk6IDAuN1xuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJ0YWdcIiwgXCJvcGVyYXRvclwiLCBcIm51bWJlclwiXSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiI2UwOTE0MlwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcInByb3BlcnR5XCIsIFwiZnVuY3Rpb25cIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcIiM5YTg2ZmRcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJ0YWctaWRcIiwgXCJzZWxlY3RvclwiLCBcImF0cnVsZS1pZFwiXSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiI2VlZWJmZlwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcImF0dHItbmFtZVwiXSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiI2M0YjlmZVwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcImJvb2xlYW5cIiwgXCJzdHJpbmdcIiwgXCJlbnRpdHlcIiwgXCJ1cmxcIiwgXCJhdHRyLXZhbHVlXCIsIFwia2V5d29yZFwiLCBcImNvbnRyb2xcIiwgXCJkaXJlY3RpdmVcIiwgXCJ1bml0XCIsIFwic3RhdGVtZW50XCIsIFwicmVnZXhcIiwgXCJhdHJ1bGVcIiwgXCJwbGFjZWhvbGRlclwiLCBcInZhcmlhYmxlXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjZmZjYzk5XCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiZGVsZXRlZFwiXSxcbiAgICBzdHlsZToge1xuICAgICAgdGV4dERlY29yYXRpb25MaW5lOiBcImxpbmUtdGhyb3VnaFwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcImluc2VydGVkXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICB0ZXh0RGVjb3JhdGlvbkxpbmU6IFwidW5kZXJsaW5lXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiaXRhbGljXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiaW1wb3J0YW50XCIsIFwiYm9sZFwiXSxcbiAgICBzdHlsZToge1xuICAgICAgZm9udFdlaWdodDogXCJib2xkXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiaW1wb3J0YW50XCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjYzRiOWZlXCJcbiAgICB9XG4gIH1dXG59O1xuXG5leHBvcnQgZGVmYXVsdCB0aGVtZTtcbiJdLCJuYW1lcyI6WyJ0aGVtZSIsInBsYWluIiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3IiLCJzdHlsZXMiLCJ0eXBlcyIsInN0eWxlIiwib3BhY2l0eSIsInRleHREZWNvcmF0aW9uTGluZSIsImZvbnRTdHlsZSIsImZvbnRXZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prism-react-renderer/themes/duotoneDark/index.js\n");

/***/ })

};
;